#  -*- coding: utf-8 -*-
#
#  STochastic Engine for Pathway Simulation documentation build configuration file, created by
#  sphinx-quickstart on Thu Mar 20 12:02:04 2014.
#
#  This file is execfile()d with the current directory set to its
#  containing dir.
#
#  Note that not all possible configuration values are present in this
#  autogenerated file.
#
#  All configuration values have a default; values that are commented out
#  serve to show the default.

import steps

#  If extensions (or modules to document with autodoc) are in another directory,
#  add these directories to sys.path here. If the directory is relative to the
#  documentation root, use os.path.abspath to make it absolute, like shown here.
#  sys.path.insert(0, os.path.abspath('.'))

#  -- General configuration ------------------------------------------------

#  If your documentation needs a minimal Sphinx version, state it here.
#  needs_sphinx = '1.0'

#  Add any Sphinx extension module names here, as strings. They can be
#  extensions coming with Sphinx (named 'sphinx.ext.*') or your custom
#  ones.
extensions = [
    'sphinx.ext.autodoc',
    'sphinx.ext.doctest',
    'sphinx.ext.intersphinx',
    'sphinx.ext.todo',
    'sphinx.ext.coverage',
    'sphinx.ext.mathjax',
    'sphinx.ext.ifconfig',
    'sphinx.ext.viewcode',
    'nbsphinx',
]

#  Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

#  The suffix of source filenames.
source_suffix = '.rst'

add_module_names = False

#  The encoding of source files.
#  source_encoding = 'utf-8-sig'

#  The master toctree document.
master_doc = 'manual_index'

#  General information about the project.
project = u'STochastic Engine for Pathway Simulation'
copyright = u'2020, The STEPS Development Team'

#  The version info for the project you're documenting, acts as replacement for
#  |version| and |release|, also used in various other places throughout the
#  built documents.
#
#  The short X.Y version.
version = steps.__version__
#  The full version, including alpha/beta/rc tags.
release = steps.__version__

#  The language for content autogenerated by Sphinx. Refer to documentation
#  for a list of supported languages.
#  language = None

#  There are two options for replacing |today|: either, you set today to some
#  non-false value, then it is used:
#  today = ''
#  Else, today_fmt is used as the format for a strftime call.
#  today_fmt = '%B %d, %Y'

#  List of patterns, relative to source directory, that match files and
#  directories to ignore when looking for source files.
exclude_patterns = []

#  The reST default role (used for this markup: `text`) to use for all
#  documents.
#  default_role = None

#  If true, '()' will be appended to :func: etc. cross-reference text.
#  add_function_parentheses = True

#  If true, the current module name will be prepended to all description
#  unit titles (such as .. function::).
#  add_module_names = True

#  If true, sectionauthor and moduleauthor directives will be shown in the
#  output. They are ignored by default.
#  show_authors = False

#  The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

#  A list of ignored prefixes for module index sorting.
#  modindex_common_prefix = []

#  If true, keep warnings as "system message" paragraphs in the built documents.
#  keep_warnings = False


#  -- Options for HTML output ----------------------------------------------

#  The theme to use for HTML and HTML Help pages.  See the documentation for
#  a list of builtin themes.
html_theme = 'sphinx_rtd_theme'#'default'

#  Theme options are theme-specific and customize the look and feel of a theme
#  further.  For a list of options available for each theme, see the
#  documentation.
#  html_theme_options = {}

#  Add any paths that contain custom themes here, relative to this directory.
#  html_theme_path = []

#  The name for this set of Sphinx documents.  If None, it defaults to
#  "<project> v<release> documentation".
#  html_title = None

#  A shorter title for the navigation bar.  Default is the same as html_title.
#  html_short_title = None

#  The name of an image file (relative to this directory) to place at the top
#  of the sidebar.
#  html_logo = None

#  The name of an image file (within the static path) to use as favicon of the
#  docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
#  pixels large.
#  html_favicon = None

#  Add any paths that contain custom static files (such as style sheets) here,
#  relative to this directory. They are copied after the builtin static files,
#  so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

html_js_files = ['js/simpath.js']

#  Add any extra paths that contain custom files (such as robots.txt or
#  .htaccess) here, relative to this directory. These files are copied
#  directly to the root of the documentation.
html_extra_path = ['simpath.json']

# Generate json
import itertools
import json
import os
import re

LOCATIONS = {
    'Tet': ('Tetrahedron', ('TET(tet)', 'TETS(tetLst)')), 
    'Tri': ('Triangle', ('TRI(tri)', 'TRIS(triLst)')), 
    'Vert': ('Vertex', ('VERT(vert)', 'VERTS(vertLst)')), 
    'ROI': ('Region of Interest', 'roi'), 
    'Comp': ('Compartment', 'comp'), 
    'Patch': ('Patch', 'patch'), 
    'Memb': ('Membrane', 'memb'), 
    'DiffBoundary': ('Diff. Boundary', ('diffb', 'diffb(direc=comp2)')),
    'SDiffBoundary': ('Surf. Diff. Boundary', ('sdiffb', 'diffb(direc=patch2)')),
}
OBJECTS = {
    '': ('Species', 'spec'),
    'Reac': ('Reaction', ("reac['fwd']", "reac['bkw']")),
    'SReac': ('Reaction', ("reac['fwd']", "reac['bkw']")),
    'VDepSReac': ('Reaction', ("reac['fwd']", "reac['bkw']")),
    'Diff': ('Diffusion', ("diff", 'diff(direc=tet2)')),
    'SDiff': ('Diffusion', ("sdiff", 'sdiff(direc=tri2)')),
    'Ohmic': ('Current', 'curr'),
    'GHK': ('Current', 'curr'),
}
OBJ_PROPERTIES = [
    'Count', 'Conc', 'Amount', 'Clamped', 'K', 'Active',  'D',
    'C', 'H', 'A', 'Extent', 'I', 'DiffusionActive', 'Dcst', 
]
LOC_PROPERTIES = [
    'Area', 'Vol', 'V', 'VClamped', 'IClamp', 'Potential', 
    'Capac', 'VolRes', 'Res', 'I',
]

DOC_REPLACEMENT = {
    'direction_comp': 'direc',
    'direction_patch': 'direc',
    'direction_tet': 'direc',
    'direction_tri': 'direc',
}

INVALID_EXAMPLES = [
    re.compile('^.+diffb\(direc=[^\)]+\)\.[^\.]+\.DiffusionActive.*$'),
    re.compile('^.+(TETS|TRIS|comp|patch).+diff\(direc=[^\)]+\)\..*$'),
    re.compile('^.+diff\(direc=[^\)]+\)\.(Active|A).*$'),
]

for dct in [LOCATIONS, OBJECTS]:
    for loc, val in list(dct.items()):
        dct['Batch' + loc] = val

allMethodNames = {}
for comb in itertools.product(['get', 'set'], LOCATIONS.items(), OBJECTS.items(), OBJ_PROPERTIES, ['', 'sNP']):
    gs, loc, obj, prop, suff = comb
    name = gs + loc[0] + obj[0] + prop + suff
    allMethodNames[name] = (gs, loc[1], obj[1], prop)
for comb in itertools.product(['get', 'set'], LOCATIONS.items(), LOC_PROPERTIES, ['', 'sNP']):
    gs, loc, prop, suff = comb
    name = gs + loc[0] + prop + suff
    allMethodNames[name] = (gs, loc[1], None, prop)


def dctFill(dct, val):
    if val not in dct:
        dct[val] = {}
    return dct[val]


def processDoc(doc):
    res = ''
    lines = []
    for line in doc.split('\n')[1:]:
        if 'Syntax::' in line:
            break
        else:
            line = line.strip()
            for src, dst in DOC_REPLACEMENT.items():
                line = line.replace(src, dst)
            if len(line) == 0 and len(lines) > 0:
                res += '<p>' + ' '.join(lines) + '</p>'
                lines = []
            else:
                lines.append(line.strip())
    if len(lines) > 0:
        res += '<p>' + ' '.join(lines) + '</p>'
    return res

def parseMethod(dct, solverName, meth):
    gs, loc, obj, prop = allMethodNames[meth.__name__]

    allLines = ['sim']

    for item in [loc, obj]:
        if item is not None:
            item = item[1]
            if isinstance(item, str):
                item = (item,)
            allLines = [line + f'.{val}' for line in allLines for val in item]

    endLines = []
    for line in allLines:
        line += f'.{prop}'
        if gs == 'get':
            line = f'val = {line}'
        else:
            line = f'{line} = val'
        if all(p.match(line) is None for p in INVALID_EXAMPLES):
            endLines.append(line)

    examples = '</br>'.join(endLines)

    dct = dctFill(dct, gs)
    dct = dctFill(dct, solverName)
    dct = dctFill(dct, loc[0])
    if obj is not None:
        dct = dctFill(dct, obj[0])
    dct[prop] = examples + '@' + processDoc(meth.__doc__)

def getSolverClass(solverStr):
    from steps import stepslib
    import steps.API_2.sim as sim
    import steps.API_2.utils as utils
    if solverStr in sim.Simulation.SERIAL_SOLVERS:
        return getattr(stepslib, utils._CYTHON_PREFIX + solverStr)
    elif solverStr in sim.Simulation.PARALLEL_SOLVERS:
        return sim.MPI._getSolver(solverStr)
    return None

def GenerateJSON(path):
    import steps.API_2.sim as sim
    jsonData = {}
    solvers = sim.Simulation.SERIAL_SOLVERS + sim.Simulation.PARALLEL_SOLVERS
    for solverName in solvers:
        solvCls = getSolverClass(solverName)
        if solvCls is not None:
            for objName in dir(solvCls):
                obj = getattr(solvCls, objName)
                if callable(obj) and objName in allMethodNames:
                    parseMethod(jsonData, solverName, obj)

    with open(path, 'w') as f:
        json.dump(jsonData, f)

GenerateJSON(html_extra_path[0])

#  If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
#  using the given strftime format.
#  html_last_updated_fmt = '%b %d, %Y'

#  If true, SmartyPants will be used to convert quotes and dashes to
#  typographically correct entities.
#  html_use_smartypants = True

#  Custom sidebar templates, maps document names to template names.
#  html_sidebars = {}

#  Additional templates that should be rendered to pages, maps page names to
#  template names.
#  html_additional_pages = {}

#  If false, no module index is generated.
#  html_domain_indices = True

#  If false, no index is generated.
#  html_use_index = True

#  If true, the index is split into individual pages for each letter.
#  html_split_index = False

#  If true, links to the reST sources are added to the pages.
#  html_show_sourcelink = True

#  If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#  html_show_sphinx = True

#  If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#  html_show_copyright = True

#  If true, an OpenSearch description file will be output, and all pages will
#  contain a <link> tag referring to it.  The value of this option must be the
#  base URL from which the finished HTML is served.
#  html_use_opensearch = ''

#  This is the file name suffix for HTML files (e.g. ".xhtml").
#  html_file_suffix = None

#  Output file base name for HTML help builder.
htmlhelp_basename = 'STochasticEngineforPathwaySimulationdoc'


#  -- Options for LaTeX output ---------------------------------------------

latex_elements = {
    # The paper size ('letterpaper' or 'a4paper').
    # 'papersize': 'letterpaper',
    # The font size ('10pt', '11pt' or '12pt').
    # 'pointsize': '10pt',
    # Additional stuff for the LaTeX preamble.
    # 'preamble': '',
}

#  Grouping the document tree into LaTeX files. List of tuples
#  (source start file, target name, title,
#   author, documentclass [howto, manual, or own class]).
latex_documents = [
    (
        'index',
        'STochasticEngineforPathwaySimulation.tex',
        u'STochastic Engine for Pathway Simulation Documentation',
        u'The STEPS Development Team',
        'manual',
    )
]

#  The name of an image file (relative to this directory) to place at the top of
#  the title page.
#  latex_logo = None

#  For "manual" documents, if this is true, then toplevel headings are parts,
#  not chapters.
#  latex_use_parts = False

#  If true, show page references after internal links.
#  latex_show_pagerefs = False

#  If true, show URL addresses after external links.
#  latex_show_urls = False

#  Documents to append as an appendix to all manuals.
#  latex_appendices = []

#  If false, no module index is generated.
#  latex_domain_indices = True


#  -- Options for manual page output ---------------------------------------

#  One entry per manual page. List of tuples
#  (source start file, name, description, authors, manual section).
man_pages = [
    (
        'index',
        'stochasticengineforpathwaysimulation',
        u'STochastic Engine for Pathway Simulation Documentation',
        [u'The STEPS Development Team'],
        1,
    )
]

#  If true, show URL addresses after external links.
#  man_show_urls = False


#  -- Options for Texinfo output -------------------------------------------

#  Grouping the document tree into Texinfo files. List of tuples
#  (source start file, target name, title, author,
#   dir menu entry, description, category)
texinfo_documents = [
    (
        'index',
        'STochasticEngineforPathwaySimulation',
        u'STochastic Engine for Pathway Simulation Documentation',
        u'The STEPS Development Team',
        'STochasticEngineforPathwaySimulation',
        'One line description of project.',
        'Miscellaneous',
    )
]

#  Documents to append as an appendix to all manuals.
#  texinfo_appendices = []

#  If false, no module index is generated.
#  texinfo_domain_indices = True

#  How to display URL addresses: 'footnote', 'no', or 'inline'.
#  texinfo_show_urls = 'footnote'

#  If true, do not generate a @detailmenu in the "Top" node's menu.
#  texinfo_no_detailmenu = False


#  Example configuration for intersphinx: refer to the Python standard library.
intersphinx_mapping = {'http://docs.python.org/': None}

[extensions]
todo_include_todos = True


####################################################
# Configuration for generating API_2 documentation #
####################################################


import types

import steps
from steps.API_2 import model, geom, utils, sim

# Not sure if there is a better way to do this but if we do not return the descriptor itself
# during documentation, the __doc__ from the original function is not taken into account. 
# This might be due to how sphinx gets class attributes which trigger the call of the descriptor's
# __get__ method instead of returning the descriptor itself. To avoid this, we monkey patch the
# descriptor's __get__ method to return the descriptor instead of the normal value.
steps.API_2.utils.classproperty.__get__ = lambda self, *args: self

# -- Project information -----------------------------------------------------



# -- General configuration ---------------------------------------------------

# Add any Sphinx extension module names here, as strings. They can be
# extensions coming with Sphinx (named 'sphinx.ext.*') or your custom
# ones.
extensions += [
    'sphinx.ext.autosummary',
]

autodoc_default_options = {
    # 'members': True,
    'member-order': 'bysource',
    # 'special-members': True,
    # 'inherited-members': 'ndarray',
    # 'undoc-members': True,
    # 'exclude-members': '__weakref__'
}

def AllSubclasses(cls):
    for cls2 in cls.__subclasses__():
        yield cls2
        for cls3 in AllSubclasses(cls2):
            yield cls3

visualClasses = ['SimControl', 'PlotDisplay', 'TimePlot', 'SpatialPlot', 'NewRow', 'SimDisplay', 'ElementDisplay']

def autodoc_skip_member(app, what, name, obj, skip, options):
    if obj is not None and hasattr(obj, '__doc__'):
        if name.startswith('__'):
            if obj.__doc__ is not None and ':meta public:' in obj.__doc__:
                return False
            else:
                return True
        elif obj.__doc__ is not None and ':meta private:' in obj.__doc__:
            return True
        elif isinstance(obj, types.MethodType) and obj.__self__.__name__ in visualClasses:
            if obj.__name__ == 'Create' :
                return True
    return skip

replace_map = {
    '{{model.Reaction._FwdSpecifier}}': steps.API_2.model.Reaction._FwdSpecifier,
    '{{model.Reaction._BkwSpecifier}}': steps.API_2.model.Reaction._BkwSpecifier,
}
py_prefix = '_py_'

def autodoc_process_docstring(app, what, name, obj, options, lines):
    if isinstance(obj, types.MethodType) and obj.__name__ == 'Create' and obj.__self__.__name__ != 'NamedObject':
        lines[:] = [f"""
            Auto naming creation method, see :py:func:`steps.API_2.utils.NamedObject.Create` for auto naming syntax and :py:class:`{obj.__self__.__name__}` for arguments.
        """]
    # Replace the dosctring of ALL(...) methods
    if isinstance(obj, types.FunctionType) and obj.__name__ == 'ALL':
        if len(name.split('.')) > 2:
            *_, clsname, methname = name.split('.')
            if clsname not in ['NamedObject', 'SimPath', 'Simulation']:
                lines[:] = [f"""
                    Access the children of the object, see :py:func:`steps.API_2.utils.NamedObject.ALL` for details.
                """]
    # Replace the docstring of special methods in classes inheriting from RefList
    if isinstance(obj, types.FunctionType) and obj.__name__.startswith('__'):
        if len(name.split('.')) > 2:
            *_, clsname, methname = name.split('.')
            if methname == '__getattr__' and clsname not in ['NamedObject', 'SimPath', 'Simulation', 'ResultSelector', 'Parameter']:
                lines[:] = [f"""
                    Access the children of the object as if they were an attribute, see :py:func:`steps.API_2.utils.NamedObject.__getattr__` for details.
                """]
            elif clsname in [cls.__name__ for cls in steps.API_2.geom.RefList.__subclasses__()]:
                clsval = [cls for cls in steps.API_2.geom.RefList.__subclasses__() if cls.__name__ == clsname][0]
                refcls = clsval._refCls
                funcCls = obj.__qualname__.split('.')[0]
                if funcCls == steps.API_2.geom.RefList.__name__:
                    lines[:] = [f"""{lines[0]}

                        See :py:func:`RefList.{methname}` for details, replace 'RefList' by '{clsname}' and 'Reference' by '{refcls.__name__}' in the examples.
                    """]
            elif clsname in [cls.__name__ for cls in AllSubclasses(steps.API_2.model.ReactionElement)]:
                funcCls = obj.__qualname__.split('.')[0]
                if funcCls == steps.API_2.model.ReactionElement.__name__:
                    lines[:] = [f"""{lines[0]}

                        See :py:func:`ReactionElement.{methname}` for details.
                    """]
    for i in range(len(lines)):
        for key, repl in replace_map.items():
            if key in lines[i]:
                lines[i] = lines[i].replace(key, repl)

    if isinstance(obj, type) and 'API_1' in obj.__module__ and obj.__init__.__class__.__name__ == 'wrapper_descriptor':
        # Add __init__ docstring to the python class for cython classes
        for cls in obj.__mro__:
            if cls.__name__.startswith(py_prefix):
                lines[:] = lines + obj.__init__.__doc__.split('\n')
                break
    elif obj.__class__.__name__ == 'builtin_function_or_method' and obj.__name__.startswith(py_prefix):
        if re.match('\s*\w+\([\w\s,=]*\)', lines[0]) is not None:
            lines[:] = lines[1:]


def autodoc_process_signature(app, what, name, obj, options, signature, return_annotation):
    sig = tuple()
    if signature is None:
        # Try to build a signature from cython bindings
        if isinstance(obj, type) and 'API_1' in obj.__module__ and obj.__init__.__class__.__name__ == 'wrapper_descriptor':
            for cls in obj.__mro__:
                if cls.__name__.startswith(py_prefix):
                    signature = cls.__doc__.split('\n')[0].strip()
                    if '(' in signature:
                        signature = signature[signature.index('('):]
                    else:
                        signature = None
                    break

    if obj.__class__.__name__ == 'builtin_function_or_method' and obj.__name__.startswith(py_prefix):
        signature = obj.__doc__.split('\n')[0].strip()
        if '(' in signature:
            signature = signature[signature.index('('):]
        else:
            signature = None

    if signature is not None:
        for param in signature.strip('()').split(','):
            param = param.strip()
            if not (param.startswith('_') and '=' in param) and param != 'self':
                if ' ' in param:
                    sig += (param.split(' ')[-1],)
                else:
                    sig += (param,)
        return ('(' + ', '.join(sig) + ')', return_annotation)
    else:
        return (signature, return_annotation)


import sphinx.ext.autodoc as ad
from sphinx.ext.autodoc.importer import get_class_members
from docutils.statemachine import StringList
from sphinx.pycode import ModuleAnalyzer, PycodeError
from sphinx.ext.autodoc.mock import ismock
import copy
import inspect

class SpeMethDocumenter(ad.MethodDocumenter):
    def format_name(self) -> str:
        return super().format_name().split('.')[-1]

class SubFacadeDocumenter(ad.ClassDocumenter):
    def __init__(self, excluded, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self._excluded = excluded
        self.doc_as_attr = None

    def filter_members(self, members, want_all):
        filtered = super().filter_members(members, want_all)
        return [(name, obj, val) for name, obj, val in filtered if name not in self._excluded]

    @property
    def documenters(self):
        """Returns registered Documenter classes"""
        docs = copy.copy(self.env.app.registry.documenters)
        for name, docCls in docs.items():
            class TmpDocClass(docCls):
                def format_name(self):
                    return super().format_name().split('.')[-1]
            docs[name] = TmpDocClass
        return docs

    def generate(self, more_content=None, real_modname=None,
                 check_module=False, all_members=False):
        """Generate reST for the object given by *self.name*, and possibly for
        its members.
        If *more_content* is given, include that content. If *real_modname* is
        given, use that module name to find attribute docs. If *check_module* is
        True, only generate if the object is defined in the module name it is
        imported from. If *all_members* is True, document all members.
        """
        if not self.parse_name():
            # need a module to import
            logger.warning(
                __('don\'t know which module to import for autodocumenting '
                   '%r (try placing a "module" or "currentmodule" directive '
                   'in the document, or giving an explicit module name)') %
                self.name, type='autodoc')
            return

        # now, import the module and get object to document
        if not self.import_object():
            return

        # If there is no real module defined, figure out which to use.
        # The real module is used in the module analyzer to look up the module
        # where the attribute documentation would actually be found in.
        # This is used for situations where you have a module that collects the
        # functions and classes of internal submodules.
        guess_modname = self.get_real_modname()
        self.real_modname: str = real_modname or guess_modname

        # try to also get a source code analyzer for attribute docs
        try:
            self.analyzer = ModuleAnalyzer.for_module(self.real_modname)
            # parse right now, to get PycodeErrors on parsing (results will
            # be cached anyway)
            self.analyzer.find_attr_docs()
        except PycodeError as exc:
            logger.debug('[autodoc] module analyzer failed: %s', exc)
            # no source file -- e.g. for builtin and C modules
            self.analyzer = None
            # at least add the module.__file__ as a dependency
            if hasattr(self.module, '__file__') and self.module.__file__:
                self.directive.record_dependencies.add(self.module.__file__)
        else:
            self.directive.record_dependencies.add(self.analyzer.srcname)

        if self.real_modname != guess_modname:
            # Add module to dependency list if target object is defined in other module.
            try:
                analyzer = ModuleAnalyzer.for_module(guess_modname)
                self.directive.record_dependencies.add(analyzer.srcname)
            except PycodeError:
                pass

        docstrings: List[str] = sum(self.get_doc() or [], [])
        if ismock(self.object) and not docstrings:
            logger.warning(__('A mocked object is detected: %r'),
                           self.name, type='autodoc')

        # check __module__ of object (for members not given explicitly)
        if check_module:
            if not self.check_module():
                return

        sourcename = self.get_sourcename()

        # make sure that the result starts with an empty line.  This is
        # necessary for some situations where another directive preprocesses
        # reST and no starting newline is present
        self.add_line('', sourcename)

        # format the object's signature, if any
        try:
            sig = self.format_signature()
        except Exception as exc:
            logger.warning(__('error while formatting signature for %s: %s'),
                           self.fullname, exc, type='autodoc')
            return

        # generate the directive header and options, if applicable
        # self.add_directive_header(sig)
        # self.add_line('', sourcename)

        # e.g. the module directive doesn't have content
        self.indent += self.content_indent

        # add all content (from docstrings, attribute docs etc.)
        # self.add_content(more_content)

        # document members, if possible
        self.document_members(all_members)

class ClassDocumenter(ad.ClassDocumenter):
    @staticmethod
    def getSubClasses(cls):
        subClasses = set()
        for subcls in cls.__subclasses__():
            subClasses.add(subcls)
            subClasses |= ClassDocumenter.getSubClasses(subcls)
        return subClasses

    def generate(self, *args, **kwargs):
        super().generate(*args, **kwargs)

        if issubclass(self.object, utils.Facade):
            subclasses = sorted(self.getSubClasses(self.object), key=lambda c: (inspect.getmodule(c), inspect.getsourcelines(c)[1]))
            # print(inspect.getsourcelines(list(subclasses)[0]))
            # print(subclasses)
            for subcls in subclasses:
                try:
                    sectionTitle = getattr(subcls, utils.Facade._FACADE_ATTR_NAME)
                    if sectionTitle is not None:
                        self.add_line(f'**{sectionTitle}**', self.get_sourcename())
                        full_name = subcls.__module__ + '.' + subcls.__qualname__
                        excluded = set()
                        for parent in subcls.__bases__:
                            excluded |= set(dir(parent))
                        documenter = SubFacadeDocumenter(excluded, self.directive, full_name, self.indent + '   ')
                        documenter.generate()
                except:
                    pass


        # print(self.object)
        # # print(ad.MethodDocumenter.can_document_member(geom._DistRefList.isLocal, 'isLocal', False, geom._DistRefList))
        # # full_mname = self.modname + '::' + '.'.join(['_DistRefList'] + ['isLocal'])
        # full_mname = 'steps.API_2.geom' + '::' + '.'.join(['_DistRefList'] + ['isLocal'])
        # documenter = SpeMethDocumenter(self.directive, full_mname, self.indent + '  ')

        # # self.add_line('.. admonition:: Special Title', self.get_sourcename())
        # self.add_line('**Special Title**', self.get_sourcename())
        # documenter.generate()

        # documenter.generate(all_members=True, real_modname=self.real_modname)
        # self.
        # classes = [cls for cls in self.documenters.values()
                       # if cls.can_document_member(member, mname, isattr, self)]
            # if not classes:
                # # don't know how to document this member
                # continue
            # # prefer the documenter with the highest priority
            # classes.sort(key=lambda cls: cls.priority)
            # # give explicitly separated module name, so that members
            # # of inner classes can be documented
            # full_mname = self.modname + '::' + '.'.join(self.objpath + [mname])
            # documenter = classes[-1](self.directive, full_mname, self.indent)
            # memberdocumenters.append((documenter, isattr))

        # member_order = self.options.member_order or self.config.autodoc_member_order
        # memberdocumenters = self.sort_members(memberdocumenters, member_order)

        # for documenter, isattr in memberdocumenters:
            # documenter.generate(
                # all_members=True, real_modname=self.real_modname,
                # check_module=members_check_module and not isattr)

    # def add_content(self, more_content, no_docstring=False):
        # more_content = StringList(['TEST1', 'TEST2'], source='')
        # super().add_content(more_content, no_docstring)

    # def add_directive_header(self, sig: str) -> None:
        # super().add_directive_header(sig)
        # print(sig)

def setup(app):
    app.connect('autodoc-skip-member', autodoc_skip_member)
    app.connect('autodoc-process-docstring', autodoc_process_docstring)
    app.connect('autodoc-process-signature', autodoc_process_signature)
    #
    app.add_autodocumenter(ClassDocumenter, override=True)

