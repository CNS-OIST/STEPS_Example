#  -*- coding: utf-8 -*-
#
#  STochastic Engine for Pathway Simulation documentation build configuration file, created by
#  sphinx-quickstart on Thu Mar 20 12:02:04 2014.
#
#  This file is execfile()d with the current directory set to its
#  containing dir.
#
#  Note that not all possible configuration values are present in this
#  autogenerated file.
#
#  All configuration values have a default; values that are commented out
#  serve to show the default.

import inspect
import itertools
import json
import os
import re
import steps
import sys
import types

from steps import stepslib
from steps.API_2 import model, geom, utils, sim

#  If extensions (or modules to document with autodoc) are in another directory,
#  add these directories to sys.path here. If the directory is relative to the
#  documentation root, use os.path.abspath to make it absolute, like shown here.
#  sys.path.insert(0, os.path.abspath('.'))

#  -- General configuration ------------------------------------------------

#  If your documentation needs a minimal Sphinx version, state it here.
#  needs_sphinx = '1.0'

sys.path.append(os.path.abspath("./_ext"))

#  Add any Sphinx extension module names here, as strings. They can be
#  extensions coming with Sphinx (named 'sphinx.ext.*') or your custom
#  ones.
extensions = [
    'sphinx.ext.autodoc',
    'sphinx.ext.doctest',
    'sphinx.ext.intersphinx',
    'sphinx.ext.todo',
    'sphinx.ext.coverage',
    'sphinx.ext.mathjax',
    'sphinx.ext.ifconfig',
    'sphinx.ext.viewcode',
    'sphinx.ext.inheritance_diagram',
    'nbsphinx',
    'autodoc_facade',
]

#  Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

#  The suffix of source filenames.
source_suffix = '.rst'

add_module_names = False

#  The encoding of source files.
#  source_encoding = 'utf-8-sig'

#  The master toctree document.
master_doc = 'index'

#  General information about the project.
project = u'STochastic Engine for Pathway Simulation'
copyright = u'2020, The STEPS Development Team'

#  The version info for the project you're documenting, acts as replacement for
#  |version| and |release|, also used in various other places throughout the
#  built documents.
#
#  The short X.Y version.
version = steps.__version__
#  The full version, including alpha/beta/rc tags.
release = steps.__version__

#  The language for content autogenerated by Sphinx. Refer to documentation
#  for a list of supported languages.
#  language = None

#  There are two options for replacing |today|: either, you set today to some
#  non-false value, then it is used:
#  today = ''
#  Else, today_fmt is used as the format for a strftime call.
#  today_fmt = '%B %d, %Y'

#  List of patterns, relative to source directory, that match files and
#  directories to ignore when looking for source files.
exclude_patterns = []

#  The reST default role (used for this markup: `text`) to use for all
#  documents.
#  default_role = None

#  If true, '()' will be appended to :func: etc. cross-reference text.
#  add_function_parentheses = True

#  If true, the current module name will be prepended to all description
#  unit titles (such as .. function::).
#  add_module_names = True

#  If true, sectionauthor and moduleauthor directives will be shown in the
#  output. They are ignored by default.
#  show_authors = False

#  The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

#  A list of ignored prefixes for module index sorting.
#  modindex_common_prefix = []

#  If true, keep warnings as "system message" paragraphs in the built documents.
#  keep_warnings = False


#  -- Options for HTML output ----------------------------------------------

#  The theme to use for HTML and HTML Help pages.  See the documentation for
#  a list of builtin themes.
html_theme = 'sphinx_rtd_theme'

#  Theme options are theme-specific and customize the look and feel of a theme
#  further.  For a list of options available for each theme, see the
#  documentation.
html_theme_options = {'logo_only': True}

#  Add any paths that contain custom themes here, relative to this directory.
#  html_theme_path = []

#  The name for this set of Sphinx documents.  If None, it defaults to
#  "<project> v<release> documentation".
#  html_title = None

#  A shorter title for the navigation bar.  Default is the same as html_title.
#  html_short_title = None

#  The name of an image file (relative to this directory) to place at the top
#  of the sidebar.
html_logo = '_static/logo.svg'

#  The name of an image file (within the static path) to use as favicon of the
#  docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
#  pixels large.
#  html_favicon = None

#  Add any paths that contain custom static files (such as style sheets) here,
#  relative to this directory. They are copied after the builtin static files,
#  so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

html_css_files = ['css/paraview.css', 'css/user_guide.css']

html_js_files = ['js/simpath.js']

#  Add any extra paths that contain custom files (such as robots.txt or
#  .htaccess) here, relative to this directory. These files are copied
#  directly to the root of the documentation.
html_extra_path = [
    'simpath.json',
]

# Generate json

LOCATIONS = {
    # NameInMethods: (Full name, examples, doc link)
    # examples -> ['name'] or [('name', 'name in descr')]
    'Comp': (
        'Compartment',
        ['comp'],
        'API_geom.html#steps.API_2.geom.Compartment',
    ),
    'Patch': (
        'Patch',
        ['patch'],
        'API_geom.html#steps.API_2.geom.Patch',
    ),
    'Memb': (
        'Membrane',
        ['memb'],
        'API_geom.html#steps.API_2.geom.Membrane',
    ),
    'DiffBoundary': (
        'Diff. Boundary',
        ['diffb', ('diffb(direc=comp2)', 'diffb in direction of comp2')],
        'API_geom.html#steps.API_2.geom.DiffBoundary',
    ),
    'SDiffBoundary': (
        'Surf. Diff. Boundary',
        ['sdiffb', ('diffb(direc=patch2)', 'diffb in direction of patch2')],
        'API_geom.html#steps.API_2.geom.SDiffBoundary',
    ),
    'ROI': (
        'Region of Interest',
        ['roi'],
        'API_geom.html#steps.API_2.geom.ROI',
    ),
    'Tet': (
        'Tetrahedron',
        [('TET(tet)', 'tet'), ('TETS(tetLst)', 'list tetLst')],
        'API_geom.html#steps.API_2.geom.TetReference',
    ),
    'Tri': (
        'Triangle',
        [('TRI(tri)', 'tri'), ('TRIS(triLst)', 'list triLst')],
        'API_geom.html#steps.API_2.geom.TriReference',
    ),
    'Vert': (
        'Vertex',
        [('VERT(vert)', 'vert'), ('VERTS(vertLst)', 'list vertLst')],
        'API_geom.html#steps.API_2.geom.VertReference',
    ),
    'Ves': (
        'Vesicle',
        ['ves'],
        'API_model.html#steps.API_2.model.Vesicle',
    ),
    'SingleVesicle': (
        'Vesicle',
        [('VESICLE(vesref)', 'vesref'), ('VESICLES(vesLst)', 'list vesLst')],
        'API_sim.html#steps.API_2.sim.VesicleReference',
    ),
    'SingleVesicleSurface': (
        'Vesicle surface',
        [("VESICLE(vesref)('surf')", 'vesref'), ("VESICLES(vesLst)('surf')", "list vesLst")],
        'API_sim.html#steps.API_2.sim.VesicleReference.__call__',
    ),
    'SingleVesicleInner': (
        'Vesicle inside',
        [("VESICLE(vesref)('in')", "vesref"), ("VESICLES(vesLst)('in')", "list vesLst")],
        'API_sim.html#steps.API_2.sim.VesicleReference.__call__',
    ),
    'Exocytosis': (
        'Exocytosis',
        ['exo'],
        'API_model.html#steps.API_2.model.Exocytosis',
    ),
    'Raft': (
        'Raft',
        ['raft'],
        'API_model.html#steps.API_2.model.Raft',
    ),
    'SingleRaft': (
        'Raft',
        [('RAFT(raftref)', "raftref"), ('RAFTS(raftLst)', "list raftLst")],
        'API_sim.html#steps.API_2.sim.RaftReference',
    ),
    'RaftEndocytosis': (
        'Raft Endocytosis',
        ['rendo'],
        'API_model.html#steps.API_2.model.RaftEndocytosis',
    ),
}

OBJECTS = {
    # NameInMethods: (Full name, examples, doc link)
    # examples -> ['name'] or [('name', 'name in descr')]
    'Spec': (
        'Species',
        ['spec'],
        'API_model.html#steps.API_2.model.Species',
    ),
    'LinkSpec': (
        'Link Species',
        ['linkspec'],
        'API_model.html#steps.API_2.model.LinkSpecies',
    ),
    'Reac': (
        'Reaction',
        [("reac['fwd']", "reac (forward)"), ("reac['bkw']", "reac (backward)")],
        'API_model.html#steps.API_2.model.Reaction',
    ),
    'SReac': (
        'Reaction',
        [("sreac['fwd']", "sreac (forward)"), ("sreac['bkw']", "sreac (backward)")],
        'API_model.html#steps.API_2.model.Reaction',
    ),
    'VDepSReac': (
        'Reaction',
        [("reac['fwd']", "reac (forward)"), ("reac['bkw']", "reac (backward)")],
        'API_model.html#steps.API_2.model.Reaction',
    ),
    'Diff': (
        'Diffusion',
        ["diff", ('diff(direc=tet2)', 'diff towards tet2')],
        'API_model.html#steps.API_2.model.Diffusion',
    ),
    'SDiff': (
        'Diffusion',
        ["sdiff", ('sdiff(direc=tri2)', 'sdiff towards tri2')],
        'API_model.html#steps.API_2.model.Diffusion',
    ),
    'Ohmic': (
        'Current',
        ['curr'],
        'API_model.html#steps.API_2.model.OhmicCurr',
    ),
    'GHK': (
        'Current',
        ['curr'],
        'API_model.html#steps.API_2.model.GHKCurr',
    ),
    'Ves': (
        'Vesicle',
        ['ves'],
        'API_model.html#steps.API_2.model.Vesicle',
    ),
    'Vesicle': (
        'Vesicle',
        ['ves'],
        'API_model.html#steps.API_2.model.Vesicle',
    ),
    'VesicleSurface': (
        'Vesicle surface',
        [("VESICLE(ves)('surf')", "ves"), ("VESICLES(vesLst)('surf')", "list vesLst")],
        'API_model.html#steps.API_2.model.Vesicle.__call__',
    ),
    'VesicleInner': (
        'Vesicle inside',
        [("VESICLE(ves)('in')", "ves"), ("VESICLES(vesLst)('in')", "list vesLst")],
        'API_model.html#steps.API_2.model.Vesicle.__call__',
    ),
    'Raft': (
        'Raft',
        ['raft'],
        'API_model.html#steps.API_2.model.Raft',
    ),
    'SingleRaft': (
        'Raft',
        [('RAFT(raftref)', 'raftref'), ('RAFTS(raftLst)', 'list raftLst')],
        'API_sim.html#steps.API_2.sim.RaftReference',
    ),
    'EndocyticZone': (
        'Endocytic zone',
        ['endoZone'],
        'API_geom.html#steps.API_2.geom.EndocyticZone',
    ),
    'RaftEndocytosis': (
        'Raft Endocytosis',
        ['rendo'],
        'API_model.html#steps.API_2.model.RaftEndocytosis',
    ),
    'Exocytosis': (
        'Exocytosis',
        ['exo'],
        'API_model.html#steps.API_2.model.Exocytosis',
    ),
}

OBJ_PROPERTIES = {
    # Prop: (getValue, setValue, short description)
    'Count': (
        'cnt',
        'n',
        'number',
    ),
    'Conc': (
        'conc',
        'conc',
        'concentration',
    ),
    'Amount': (
        'val',
        'a',
        'the amount',
    ),
    'Clamped': (
        'clamped',
        'clamped',
        'clamped status',
    ),
    'K': (
        'val',
        'kf',
        'reaction constant',
    ),
    'Active': (
        'active',
        'active',
        'active status',
    ),
    'D': (
        'dcst',
        'dcst',
        'diffusion constant',
    ),
    'C': (
        'val',
        'val',
        'stochastic reaction constant',
    ),
    'H': (
        'val',
        'val',
        'number of reactant combinations h_mu',
    ),
    'A': (
        'val',
        'val',
        'propensity',
    ),
    'Extent': (
        'val',
        'val',
        'extent',
    ),
    'I': (
        'val',
        'val',
        'current',
    ),
    'DiffusionActive': (
        'val',
        'val',
        'active status',
    ),
    'Dcst': (
        'val',
        'val',
        'diffusion constant',
    ),
    'Pos': (
        'pos',
        'pos',
        'position in cartesian coordinates',
    ),
    'PosSpherical': (
        'spos',
        'spos',
        'position in spherical coordinated',
    ),
}

LOC_PROPERTIES = {
    # Prop: (getValue, setValue, short description)
    'Area': (
        'val',
        'val',
        'area',
    ),
    'Vol': (
        'val',
        'val',
        'volume',
    ),
    'V': (
        'val',
        'val',
        'potential',
    ),
    'VClamped': (
        'clamped',
        'clamped',
        'clamped status of potential',
    ),
    'IClamp': (
        'val',
        'i',
        'current clamp',
    ),
    'Potential': (
        'val',
        'val',
        'potential',
    ),
    'Capac': (
        'cap',
        'cap',
        'capacitance',
    ),
    'VolRes': (
        'val',
        'val',
        'bulk electrical resistivity',
    ),
    'Res': (
        'ro, vrev',
        'steps.utils.Params(ro, vrev)',
        'electrical resistivity',
    ),
    'I': (
        'val',
        'val',
        'the current',
    ),
    'Pos': (
        'pos',
        'pos',
        'position in cartesian coordinates'
    ),
    'PosSpherical': (
        'spos',
        'spos',
        'position in spherical coordinated',
    ),
    'Immobility': (
        'immob',
        'immob',
        'immobility status',
    ),
    'Events': (
        'events',
        'events',
        'list of events',
    ),
    'K': (
        'val',
        'kf',
        'rate',
    ),
}

REV_LOC_MAP = {long: short for short, (long, *_) in LOCATIONS.items()}

DOC_REPLACEMENT = {
    'direction_comp': 'direc',
    'direction_patch': 'direc',
    'direction_tet': 'direc',
    'direction_tri': 'direc',
    'with\sindex\sidx': lambda loc: REV_LOC_MAP[loc].lower(),
    'ohmic\scurrent': 'ohmic or GHK current with string identifier curr',
}

DOC_STOP_LINES = [
    r'Syntax::',
    r':param',
    r':rtype',
]

INVALID_EXAMPLES = [
    re.compile('^.+diffb\(direc=[^\)]+\)\.[^\.]+\.DiffusionActive.*$'),
    re.compile('^.+(TETS|TRIS|comp|patch).+diff\(direc=[^\)]+\)\..*$'),
    re.compile('^.+diff\(direc=[^\)]+\)\.(Active|A|Extent).*$'),
    re.compile('^.+direction_(tet|tri)=.+$'),
    re.compile('^.+local=False.+$'),
]

TET_SOLVERS = [
    solv for solv in sim.Simulation.SERIAL_SOLVERS + sim.Simulation.PARALLEL_SOLVERS if 'tet' in solv.lower()
]

INVALID_METHODS = [(solv, 'setCompVol') for solv in TET_SOLVERS]
INVALID_METHODS += [(solv, 'setPatchArea') for solv in TET_SOLVERS]

for dct in [LOCATIONS, OBJECTS]:
    for loc, val in list(dct.items()):
        dct['Batch' + loc] = val

allMethodNames = {}
for comb in itertools.product(['get', 'set'], LOCATIONS.items(), OBJECTS.items(), OBJ_PROPERTIES.items(), ['', 'sNP']):
    gs, loc, obj, prop, suff = comb
    name = gs + loc[0] + obj[0] + prop[0] + suff
    allMethodNames[name] = (gs, loc[1], obj[1], prop)
for comb in itertools.product(['get', 'set'], LOCATIONS.items(), LOC_PROPERTIES.items(), ['', 'sNP']):
    gs, loc, prop, suff = comb
    name = gs + loc[0] + prop[0] + suff
    allMethodNames[name] = (gs, loc[1], None, prop)


def generateDescription(meth):
    gs, loc, obj, prop = allMethodNames[meth.__name__]
    allProps = {}
    if loc is not None:
        allProps = LOC_PROPERTIES
    if obj is not None:
        allProps = {**allProps, **OBJ_PROPERTIES}
    propDescr = allProps.get(prop[0], (None, None, prop[0]))[-1]
    descr = f'{gs[0].upper() + gs[1:]} the <a href="#steps.API_2.sim.SimPath.{prop[0]}">{propDescr}</a>'
    if prop[0] in sim.SimPath._PATH_END_UNITS:
        unit = sim.SimPath._PATH_END_UNITS[prop[0]]
        if isinstance(unit, utils.Units) and not unit._isDimensionless():
            descr += f' (in {unit._toUnicode()})'
    if obj is None:
        if loc is None:
            descr += f' of the simulation'
        else:
            loctpe, locid, locdoc = loc
            if not isinstance(locid, str):
                locid = locid[0]
            descr += f' of <a href="{locdoc}">{loctpe}</a> {locid}'
    else:
        objtpe, objid, objdoc = obj
        if not isinstance(objid, str):
            objid = objid[0]
        descr += f' of <a href="{objdoc}">{objtpe}</a> {objid}'
        if loc is not None:
            loctpe, locid, locdoc = loc
            if not isinstance(locid, str):
                locid = locid[0]
            descr += f' in <a href="{locdoc}">{loctpe}</a> {locid}'
    return descr + '.'


def processDoc(doc, loc):
    res = ''
    signature, *doc = doc.split('\n')
    # Extract kwargs
    kwargs = re.findall(r'(\w+)\s*=\s*(?:_py_)?([\w\.]+)', signature)

    lines = []
    for line in doc:
        if any(re.search(rexp, line) is not None for rexp in DOC_STOP_LINES):
            break
        else:
            line = line.strip()
            if len(line) == 0 and len(lines) > 0:
                res += '<p>' + ' '.join(lines) + '</p>'
                lines = []
            else:
                lines.append(line.strip())
    if len(lines) > 0:
        res += '<p>' + ' '.join(lines) + '</p>'

    for src, dst in DOC_REPLACEMENT.items():
        if callable(dst):
            res = re.sub(src, dst(loc), res)
        else:
            res = re.sub(src, dst, res)

    return res, kwargs

def parseMethod(dct, solverName, method):
    gs, loc, obj, prop = allMethodNames[method.__name__]

    parts = [['sim']]
    names = []
    docs = []
    for item in [loc, obj]:
        if item is not None:
            name, examples, doc = item
            names.append(name)
            parts.append(examples)
            docs.append(doc)
    
    for comb in itertools.product(*parts):

    # locExamples, objExamples = [], []
    # if loc is not None:
    #     locName, locExamples, locDoc = loc
    # if obj is not None:
    #     objName, objExamples, objDoc = obj

    print(loc, obj, prop)

def parseMethod_old(dct, solverName, meth):
    gs, loc, obj, prop = allMethodNames[meth.__name__]

    allLines = ['sim']
    doc, kwargs = processDoc(meth.__doc__, loc[0])
    # TMP
    doc = generateDescription(meth) + '\n' + doc

    for item in [loc, obj]:
        if item is not None:
            item = item[1]
            if isinstance(item, str):
                item = (item,)
            allLines = [line + f'.{val}' for line in allLines for val in item]

    endLines = []
    for line in allLines:
        line = f'{line}.{prop[0]}'
        if gs == 'get':
            line = f'{prop[1][0]} = {line}'
        else:
            line = f'{line} = {prop[1][1]}'
        if all(p.match(line) is None for p in INVALID_EXAMPLES):
            endLines.append(line)
    if len(kwargs) > 0:
        for line in allLines:
            if gs == 'set':
                line = f'{line}.{prop[0]} = steps.utils.Params({prop[1][1]}'
                for name, val in kwargs:
                    line += f', {name}={val}'
                line += ')'
                if all(p.match(line) is None for p in INVALID_EXAMPLES):
                    endLines.append(line)

    dct = dct.setdefault(gs, {}).setdefault(
        solverName, {}).setdefault(loc[0], {})
    if obj is not None:
        dct = dct.setdefault(obj[0], {})
    if prop[0] not in dct:
        dct[prop[0]] = {'@code': endLines, '@doc': doc}


def getSolverClass(solverStr):
    if solverStr in sim.Simulation.SERIAL_SOLVERS:
        return getattr(stepslib, utils._CYTHON_PREFIX + solverStr)
    elif solverStr in sim.Simulation.PARALLEL_SOLVERS and solverStr != 'TetVesicle':
        return sim.MPI._getSolver(solverStr)
    if solverStr == 'TetVesicle':
        return stepslib._py_TetVesicleVesRaft
    return None


def GenerateJSON(path):
    jsonData = {}
    solvers = sim.Simulation.SERIAL_SOLVERS + sim.Simulation.PARALLEL_SOLVERS
    for solverName in solvers:
        solvCls = getSolverClass(solverName)
        if solvCls is not None:
            for methodName in allMethodNames:
                if (solverName, methodName) in INVALID_METHODS:
                    continue
                try:
                    obj = getattr(solvCls, methodName)
                except:
                    continue
                if callable(obj):
                    parseMethod(jsonData, solverName, obj)

    with open(path, 'w') as f:
        json.dump(jsonData, f)


GenerateJSON(html_extra_path[0])

#  If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
#  using the given strftime format.
#  html_last_updated_fmt = '%b %d, %Y'

#  If true, SmartyPants will be used to convert quotes and dashes to
#  typographically correct entities.
#  html_use_smartypants = True

#  Custom sidebar templates, maps document names to template names.
#  html_sidebars = {}

#  Additional templates that should be rendered to pages, maps page names to
#  template names.
#  html_additional_pages = {}

#  If false, no module index is generated.
#  html_domain_indices = True

#  If false, no index is generated.
#  html_use_index = True

#  If true, the index is split into individual pages for each letter.
#  html_split_index = False

#  If true, links to the reST sources are added to the pages.
#  html_show_sourcelink = True

#  If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#  html_show_sphinx = True

#  If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#  html_show_copyright = True

#  If true, an OpenSearch description file will be output, and all pages will
#  contain a <link> tag referring to it.  The value of this option must be the
#  base URL from which the finished HTML is served.
#  html_use_opensearch = ''

#  This is the file name suffix for HTML files (e.g. ".xhtml").
#  html_file_suffix = None

#  Output file base name for HTML help builder.
htmlhelp_basename = 'STochasticEngineforPathwaySimulationdoc'


#  -- Options for LaTeX output ---------------------------------------------

latex_elements = {
    # The paper size ('letterpaper' or 'a4paper').
    # 'papersize': 'letterpaper',
    # The font size ('10pt', '11pt' or '12pt').
    # 'pointsize': '10pt',
    # Additional stuff for the LaTeX preamble.
    # 'preamble': '',
}

#  Grouping the document tree into LaTeX files. List of tuples
#  (source start file, target name, title,
#   author, documentclass [howto, manual, or own class]).
latex_documents = [
    (
        'index',
        'STochasticEngineforPathwaySimulation.tex',
        u'STochastic Engine for Pathway Simulation Documentation',
        u'The STEPS Development Team',
        'manual',
    )
]

#  The name of an image file (relative to this directory) to place at the top of
#  the title page.
#  latex_logo = None

#  For "manual" documents, if this is true, then toplevel headings are parts,
#  not chapters.
#  latex_use_parts = False

#  If true, show page references after internal links.
#  latex_show_pagerefs = False

#  If true, show URL addresses after external links.
#  latex_show_urls = False

#  Documents to append as an appendix to all manuals.
#  latex_appendices = []

#  If false, no module index is generated.
#  latex_domain_indices = True


#  -- Options for manual page output ---------------------------------------

#  One entry per manual page. List of tuples
#  (source start file, name, description, authors, manual section).
man_pages = [
    (
        'index',
        'stochasticengineforpathwaysimulation',
        u'STochastic Engine for Pathway Simulation Documentation',
        [u'The STEPS Development Team'],
        1,
    )
]

#  If true, show URL addresses after external links.
#  man_show_urls = False


#  -- Options for Texinfo output -------------------------------------------

#  Grouping the document tree into Texinfo files. List of tuples
#  (source start file, target name, title, author,
#   dir menu entry, description, category)
texinfo_documents = [
    (
        'index',
        'STochasticEngineforPathwaySimulation',
        u'STochastic Engine for Pathway Simulation Documentation',
        u'The STEPS Development Team',
        'STochasticEngineforPathwaySimulation',
        'One line description of project.',
        'Miscellaneous',
    )
]

#  Documents to append as an appendix to all manuals.
#  texinfo_appendices = []

#  If false, no module index is generated.
#  texinfo_domain_indices = True

#  How to display URL addresses: 'footnote', 'no', or 'inline'.
#  texinfo_show_urls = 'footnote'

#  If true, do not generate a @detailmenu in the "Top" node's menu.
#  texinfo_no_detailmenu = False


#  Example configuration for intersphinx: refer to the Python standard library.
intersphinx_mapping = {'http://docs.python.org/': None}

[extensions]
todo_include_todos = True


####################################################
# Configuration for generating API_2 documentation #
####################################################


# Not sure if there is a better way to do this but if we do not return the descriptor itself
# during documentation, the __doc__ from the original function is not taken into account.
# This might be due to how sphinx gets class attributes which trigger the call of the descriptor's
# __get__ method instead of returning the descriptor itself. To avoid this, we monkey patch the
# descriptor's __get__ method to return the descriptor instead of the normal value.
steps.API_2.utils.classproperty.__get__ = lambda self, *args: self

# -- Project information -----------------------------------------------------


# -- General configuration ---------------------------------------------------

# Add any Sphinx extension module names here, as strings. They can be
# extensions coming with Sphinx (named 'sphinx.ext.*') or your custom
# ones.
extensions += [
    'sphinx.ext.autosummary',
]

autodoc_default_options = {
    # 'members': True,
    'member-order': 'bysource',
    # 'special-members': True,
    # 'inherited-members': 'ndarray',
    # 'undoc-members': True,
    # 'exclude-members': '__weakref__'
}


def AllSubclasses(cls):
    for cls2 in cls.__subclasses__():
        yield cls2
        for cls3 in AllSubclasses(cls2):
            yield cls3


visualClasses = ['SimControl', 'PlotDisplay', 'TimePlot',
                 'SpatialPlot', 'NewRow', 'SimDisplay', 'ElementDisplay']


def autodoc_skip_member(app, what, name, obj, skip, options):
    if obj is not None and hasattr(obj, '__doc__'):
        if name.startswith('__'):
            if obj.__doc__ is not None and ':meta public:' in obj.__doc__:
                return False
            else:
                return True
        elif obj.__doc__ is not None and ':meta private:' in obj.__doc__:
            return True
        elif isinstance(obj, types.MethodType):
            if obj.__self__.__name__ in visualClasses and obj.__name__ == 'Create':
                return True
    return skip


replace_map = {
    '{{model.Reaction._FwdSpecifier}}': steps.API_2.model.Reaction._FwdSpecifier,
    '{{model.Reaction._BkwSpecifier}}': steps.API_2.model.Reaction._BkwSpecifier,
}
py_prefix = '_py_'


def autodoc_process_docstring(app, what, name, obj, options, lines):
    if isinstance(obj, types.MethodType) and obj.__name__ == 'Create' and obj.__self__.__name__ != 'NamedObject':
        lines[:] = [f"""
            Auto naming creation method, see :py:func:`steps.API_2.utils.NamedObject.Create` for auto naming syntax and :py:class:`{obj.__self__.__name__}` for arguments.
        """]
    # Replace the dosctring of ALL(...) methods
    if isinstance(obj, types.FunctionType) and obj.__name__ == 'ALL':
        if len(name.split('.')) > 2:
            *_, clsname, methname = name.split('.')
            if clsname not in ['NamedObject', 'SimPath', 'Simulation']:
                lines[:] = [f"""
                    Access the children of the object, see :py:func:`steps.API_2.utils.NamedObject.ALL` for details.
                """]
    # Replace the docstring of special methods in classes inheriting from RefList
    if isinstance(obj, types.FunctionType) and obj.__name__.startswith('__'):
        if len(name.split('.')) > 2:
            *_, clsname, methname = name.split('.')
            if methname == '__getattr__' and clsname not in ['NamedObject', 'SimPath', 'Simulation',
                                                             'ResultSelector', 'Parameter', 'SQLiteGroup', 'HDF5Group']:
                lines[:] = [f"""
                    Access the children of the object as if they were an attribute, see :py:func:`steps.API_2.utils.NamedObject.__getattr__` for details.
                """]
            elif clsname in [cls.__name__ for cls in steps.API_2.geom.RefList.__subclasses__()]:
                clsval = [cls for cls in steps.API_2.geom.RefList.__subclasses__(
                ) if cls.__name__ == clsname][0]
                refcls = clsval._refCls
                funcCls = obj.__qualname__.split('.')[0]
                if funcCls == steps.API_2.geom.RefList.__name__:
                    lines[:] = [f"""{lines[0]}

                        See :py:func:`RefList.{methname}` for details, replace 'RefList' by '{clsname}' and 'Reference' by '{refcls.__name__}' in the examples.
                    """]
            elif clsname in [cls.__name__ for cls in AllSubclasses(steps.API_2.model.ReactionElement)]:
                funcCls = obj.__qualname__.split('.')[0]
                if funcCls == steps.API_2.model.ReactionElement.__name__:
                    lines[:] = [f"""{lines[0]}

                        See :py:func:`ReactionElement.{methname}` for details.
                    """]
    for i in range(len(lines)):
        for key, repl in replace_map.items():
            if key in lines[i]:
                lines[i] = lines[i].replace(key, repl)

    if isinstance(obj, type) and 'API_1' in obj.__module__ and obj.__init__.__class__.__name__ == 'wrapper_descriptor':
        # Add __init__ docstring to the python class for cython classes
        for cls in obj.__mro__:
            if cls.__name__.startswith(py_prefix):
                lines[:] = lines + obj.__init__.__doc__.split('\n')
                break
    elif obj.__class__.__name__ == 'builtin_function_or_method' and obj.__name__.startswith(py_prefix):
        if re.match('\s*\w+\([\w\s,=]*\)', lines[0]) is not None:
            lines[:] = lines[1:]


def autodoc_process_signature(app, what, name, obj, options, signature, return_annotation):
    sig = tuple()
    if signature is None:
        # Try to build a signature from cython bindings
        if isinstance(obj, type) and 'API_1' in obj.__module__ and obj.__init__.__class__.__name__ == 'wrapper_descriptor':
            for cls in obj.__mro__:
                if cls.__name__.startswith(py_prefix):
                    signature = cls.__doc__.split('\n')[0].strip()
                    if '(' in signature:
                        signature = signature[signature.index('('):]
                    else:
                        signature = None
                    break

    if obj.__class__.__name__ == 'builtin_function_or_method' and obj.__name__.startswith(py_prefix):
        signature = obj.__doc__.split('\n')[0].strip()
        if '(' in signature:
            signature = signature[signature.index('('):]
        else:
            signature = None

    if signature is not None:
        for param in signature.strip('()').split(','):
            param = param.strip()
            if not (param.startswith('_') and '=' in param) and param != 'self':
                if ' ' in param:
                    sig += (param.split(' ')[-1],)
                else:
                    sig += (param,)
        return ('(' + ', '.join(sig) + ')', return_annotation)
    else:
        return (signature, return_annotation)


# Only display bases classes that are documented
def autodoc_process_bases(app, name, obj, options, bases):
    added = True
    while added:
        added = False
        for i, b in reversed(list(enumerate(bases))):
            mod = inspect.getmodule(b)
            try:
                _all = mod.__all__
            except:
                _all = []
            if b.__name__ not in _all:
                for b2 in b.__bases__:
                    if b2 not in bases:
                        bases.append(b2)
                        added = True
                del bases[i]


def setup(app):
    app.connect('autodoc-skip-member', autodoc_skip_member)
    app.connect('autodoc-process-docstring', autodoc_process_docstring)
    app.connect('autodoc-process-signature', autodoc_process_signature)
    app.connect('autodoc-process-bases', autodoc_process_bases)
