#  -*- coding: utf-8 -*-
#
#  STochastic Engine for Pathway Simulation documentation build configuration file, created by
#  sphinx-quickstart on Thu Mar 20 12:02:04 2014.
#
#  This file is execfile()d with the current directory set to its
#  containing dir.
#
#  Note that not all possible configuration values are present in this
#  autogenerated file.
#
#  All configuration values have a default; values that are commented out
#  serve to show the default.

import steps

#  If extensions (or modules to document with autodoc) are in another directory,
#  add these directories to sys.path here. If the directory is relative to the
#  documentation root, use os.path.abspath to make it absolute, like shown here.
#  sys.path.insert(0, os.path.abspath('.'))

#  -- General configuration ------------------------------------------------

#  If your documentation needs a minimal Sphinx version, state it here.
#  needs_sphinx = '1.0'

#  Add any Sphinx extension module names here, as strings. They can be
#  extensions coming with Sphinx (named 'sphinx.ext.*') or your custom
#  ones.
extensions = [
    'sphinx.ext.autodoc',
    'sphinx.ext.doctest',
    'sphinx.ext.intersphinx',
    'sphinx.ext.todo',
    'sphinx.ext.coverage',
    'sphinx.ext.mathjax',
    'sphinx.ext.ifconfig',
    'sphinx.ext.viewcode',
    'nbsphinx',
]

#  Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

#  The suffix of source filenames.
source_suffix = '.rst'

add_module_names = False

#  The encoding of source files.
#  source_encoding = 'utf-8-sig'

#  The master toctree document.
master_doc = 'manual_index'

#  General information about the project.
project = u'STochastic Engine for Pathway Simulation'
copyright = u'2020, The STEPS Development Team'

#  The version info for the project you're documenting, acts as replacement for
#  |version| and |release|, also used in various other places throughout the
#  built documents.
#
#  The short X.Y version.
version = steps.__version__
#  The full version, including alpha/beta/rc tags.
release = steps.__version__

#  The language for content autogenerated by Sphinx. Refer to documentation
#  for a list of supported languages.
#  language = None

#  There are two options for replacing |today|: either, you set today to some
#  non-false value, then it is used:
#  today = ''
#  Else, today_fmt is used as the format for a strftime call.
#  today_fmt = '%B %d, %Y'

#  List of patterns, relative to source directory, that match files and
#  directories to ignore when looking for source files.
exclude_patterns = []

#  The reST default role (used for this markup: `text`) to use for all
#  documents.
#  default_role = None

#  If true, '()' will be appended to :func: etc. cross-reference text.
#  add_function_parentheses = True

#  If true, the current module name will be prepended to all description
#  unit titles (such as .. function::).
#  add_module_names = True

#  If true, sectionauthor and moduleauthor directives will be shown in the
#  output. They are ignored by default.
#  show_authors = False

#  The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

#  A list of ignored prefixes for module index sorting.
#  modindex_common_prefix = []

#  If true, keep warnings as "system message" paragraphs in the built documents.
#  keep_warnings = False


#  -- Options for HTML output ----------------------------------------------

#  The theme to use for HTML and HTML Help pages.  See the documentation for
#  a list of builtin themes.
html_theme = 'default'

#  Theme options are theme-specific and customize the look and feel of a theme
#  further.  For a list of options available for each theme, see the
#  documentation.
#  html_theme_options = {}

#  Add any paths that contain custom themes here, relative to this directory.
#  html_theme_path = []

#  The name for this set of Sphinx documents.  If None, it defaults to
#  "<project> v<release> documentation".
#  html_title = None

#  A shorter title for the navigation bar.  Default is the same as html_title.
#  html_short_title = None

#  The name of an image file (relative to this directory) to place at the top
#  of the sidebar.
#  html_logo = None

#  The name of an image file (within the static path) to use as favicon of the
#  docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
#  pixels large.
#  html_favicon = None

#  Add any paths that contain custom static files (such as style sheets) here,
#  relative to this directory. They are copied after the builtin static files,
#  so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

html_js_files = ['js/simpath.js']

#  Add any extra paths that contain custom files (such as robots.txt or
#  .htaccess) here, relative to this directory. These files are copied
#  directly to the root of the documentation.
html_extra_path = ['simpath.json']

# Generate json
import itertools
import json
import os
import re

LOCATIONS = {
    'Tet': ('Tetrahedron', ('TET(tet)', 'TETS(tetLst)')), 
    'Tri': ('Triangle', ('TRI(tri)', 'TRIS(triLst)')), 
    'Vert': ('Vertex', ('VERT(vert)', 'VERTS(vertLst)')), 
    'ROI': ('Region of Interest', 'roi'), 
    'Comp': ('Compartment', 'comp'), 
    'Patch': ('Patch', 'patch'), 
    'Memb': ('Membrane', 'memb'), 
    'DiffBoundary': ('Diff. Boundary', ('diffb', 'diffb(direc=comp2)')),
    'SDiffBoundary': ('Surf. Diff. Boundary', ('sdiffb', 'diffb(direc=patch2)')),
}
OBJECTS = {
    '': ('Species', 'spec'),
    'Reac': ('Reaction', ("reac['fwd']", "reac['bkw']")),
    'SReac': ('Reaction', ("reac['fwd']", "reac['bkw']")),
    'VDepSReac': ('Reaction', ("reac['fwd']", "reac['bkw']")),
    'Diff': ('Diffusion', ("diff", 'diff(direc=tet2)')),
    'SDiff': ('Diffusion', ("sdiff", 'sdiff(direc=tri2)')),
    'Ohmic': ('Current', 'curr'),
    'GHK': ('Current', 'curr'),
}
OBJ_PROPERTIES = [
    'Count', 'Conc', 'Amount', 'Clamped', 'K', 'Active',  'D',
    'C', 'H', 'A', 'Extent', 'I', 'DiffusionActive', 'Dcst', 
]
LOC_PROPERTIES = [
    'Area', 'Vol', 'V', 'VClamped', 'IClamp', 'Potential', 
    'Capac', 'VolRes', 'Res', 'I',
]

DOC_REPLACEMENT = {
    'direction_comp': 'direc',
    'direction_patch': 'direc',
    'direction_tet': 'direc',
    'direction_tri': 'direc',
}

INVALID_EXAMPLES = [
    re.compile('^.+diffb\(direc=[^\)]+\)\.[^\.]+\.DiffusionActive.*$'),
    re.compile('^.+(TETS|TRIS|comp|patch).+diff\(direc=[^\)]+\)\..*$'),
    re.compile('^.+diff\(direc=[^\)]+\)\.(Active|A).*$'),
]

for dct in [LOCATIONS, OBJECTS]:
    for loc, val in list(dct.items()):
        dct['Batch' + loc] = val

allMethodNames = {}
for comb in itertools.product(['get', 'set'], LOCATIONS.items(), OBJECTS.items(), OBJ_PROPERTIES, ['', 'sNP']):
    gs, loc, obj, prop, suff = comb
    name = gs + loc[0] + obj[0] + prop + suff
    allMethodNames[name] = (gs, loc[1], obj[1], prop)
for comb in itertools.product(['get', 'set'], LOCATIONS.items(), LOC_PROPERTIES, ['', 'sNP']):
    gs, loc, prop, suff = comb
    name = gs + loc[0] + prop + suff
    allMethodNames[name] = (gs, loc[1], None, prop)


def dctFill(dct, val):
    if val not in dct:
        dct[val] = {}
    return dct[val]


def processDoc(doc):
    res = ''
    lines = []
    for line in doc.split('\n')[1:]:
        if 'Syntax::' in line:
            break
        else:
            line = line.strip()
            for src, dst in DOC_REPLACEMENT.items():
                line = line.replace(src, dst)
            if len(line) == 0 and len(lines) > 0:
                res += '<p>' + ' '.join(lines) + '</p>'
                lines = []
            else:
                lines.append(line.strip())
    if len(lines) > 0:
        res += '<p>' + ' '.join(lines) + '</p>'
    return res

def parseMethod(dct, solverName, meth):
    gs, loc, obj, prop = allMethodNames[meth.__name__]

    allLines = ['sim']

    for item in [loc, obj]:
        if item is not None:
            item = item[1]
            if isinstance(item, str):
                item = (item,)
            allLines = [line + f'.{val}' for line in allLines for val in item]

    endLines = []
    for line in allLines:
        line += f'.{prop}'
        if gs == 'get':
            line = f'val = {line}'
        else:
            line = f'{line} = val'
        if all(p.match(line) is None for p in INVALID_EXAMPLES):
            endLines.append(line)

    examples = '</br>'.join(endLines)

    dct = dctFill(dct, gs)
    dct = dctFill(dct, solverName)
    dct = dctFill(dct, loc[0])
    if obj is not None:
        dct = dctFill(dct, obj[0])
    dct[prop] = examples + '@' + processDoc(meth.__doc__)

def getSolverClass(solverStr):
    from steps import stepslib
    import steps.API_2.sim as sim
    import steps.API_2.utils as utils
    if solverStr in sim.Simulation.SERIAL_SOLVERS:
        return getattr(stepslib, utils._CYTHON_PREFIX + solverStr)
    elif solverStr in sim.Simulation.PARALLEL_SOLVERS:
        return sim.MPI._getSolver(solverStr)
    return None

def GenerateJSON(path):
    import steps.API_2.sim as sim
    jsonData = {}
    solvers = sim.Simulation.SERIAL_SOLVERS + sim.Simulation.PARALLEL_SOLVERS
    for solverName in solvers:
        solvCls = getSolverClass(solverName)
        if solvCls is not None:
            for objName in dir(solvCls):
                obj = getattr(solvCls, objName)
                if callable(obj) and objName in allMethodNames:
                    print(solverName, objName)
                    parseMethod(jsonData, solverName, obj)

    with open(path, 'w') as f:
        json.dump(jsonData, f)

GenerateJSON(html_extra_path[0])

#  If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
#  using the given strftime format.
#  html_last_updated_fmt = '%b %d, %Y'

#  If true, SmartyPants will be used to convert quotes and dashes to
#  typographically correct entities.
#  html_use_smartypants = True

#  Custom sidebar templates, maps document names to template names.
#  html_sidebars = {}

#  Additional templates that should be rendered to pages, maps page names to
#  template names.
#  html_additional_pages = {}

#  If false, no module index is generated.
#  html_domain_indices = True

#  If false, no index is generated.
#  html_use_index = True

#  If true, the index is split into individual pages for each letter.
#  html_split_index = False

#  If true, links to the reST sources are added to the pages.
#  html_show_sourcelink = True

#  If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#  html_show_sphinx = True

#  If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#  html_show_copyright = True

#  If true, an OpenSearch description file will be output, and all pages will
#  contain a <link> tag referring to it.  The value of this option must be the
#  base URL from which the finished HTML is served.
#  html_use_opensearch = ''

#  This is the file name suffix for HTML files (e.g. ".xhtml").
#  html_file_suffix = None

#  Output file base name for HTML help builder.
htmlhelp_basename = 'STochasticEngineforPathwaySimulationdoc'


#  -- Options for LaTeX output ---------------------------------------------

latex_elements = {
    # The paper size ('letterpaper' or 'a4paper').
    # 'papersize': 'letterpaper',
    # The font size ('10pt', '11pt' or '12pt').
    # 'pointsize': '10pt',
    # Additional stuff for the LaTeX preamble.
    # 'preamble': '',
}

#  Grouping the document tree into LaTeX files. List of tuples
#  (source start file, target name, title,
#   author, documentclass [howto, manual, or own class]).
latex_documents = [
    (
        'index',
        'STochasticEngineforPathwaySimulation.tex',
        u'STochastic Engine for Pathway Simulation Documentation',
        u'The STEPS Development Team',
        'manual',
    )
]

#  The name of an image file (relative to this directory) to place at the top of
#  the title page.
#  latex_logo = None

#  For "manual" documents, if this is true, then toplevel headings are parts,
#  not chapters.
#  latex_use_parts = False

#  If true, show page references after internal links.
#  latex_show_pagerefs = False

#  If true, show URL addresses after external links.
#  latex_show_urls = False

#  Documents to append as an appendix to all manuals.
#  latex_appendices = []

#  If false, no module index is generated.
#  latex_domain_indices = True


#  -- Options for manual page output ---------------------------------------

#  One entry per manual page. List of tuples
#  (source start file, name, description, authors, manual section).
man_pages = [
    (
        'index',
        'stochasticengineforpathwaysimulation',
        u'STochastic Engine for Pathway Simulation Documentation',
        [u'The STEPS Development Team'],
        1,
    )
]

#  If true, show URL addresses after external links.
#  man_show_urls = False


#  -- Options for Texinfo output -------------------------------------------

#  Grouping the document tree into Texinfo files. List of tuples
#  (source start file, target name, title, author,
#   dir menu entry, description, category)
texinfo_documents = [
    (
        'index',
        'STochasticEngineforPathwaySimulation',
        u'STochastic Engine for Pathway Simulation Documentation',
        u'The STEPS Development Team',
        'STochasticEngineforPathwaySimulation',
        'One line description of project.',
        'Miscellaneous',
    )
]

#  Documents to append as an appendix to all manuals.
#  texinfo_appendices = []

#  If false, no module index is generated.
#  texinfo_domain_indices = True

#  How to display URL addresses: 'footnote', 'no', or 'inline'.
#  texinfo_show_urls = 'footnote'

#  If true, do not generate a @detailmenu in the "Top" node's menu.
#  texinfo_no_detailmenu = False


#  Example configuration for intersphinx: refer to the Python standard library.
intersphinx_mapping = {'http://docs.python.org/': None}

[extensions]
todo_include_todos = True


####################################################
# Configuration for generating API_2 documentation #
####################################################


import types

import steps
from steps.API_2 import model, geom, utils, sim

# Not sure if there is a better way to do this but if we do not return the descriptor itself
# during documentation, the __doc__ from the original function is not taken into account. 
# This might be due to how sphinx gets class attributes which trigger the call of the descriptor's
# __get__ method instead of returning the descriptor itself. To avoid this, we monkey patch the
# descriptor's __get__ method to return the descriptor instead of the normal value.
steps.API_2.utils.classproperty.__get__ = lambda self, *args: self

# -- Project information -----------------------------------------------------



# -- General configuration ---------------------------------------------------

# Add any Sphinx extension module names here, as strings. They can be
# extensions coming with Sphinx (named 'sphinx.ext.*') or your custom
# ones.
extensions += [
    'sphinx.ext.autosummary',
]

autodoc_default_options = {
    # 'members': True,
    'member-order': 'bysource',
    # 'special-members': True,
    # 'inherited-members': 'ndarray',
    # 'undoc-members': True,
    # 'exclude-members': '__weakref__'
}

def AllSubclasses(cls):
    for cls2 in cls.__subclasses__():
        yield cls2
        for cls3 in AllSubclasses(cls2):
            yield cls3

visualClasses = ['SimControl', 'PlotDisplay', 'TimePlot', 'SpatialPlot', 'NewRow', 'SimDisplay', 'ElementDisplay']

def autodoc_skip_member(app, what, name, obj, skip, options):
    if obj is not None and hasattr(obj, '__doc__'):
        if name.startswith('__'):
            if obj.__doc__ is not None and ':meta public:' in obj.__doc__:
                return False
            else:
                return True
        elif obj.__doc__ is not None and ':meta private:' in obj.__doc__:
            return True
        elif isinstance(obj, types.MethodType) and obj.__self__.__name__ in visualClasses:
            if obj.__name__ == 'Create' :
                return True
    return skip

replace_map = {
    '{{model.Reaction._FwdSpecifier}}': steps.API_2.model.Reaction._FwdSpecifier,
    '{{model.Reaction._BkwSpecifier}}': steps.API_2.model.Reaction._BkwSpecifier,
}
py_prefix = '_py_'

def autodoc_process_docstring(app, what, name, obj, options, lines):
    if isinstance(obj, types.MethodType) and obj.__name__ == 'Create' and obj.__self__.__name__ != 'NamedObject':
        lines[:] = [f"""
            Auto naming creation method, see :py:func:`steps.API_2.utils.NamedObject.Create` for auto naming syntax and :py:class:`{obj.__self__.__name__}` for arguments.
        """]
    # Replace the dosctring of ALL(...) methods
    if isinstance(obj, types.FunctionType) and obj.__name__ == 'ALL':
        if len(name.split('.')) > 2:
            *_, clsname, methname = name.split('.')
            if clsname not in ['NamedObject', 'SimPath', 'Simulation']:
                lines[:] = [f"""
                    Access the children of the object, see :py:func:`steps.API_2.utils.NamedObject.ALL` for details.
                """]
    # Replace the docstring of special methods in classes inheriting from RefList
    if isinstance(obj, types.FunctionType) and obj.__name__.startswith('__'):
        if len(name.split('.')) > 2:
            *_, clsname, methname = name.split('.')
            if methname == '__getattr__' and clsname not in ['NamedObject', 'SimPath', 'Simulation', 'ResultSelector', 'Parameter']:
                lines[:] = [f"""
                    Access the children of the object as if they were an attribute, see :py:func:`steps.API_2.utils.NamedObject.__getattr__` for details.
                """]
            elif clsname in [cls.__name__ for cls in steps.API_2.geom.RefList.__subclasses__()]:
                clsval = [cls for cls in steps.API_2.geom.RefList.__subclasses__() if cls.__name__ == clsname][0]
                refcls = clsval._refCls
                funcCls = obj.__qualname__.split('.')[0]
                if funcCls == steps.API_2.geom.RefList.__name__:
                    lines[:] = [f"""{lines[0]}

                        See :py:func:`RefList.{methname}` for details, replace 'RefList' by '{clsname}' and 'Reference' by '{refcls.__name__}' in the examples.
                    """]
            elif clsname in [cls.__name__ for cls in AllSubclasses(steps.API_2.model.ReactionElement)]:
                funcCls = obj.__qualname__.split('.')[0]
                if funcCls == steps.API_2.model.ReactionElement.__name__:
                    lines[:] = [f"""{lines[0]}

                        See :py:func:`ReactionElement.{methname}` for details.
                    """]
    for i in range(len(lines)):
        for key, repl in replace_map.items():
            if key in lines[i]:
                lines[i] = lines[i].replace(key, repl)

    if isinstance(obj, type) and 'API_1' in obj.__module__ and obj.__init__.__class__.__name__ == 'wrapper_descriptor':
        # Add __init__ docstring to the python class for cython classes
        for cls in obj.__mro__:
            if cls.__name__.startswith(py_prefix):
                lines[:] = lines + obj.__init__.__doc__.split('\n')
                break
    elif obj.__class__.__name__ == 'builtin_function_or_method' and obj.__name__.startswith(py_prefix):
        if re.match('\s*\w+\([\w\s,=]*\)', lines[0]) is not None:
            lines[:] = lines[1:]


def autodoc_process_signature(app, what, name, obj, options, signature, return_annotation):
    sig = tuple()
    if signature is None:
        # Try to build a signature from cython bindings
        if isinstance(obj, type) and 'API_1' in obj.__module__ and obj.__init__.__class__.__name__ == 'wrapper_descriptor':
            for cls in obj.__mro__:
                if cls.__name__.startswith(py_prefix):
                    signature = cls.__doc__.split('\n')[0].strip()
                    if '(' in signature:
                        signature = signature[signature.index('('):]
                    else:
                        signature = None
                    break

    if obj.__class__.__name__ == 'builtin_function_or_method' and obj.__name__.startswith(py_prefix):
        signature = obj.__doc__.split('\n')[0].strip()
        if '(' in signature:
            signature = signature[signature.index('('):]
        else:
            signature = None

    if signature is not None:
        for param in signature.strip('()').split(','):
            param = param.strip()
            if not (param.startswith('_') and '=' in param) and param != 'self':
                if ' ' in param:
                    sig += (param.split(' ')[-1],)
                else:
                    sig += (param,)
        return ('(' + ', '.join(sig) + ')', return_annotation)
    else:
        return (signature, return_annotation)

def setup(app):
    app.connect('autodoc-skip-member', autodoc_skip_member)
    app.connect('autodoc-process-docstring', autodoc_process_docstring)
    app.connect('autodoc-process-signature', autodoc_process_signature)


