#  -*- coding: utf-8 -*-
#
#  STochastic Engine for Pathway Simulation documentation build configuration file, created by
#  sphinx-quickstart on Thu Mar 20 12:02:04 2014.
#
#  This file is execfile()d with the current directory set to its
#  containing dir.
#
#  Note that not all possible configuration values are present in this
#  autogenerated file.
#
#  All configuration values have a default; values that are commented out
#  serve to show the default.

import inspect
import itertools
import json
import os
import re
import steps
import sys
import types

from steps import stepslib
from steps.API_2 import model, geom, utils, sim

#  If extensions (or modules to document with autodoc) are in another directory,
#  add these directories to sys.path here. If the directory is relative to the
#  documentation root, use os.path.abspath to make it absolute, like shown here.
#  sys.path.insert(0, os.path.abspath('.'))

#  -- General configuration ------------------------------------------------

#  If your documentation needs a minimal Sphinx version, state it here.
#  needs_sphinx = '1.0'

sys.path.append(os.path.abspath("./_ext"))

#  Add any Sphinx extension module names here, as strings. They can be
#  extensions coming with Sphinx (named 'sphinx.ext.*') or your custom
#  ones.
extensions = [
    'sphinx.ext.autodoc',
    'sphinx.ext.doctest',
    'sphinx.ext.intersphinx',
    'sphinx.ext.todo',
    'sphinx.ext.coverage',
    'sphinx.ext.mathjax',
    'sphinx.ext.ifconfig',
    'sphinx.ext.viewcode',
    'sphinx.ext.inheritance_diagram',
    'nbsphinx',
    'autodoc_facade',
]

#  Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

#  The suffix of source filenames.
source_suffix = '.rst'

add_module_names = False

#  The encoding of source files.
#  source_encoding = 'utf-8-sig'

#  The master toctree document.
master_doc = 'index'

#  General information about the project.
project = u'STochastic Engine for Pathway Simulation'
copyright = u'2020, The STEPS Development Team'

#  The version info for the project you're documenting, acts as replacement for
#  |version| and |release|, also used in various other places throughout the
#  built documents.
#
#  The short X.Y version.
version = steps.__version__
#  The full version, including alpha/beta/rc tags.
release = steps.__version__

#  The language for content autogenerated by Sphinx. Refer to documentation
#  for a list of supported languages.
#  language = None

#  There are two options for replacing |today|: either, you set today to some
#  non-false value, then it is used:
#  today = ''
#  Else, today_fmt is used as the format for a strftime call.
#  today_fmt = '%B %d, %Y'

#  List of patterns, relative to source directory, that match files and
#  directories to ignore when looking for source files.
exclude_patterns = []

#  The reST default role (used for this markup: `text`) to use for all
#  documents.
#  default_role = None

#  If true, '()' will be appended to :func: etc. cross-reference text.
#  add_function_parentheses = True

#  If true, the current module name will be prepended to all description
#  unit titles (such as .. function::).
#  add_module_names = True

#  If true, sectionauthor and moduleauthor directives will be shown in the
#  output. They are ignored by default.
#  show_authors = False

#  The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

#  A list of ignored prefixes for module index sorting.
#  modindex_common_prefix = []

#  If true, keep warnings as "system message" paragraphs in the built documents.
#  keep_warnings = False


#  -- Options for HTML output ----------------------------------------------

#  The theme to use for HTML and HTML Help pages.  See the documentation for
#  a list of builtin themes.
html_theme = 'sphinx_rtd_theme'

#  Theme options are theme-specific and customize the look and feel of a theme
#  further.  For a list of options available for each theme, see the
#  documentation.
html_theme_options = {'logo_only': True}

#  Add any paths that contain custom themes here, relative to this directory.
#  html_theme_path = []

#  The name for this set of Sphinx documents.  If None, it defaults to
#  "<project> v<release> documentation".
#  html_title = None

#  A shorter title for the navigation bar.  Default is the same as html_title.
#  html_short_title = None

#  The name of an image file (relative to this directory) to place at the top
#  of the sidebar.
html_logo = '_static/logo.svg'

#  The name of an image file (within the static path) to use as favicon of the
#  docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
#  pixels large.
#  html_favicon = None

#  Add any paths that contain custom static files (such as style sheets) here,
#  relative to this directory. They are copied after the builtin static files,
#  so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

html_css_files = ['css/paraview.css', 'css/user_guide.css']

html_js_files = ['js/simpath.js']

#  Add any extra paths that contain custom files (such as robots.txt or
#  .htaccess) here, relative to this directory. These files are copied
#  directly to the root of the documentation.
html_extra_path = [
    'simpath.json',
]

# Generate json

LOCATIONS = {
    # NameInMethods: (Full name, examples)
    # examples -> [('name in example', 'name in descr', optional: 'required kwarg 1', 'required kwarg 2', ...)]
    'Comp': (
        'Compartment',
        [('comp', '__CLS_geom.Compartment__ __CODE_comp__')],
    ),
    'Patch': (
        'Patch',
        [('patch', '__CLS_geom.Patch__ __CODE_patch__')],
    ),
    'Memb': (
        'Membrane',
        [('memb', '__CLS_geom.Membrane__ __CODE_memb__')],
    ),
    'DiffBoundary': (
        'Diff. Boundary',
        [('diffb', '__CLS_geom.DiffBoundary__ __CODE_diffb__'),
         ('diffb(direc=comp2)', '__CLS_geom.DiffBoundary__ diffb in direction of __CLS_geom.Compartment__ __CODE_comp2__', 'direction_comp')],
    ),
    'SDiffBoundary': (
        'Surf. Diff. Boundary',
        [('sdiffb', '__CLS_geom.SDiffBoundary__ __CODE_diffb__'),
         ('diffb(direc=patch2)', '__CLS_geom.SDiffBoundary__ diffb in direction of __CLS_geom.Patch__ __CODE_patch2_', 'direction_patch')],
    ),
    'ROI': (
        'Region of Interest',
        [('roi', '__CLS_geom.ROI__ __CODE_roi__')],
    ),
    'Tet': (
        'Tetrahedron',
        [('TET(tet)', '__CLS_geom.TetReference__ __CODE_tet__'),
         ('TETS(tetLst)', 'each tetrahedron in __CLS_geom.TetList__ __CODE_tetLst__')],
    ),
    'Tri': (
        'Triangle',
        [('TRI(tri)', '__CLS_geom.TriReference__ __CODE_tri__'),
         ('TRIS(triLst)', 'each triangle in __CLS_geom.TriList__ __CODE_triLst__')],
    ),
    'Vert': (
        'Vertex',
        [('VERT(vert)', '__CLS_geom.VertReference__ __CODE_vert__'),
         ('VERTS(vertLst)', 'each vertex in __CLS_geom.VertList__ __CODE_vertLst__')],
    ),
    'Ves': (
        'Vesicle',
        [('ves', '__CLS_model.Vesicle__ __CODE_ves__')],
    ),
    'SingleVesicle': (
        'Vesicle',
        [('VESICLE(vesref)', '__CLS_sim.VesicleReference__ __CODE_vesref__'),
         ('VESICLES(vesLst)', 'each vesicle in __CLS_sim.VesicleList__ __CODE_vesLst__')],
    ),
    'SingleVesicleSurface': (
        'Vesicle surface',
        [("VESICLE(vesref)('surf')", 'the surface of __CLS_sim.VesicleReference__ __CODE_vesref__'),
         ("VESICLES(vesLst)('surf')", 'the surface of each vesicle in __CLS_sim.VesicleList__ __CODE_vesLst__')],
    ),
    'SingleVesicleInner': (
        'Vesicle inside',
        [("VESICLE(vesref)('in')", "the lumen of __CLS_sim.VesicleReference__ __CODE_vesref__"),
         ("VESICLES(vesLst)('in')", "the lumen of each vesicle in __CLS_sim.VesicleList__ __CODE_vesLst__")],
    ),
    'Exocytosis': (
        'Exocytosis',
        [('exo', '__CLS_model.Exocytosis__ __CODE_exo__')],
    ),
    'Raft': (
        'Raft',
        [('raft', '__CLS_model.Raft__ __CODE_raft__')],
    ),
    'SingleRaft': (
        'Raft',
        [('RAFT(raftref)', "__CLS_sim.RaftReference__ __CODE_raftref__"),
         ('RAFTS(raftLst)', "each raft in __CLS_sim.RaftList__ __CODE_raftLst__")],
    ),
    'RaftEndocytosis': (
        'Raft Endocytosis',
        [('rendo', '__CLS_model.RaftEndocytosis__ __CODE_rendo__')],
    ),
}

OBJECTS = {
    # NameInMethods: (Full name, examples)
    # examples -> [('name in example', 'name in descr')]
    'Spec': (
        'Species',
        [('spec', '__CLS_model.Species__ __CODE_spec__')],
    ),
    'LinkSpec': (
        'Link Species',
        [('linkspec', '__CLS_model.LinkSpecies__ __CODE_linkspec__')],
    ),
    'Reac': (
        'Reaction',
        [("reac['fwd']", 'the forward part of __CLS_model.Reaction__ __CODE_reac__'),
         ("reac['bkw']", 'the backward part of __CLS_model.Reaction__ __CODE_reac__')],
    ),
    'SReac': (
        'Reaction',
        [("sreac['fwd']", 'the forward part of __CLS_model.Reaction__ __CODE_sreac__'),
         ("sreac['bkw']", 'the backward part of __CLS_model.Reaction__ __CODE_sreac__')],
    ),
    'VDepSReac': (
        'Reaction',
        [("reac['fwd']", 'the forward part of __CLS_model.Reaction__ __CODE_reac__'),
         ("reac['bkw']", 'the backward part of __CLS_model.Reaction__ __CODE_reac__')],
    ),
    'Diff': (
        'Diffusion',
        [('diff', '__CLS_model.Diffusion__ __CODE_diff__'),
         ('diff(direc=tet2)', '__CLS_model.Diffusion__ diff towards __CLS_geom.TetReference__ __CODE_tet2__', 'direction_tet')],
    ),
    'SDiff': (
        'Diffusion',
        [('sdiff', '__CLS_model.Diffusion__ __CODE_diff__'),
         ('sdiff(direc=tri2)', '__CLS_model.Diffusion__ diff towards __CLS_geom.TriReference__ __CODE_tri2__', 'direction_tri')],
    ),
    'Ohmic': (
        'Current',
        [('curr', '__CLS_model.OhmicCurr__ __CODE_curr__')],
    ),
    'GHK': (
        'Current',
        [('curr', '__CLS_model.GHKCurr__ __CODE_curr__')],
    ),
    'Ves': (
        'Vesicle',
        [('ves', '__CLS_model.Vesicle__ __CODE_ves__')],
    ),
    'Vesicle': (
        'Vesicle',
        [('ves', '__CLS_model.Vesicle__ __CODE_ves__')],
    ),
    # TODO: Check that the following make sense, shouldn't it be instead e.g. sim.comp.ves('surf').SA.Count?
    'VesicleSurface': (
        'Vesicle surface',
        [("VESICLE(vesref)('surf')", 'the surface of __CLS_sim.VesicleReference__ __CODE_vesref__'),
         ("VESICLES(vesLst)('surf')", 'the surface of each vesicle in __CLS_sim.VesicleList__ __CODE_vesLst__')],
    ),
    'VesicleInner': (
        'Vesicle inside',
        [("VESICLE(vesref)('in')", "the lumen of __CLS_sim.VesicleReference__ __CODE_vesref__"),
         ("VESICLES(vesLst)('in')", "the lumen of each vesicle in __CLS_sim.VesicleList__ __CODE_vesLst__")],
    ),
    'Raft': (
        'Raft',
        [('raft', '__CLS_model.Raft__ __CODE_raft__')],
    ),
    'SingleRaft': (
        'Raft',
        [('RAFT(raftref)', "__CLS_sim.RaftReference__ __CODE_raftref__"),
         ('RAFTS(raftLst)', "each raft in __CLS_sim.RaftList__ __CODE_raftLst__")],
    ),
    'EndocyticZone': (
        'Endocytic zone',
        [('endoZone', '__CLS_geom.EndocyticZone__ __CODE_endoZone__')],
    ),
    'RaftEndocytosis': (
        'Raft Endocytosis',
        [('rendo', '__CLS_model.RaftEndocytosis__ __CODE_rendo__')],
    ),
    'Exocytosis': (
        'Exocytosis',
        [('exo', '__CLS_model.Exocytosis__ __CODE_exo__')],
    ),
}

OBJ_PROPERTIES = {
    # Prop: (getValue, setValue, short description)
    'Count': (
        'cnt',
        'n',
        'number',
    ),
    'Conc': (
        'conc',
        'conc',
        'concentration',
    ),
    'Amount': (
        'val',
        'a',
        'amount',
    ),
    'Clamped': (
        'clamped',
        'clamped',
        'clamped status',
    ),
    'K': (
        'val',
        'kf',
        'reaction constant',
    ),
    'Active': (
        'active',
        'active',
        'active status',
    ),
    'D': (
        'dcst',
        'dcst',
        'diffusion constant',
    ),
    'C': (
        'val',
        'val',
        'stochastic reaction constant',
    ),
    'H': (
        'val',
        'val',
        'number of reactant combinations h_mu',
    ),
    'A': (
        'val',
        'val',
        'propensity',
    ),
    'Extent': (
        'val',
        'val',
        'extent',
    ),
    'I': (
        'val',
        'val',
        'current',
    ),
    'DiffusionActive': (
        'val',
        'val',
        'diffusion active status',
    ),
    'Dcst': (
        'val',
        'val',
        'diffusion constant',
    ),
    'Pos': (
        'pos',
        'pos',
        'position in cartesian coordinates',
    ),
    'PosSpherical': (
        'spos',
        'spos',
        'position in spherical coordinated',
    ),
}

LOC_PROPERTIES = {
    # Prop: (getValue, setValue, short description)
    'Area': (
        'val',
        'val',
        'area',
    ),
    'Vol': (
        'val',
        'val',
        'volume',
    ),
    'V': (
        'val',
        'val',
        'potential',
    ),
    'VClamped': (
        'clamped',
        'clamped',
        'clamped status of potential',
    ),
    'IClamp': (
        'val',
        'i',
        'current clamp',
    ),
    'Potential': (
        'val',
        'val',
        'potential',
    ),
    'Capac': (
        'cap',
        'cap',
        'capacitance',
    ),
    'VolRes': (
        'val',
        'val',
        'bulk electrical resistivity',
    ),
    'Res': (
        'ro, vrev',
        'steps.utils.Params(ro, vrev)',
        'electrical resistivity',
    ),
    'I': (
        'val',
        'val',
        'the current',
    ),
    'Pos': (
        'pos',
        'pos',
        'position in cartesian coordinates'
    ),
    'PosSpherical': (
        'spos',
        'spos',
        'position in spherical coordinated',
    ),
    'Immobility': (
        'immob',
        'immob',
        'immobility status',
    ),
    'Events': (
        'events',
        'events',
        'list of events',
    ),
    'K': (
        'val',
        'kf',
        'rate',
    ),
}

INVALID_EXAMPLES = [
    re.compile('^.+(TETS|TRIS).+diff\(direc=[^\)]+\)\..*$'),
]

# Ignore these kwargs because they are integrated in other API_2 objects in the SimPath
IGNORE_KWARGS = ['direction_tet', 'direction_tri', 'direction_comp', 'direction_patch', 'local']

KWARGS_DOC = {
    # Kwname: [(kwval, description)]
    'force': [('True', 'When force is set to True, the vesicle is swapped with any vesicle that would prevent it from changing its position')],
    'distributionMethod': [
        ('DistributionMethod.MULTINOMIAL', 
         """The distributing is weighted with the volume or area fraction of elements: bigger elements get a higher amount of molecules.
         With __CLS_sim.DistributionMethod.UNIFORM__ (default), the distribution is deterministic (apart from roundings) and the number of
         molecules per element is e.g. n*V_tet/V_tot.
         With __CLS_sim.DistributionMethod.MULTINOMIAL__ the distribution is multinomial and the probability of putting a species in an
         element is e.g. V_tet/V_tot.
         """)],
}

TET_SOLVERS = [
    solv for solv in sim.Simulation.SERIAL_SOLVERS + sim.Simulation.PARALLEL_SOLVERS if 'tet' in solv.lower()
]

INVALID_METHODS = [(solv, 'setCompVol') for solv in TET_SOLVERS]
INVALID_METHODS += [(solv, 'setPatchArea') for solv in TET_SOLVERS]

for dct in [LOCATIONS, OBJECTS]:
    for loc, val in list(dct.items()):
        dct['Batch' + loc] = val

allMethodNames = {}
for comb in itertools.product(['get', 'set'], LOCATIONS.items(), OBJECTS.items(), OBJ_PROPERTIES.items(), ['', 'sNP']):
    gs, loc, obj, prop, suff = comb
    name = gs + loc[0] + obj[0] + prop[0] + suff
    allMethodNames[name] = (gs, loc[1], obj[1], prop)
for comb in itertools.product(['get', 'set'], LOCATIONS.items(), LOC_PROPERTIES.items(), ['', 'sNP']):
    gs, loc, prop, suff = comb
    name = gs + loc[0] + prop[0] + suff
    allMethodNames[name] = (gs, loc[1], None, prop)


def finalize_descr(descr):
    replacements = [
        ('__CLS_(\w+)\.([\w\.]+)__', '<a href="API_\g<1>.html#steps.API_2.\g<1>.\g<2>">\g<2></a>'),
        ('__CODE_([\w\.]+)__', '<code class="py py-class">\g<1></code>'),
    ]
    for pattern, repl in replacements:
        descr = re.sub(pattern, repl, descr)
    return descr

def parseMethod(dct, solverName, method):
    # Extract kwargs
    signature, *doc = method.__doc__.split('\n')
    kwargs_pairs = re.findall(r'(\w+)\s*=\s*(?:_py_)?([\w\.]+)', signature)
    kwargs = {kwname: kwval for kwname, kwval in kwargs_pairs}

    gs, loc, obj, prop = allMethodNames[method.__name__]
    propName, (getValue, setValue, propDescr) = prop

    examples = [['sim']]
    descriptions = [[]]

    for item in [loc, obj]:
        if item is not None:
            tpe, options = item
            options = [(sl, sl) if isinstance(sl, str) else sl for sl in options]
            new_examples = []
            new_descriptions = []
            for ex, dscr in zip(examples, descriptions):
                for name, descr, *kwarg_deps in options:
                    if all(kwdep in kwargs for kwdep in kwarg_deps):
                        new_examples.append(ex + [name])
                        new_descriptions.append(dscr + [finalize_descr(descr)])
            examples = new_examples
            descriptions = new_descriptions

    setValues = [(setValue, '')]
    # Process keywords
    for kwname, kwvalue in kwargs.items():
        if kwname not in IGNORE_KWARGS:
            if kwname in KWARGS_DOC:
                for val, descr in KWARGS_DOC[kwname]:
                    setValues.append((f'steps.utils.Params({setValue}, {kwname}={val})', finalize_descr(descr)))
            else:
                warnings.warn('Undocumented keyword arg {kwname} in method {method}. Add documentation to the KWARGS_DOC dict in conf.py.')

    propDescr = f'<a href="#steps.API_2.sim.SimPath.{propName}">{propDescr}</a>'
    # Add unit if available
    if propName in sim.SimPath._PATH_END_UNITS:
        unit = sim.SimPath._PATH_END_UNITS[propName]
        if isinstance(unit, utils.Units) and not unit._isDimensionless():
            propDescr += f' (in {unit._toUnicode()})'

    allDoc = []
    for setval, additionalDescr in setValues:
        for ex, descr in zip(examples, descriptions):
            if gs == 'get':
                exLine = f'{getValue} = {".".join(ex)}.{propName}'
                descrLine = 'Get'
            elif gs == 'set':
                exLine = f'{".".join(ex)}.{propName} = {setval}'
                descrLine = 'Set'

            if all(p.match(exLine) is None for p in INVALID_EXAMPLES):
                *descr, objDescr = descr
                descrLine += f' the {propDescr} of {objDescr}'
                if len(descr) > 0:
                    locDescr = descr[0]
                    descrLine += f' in {locDescr}'
                descrLine += '. ' + additionalDescr
                allDoc.append({'@code': exLine, '@descr': descrLine})

    dct = dct.setdefault(gs, {}).setdefault(
        solverName, {}).setdefault(loc[0], {})
    if obj is not None:
        dct = dct.setdefault(obj[0], {})
    if propName not in dct:
        dct[propName] = {'@doc': allDoc}
            

def getSolverClass(solverStr):
    if solverStr in sim.Simulation.SERIAL_SOLVERS:
        return getattr(stepslib, utils._CYTHON_PREFIX + solverStr)
    elif solverStr in sim.Simulation.PARALLEL_SOLVERS and solverStr != 'TetVesicle':
        return sim.MPI._getSolver(solverStr)
    if solverStr == 'TetVesicle':
        return stepslib._py_TetVesicleVesRaft
    return None


def GenerateJSON(path):
    jsonData = {}
    solvers = sim.Simulation.SERIAL_SOLVERS + sim.Simulation.PARALLEL_SOLVERS
    for solverName in solvers:
        solvCls = getSolverClass(solverName)
        if solvCls is not None:
            for methodName in allMethodNames:
                if (solverName, methodName) in INVALID_METHODS:
                    continue
                try:
                    obj = getattr(solvCls, methodName)
                except:
                    continue
                if callable(obj):
                    parseMethod(jsonData, solverName, obj)

    with open(path, 'w') as f:
        json.dump(jsonData, f)


GenerateJSON(html_extra_path[0])

#  If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
#  using the given strftime format.
#  html_last_updated_fmt = '%b %d, %Y'

#  If true, SmartyPants will be used to convert quotes and dashes to
#  typographically correct entities.
#  html_use_smartypants = True

#  Custom sidebar templates, maps document names to template names.
#  html_sidebars = {}

#  Additional templates that should be rendered to pages, maps page names to
#  template names.
#  html_additional_pages = {}

#  If false, no module index is generated.
#  html_domain_indices = True

#  If false, no index is generated.
#  html_use_index = True

#  If true, the index is split into individual pages for each letter.
#  html_split_index = False

#  If true, links to the reST sources are added to the pages.
#  html_show_sourcelink = True

#  If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#  html_show_sphinx = True

#  If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#  html_show_copyright = True

#  If true, an OpenSearch description file will be output, and all pages will
#  contain a <link> tag referring to it.  The value of this option must be the
#  base URL from which the finished HTML is served.
#  html_use_opensearch = ''

#  This is the file name suffix for HTML files (e.g. ".xhtml").
#  html_file_suffix = None

#  Output file base name for HTML help builder.
htmlhelp_basename = 'STochasticEngineforPathwaySimulationdoc'


#  -- Options for LaTeX output ---------------------------------------------

latex_elements = {
    # The paper size ('letterpaper' or 'a4paper').
    # 'papersize': 'letterpaper',
    # The font size ('10pt', '11pt' or '12pt').
    # 'pointsize': '10pt',
    # Additional stuff for the LaTeX preamble.
    # 'preamble': '',
}

#  Grouping the document tree into LaTeX files. List of tuples
#  (source start file, target name, title,
#   author, documentclass [howto, manual, or own class]).
latex_documents = [
    (
        'index',
        'STochasticEngineforPathwaySimulation.tex',
        u'STochastic Engine for Pathway Simulation Documentation',
        u'The STEPS Development Team',
        'manual',
    )
]

#  The name of an image file (relative to this directory) to place at the top of
#  the title page.
#  latex_logo = None

#  For "manual" documents, if this is true, then toplevel headings are parts,
#  not chapters.
#  latex_use_parts = False

#  If true, show page references after internal links.
#  latex_show_pagerefs = False

#  If true, show URL addresses after external links.
#  latex_show_urls = False

#  Documents to append as an appendix to all manuals.
#  latex_appendices = []

#  If false, no module index is generated.
#  latex_domain_indices = True


#  -- Options for manual page output ---------------------------------------

#  One entry per manual page. List of tuples
#  (source start file, name, description, authors, manual section).
man_pages = [
    (
        'index',
        'stochasticengineforpathwaysimulation',
        u'STochastic Engine for Pathway Simulation Documentation',
        [u'The STEPS Development Team'],
        1,
    )
]

#  If true, show URL addresses after external links.
#  man_show_urls = False


#  -- Options for Texinfo output -------------------------------------------

#  Grouping the document tree into Texinfo files. List of tuples
#  (source start file, target name, title, author,
#   dir menu entry, description, category)
texinfo_documents = [
    (
        'index',
        'STochasticEngineforPathwaySimulation',
        u'STochastic Engine for Pathway Simulation Documentation',
        u'The STEPS Development Team',
        'STochasticEngineforPathwaySimulation',
        'One line description of project.',
        'Miscellaneous',
    )
]

#  Documents to append as an appendix to all manuals.
#  texinfo_appendices = []

#  If false, no module index is generated.
#  texinfo_domain_indices = True

#  How to display URL addresses: 'footnote', 'no', or 'inline'.
#  texinfo_show_urls = 'footnote'

#  If true, do not generate a @detailmenu in the "Top" node's menu.
#  texinfo_no_detailmenu = False


#  Example configuration for intersphinx: refer to the Python standard library.
intersphinx_mapping = {'python': ('http://docs.python.org/3', None)}

[extensions]
todo_include_todos = True


####################################################
# Configuration for generating API_2 documentation #
####################################################


# Not sure if there is a better way to do this but if we do not return the descriptor itself
# during documentation, the __doc__ from the original function is not taken into account.
# This might be due to how sphinx gets class attributes which trigger the call of the descriptor's
# __get__ method instead of returning the descriptor itself. To avoid this, we monkey patch the
# descriptor's __get__ method to return the descriptor instead of the normal value.
steps.API_2.utils.classproperty.__get__ = lambda self, *args: self

# -- Project information -----------------------------------------------------


# -- General configuration ---------------------------------------------------

# Add any Sphinx extension module names here, as strings. They can be
# extensions coming with Sphinx (named 'sphinx.ext.*') or your custom
# ones.
extensions += [
    'sphinx.ext.autosummary',
]

autodoc_default_options = {
    # 'members': True,
    'member-order': 'bysource',
    # 'special-members': True,
    # 'inherited-members': 'ndarray',
    # 'undoc-members': True,
    # 'exclude-members': '__weakref__'
}


def AllSubclasses(cls):
    for cls2 in cls.__subclasses__():
        yield cls2
        for cls3 in AllSubclasses(cls2):
            yield cls3


visualClasses = ['SimControl', 'PlotDisplay', 'TimePlot',
                 'SpatialPlot', 'NewRow', 'SimDisplay', 'ElementDisplay']


def autodoc_skip_member(app, what, name, obj, skip, options):
    if obj is not None and hasattr(obj, '__doc__'):
        if name.startswith('__'):
            if obj.__doc__ is not None and ':meta public:' in obj.__doc__:
                return False
            else:
                return True
        elif obj.__doc__ is not None and ':meta private:' in obj.__doc__:
            return True
        elif isinstance(obj, types.MethodType):
            if obj.__self__.__name__ in visualClasses and obj.__name__ == 'Create':
                return True
    return skip


replace_map = {
    '{{model.Reaction._FwdSpecifier}}': steps.API_2.model.Reaction._FwdSpecifier,
    '{{model.Reaction._BkwSpecifier}}': steps.API_2.model.Reaction._BkwSpecifier,
}
py_prefix = '_py_'


def autodoc_process_docstring(app, what, name, obj, options, lines):
    if isinstance(obj, types.MethodType) and obj.__name__ == 'Create' and obj.__self__.__name__ != 'NamedObject':
        lines[:] = [f"""
            Auto naming creation method, see :py:func:`steps.API_2.utils.NamedObject.Create` for auto naming syntax and :py:class:`{obj.__self__.__name__}` for arguments.
        """]
    # Replace the dosctring of ALL(...) methods
    if isinstance(obj, types.FunctionType) and obj.__name__ == 'ALL':
        if len(name.split('.')) > 2:
            *_, clsname, methname = name.split('.')
            if clsname not in ['NamedObject', 'SimPath', 'Simulation']:
                lines[:] = [f"""
                    Access the children of the object, see :py:func:`steps.API_2.utils.NamedObject.ALL` for details.
                """]
    # Replace the docstring of special methods in classes inheriting from RefList
    if isinstance(obj, types.FunctionType) and obj.__name__.startswith('__'):
        if len(name.split('.')) > 2:
            *_, clsname, methname = name.split('.')
            if methname == '__getattr__' and clsname not in ['NamedObject', 'SimPath', 'Simulation',
                                                             'ResultSelector', 'Parameter', 'SQLiteGroup', 'HDF5Group']:
                lines[:] = [f"""
                    Access the children of the object as if they were an attribute, see :py:func:`steps.API_2.utils.NamedObject.__getattr__` for details.
                """]
            elif clsname in [cls.__name__ for cls in steps.API_2.geom.RefList.__subclasses__()]:
                clsval = [cls for cls in steps.API_2.geom.RefList.__subclasses__(
                ) if cls.__name__ == clsname][0]
                refcls = clsval._refCls
                funcCls = obj.__qualname__.split('.')[0]
                if funcCls == steps.API_2.geom.RefList.__name__:
                    lines[:] = [f"""{lines[0]}

                        See :py:func:`RefList.{methname}` for details, replace 'RefList' by '{clsname}' and 'Reference' by '{refcls.__name__}' in the examples.
                    """]
            elif clsname in [cls.__name__ for cls in AllSubclasses(steps.API_2.model.ReactionElement)]:
                funcCls = obj.__qualname__.split('.')[0]
                if funcCls == steps.API_2.model.ReactionElement.__name__:
                    lines[:] = [f"""{lines[0]}

                        See :py:func:`ReactionElement.{methname}` for details.
                    """]
    for i in range(len(lines)):
        for key, repl in replace_map.items():
            if key in lines[i]:
                lines[i] = lines[i].replace(key, repl)

    if isinstance(obj, type) and 'API_1' in obj.__module__ and obj.__init__.__class__.__name__ == 'wrapper_descriptor':
        # Add __init__ docstring to the python class for cython classes
        for cls in obj.__mro__:
            if cls.__name__.startswith(py_prefix):
                lines[:] = lines + obj.__init__.__doc__.split('\n')
                break
    elif obj.__class__.__name__ == 'builtin_function_or_method' and obj.__name__.startswith(py_prefix):
        if re.match('\s*\w+\([\w\s,=]*\)', lines[0]) is not None:
            lines[:] = lines[1:]


def autodoc_process_signature(app, what, name, obj, options, signature, return_annotation):
    sig = tuple()
    if signature is None:
        # Try to build a signature from cython bindings
        if isinstance(obj, type) and 'API_1' in obj.__module__ and obj.__init__.__class__.__name__ == 'wrapper_descriptor':
            for cls in obj.__mro__:
                if cls.__name__.startswith(py_prefix):
                    signature = cls.__doc__.split('\n')[0].strip()
                    if '(' in signature:
                        signature = signature[signature.index('('):]
                    else:
                        signature = None
                    break

    if obj.__class__.__name__ == 'builtin_function_or_method' and obj.__name__.startswith(py_prefix):
        signature = obj.__doc__.split('\n')[0].strip()
        if '(' in signature:
            signature = signature[signature.index('('):]
        else:
            signature = None

    if signature is not None:
        for param in signature.strip('()').split(','):
            param = param.strip()
            if not (param.startswith('_') and '=' in param) and param != 'self':
                if ' ' in param:
                    sig += (param.split(' ')[-1],)
                else:
                    sig += (param,)
        return ('(' + ', '.join(sig) + ')', return_annotation)
    else:
        return (signature, return_annotation)


# Only display bases classes that are documented
def autodoc_process_bases(app, name, obj, options, bases):
    added = True
    while added:
        added = False
        for i, b in reversed(list(enumerate(bases))):
            mod = inspect.getmodule(b)
            try:
                _all = mod.__all__
            except:
                _all = []
            if b.__name__ not in _all:
                for b2 in b.__bases__:
                    if b2 not in bases:
                        bases.append(b2)
                        added = True
                del bases[i]


def setup(app):
    app.connect('autodoc-skip-member', autodoc_skip_member)
    app.connect('autodoc-process-docstring', autodoc_process_docstring)
    app.connect('autodoc-process-signature', autodoc_process_signature)
    app.connect('autodoc-process-bases', autodoc_process_bases)
