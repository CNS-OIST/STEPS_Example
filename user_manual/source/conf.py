#  -*- coding: utf-8 -*-
#
#  STochastic Engine for Pathway Simulation documentation build configuration file, created by
#  sphinx-quickstart on Thu Mar 20 12:02:04 2014.
#
#  This file is execfile()d with the current directory set to its
#  containing dir.
#
#  Note that not all possible configuration values are present in this
#  autogenerated file.
#
#  All configuration values have a default; values that are commented out
#  serve to show the default.

import inspect
import itertools
import json
import os
import re
import steps
import sys
import types
import warnings

from steps import stepslib
from steps.API_2 import model, geom, utils, sim

#  If extensions (or modules to document with autodoc) are in another directory,
#  add these directories to sys.path here. If the directory is relative to the
#  documentation root, use os.path.abspath to make it absolute, like shown here.
#  sys.path.insert(0, os.path.abspath('.'))

#  -- General configuration ------------------------------------------------

#  If your documentation needs a minimal Sphinx version, state it here.
#  needs_sphinx = '1.0'

sys.path.append(os.path.abspath("./_ext"))

#  Add any Sphinx extension module names here, as strings. They can be
#  extensions coming with Sphinx (named 'sphinx.ext.*') or your custom
#  ones.
extensions = [
    'sphinx.ext.autodoc',
    'sphinx.ext.doctest',
    'sphinx.ext.intersphinx',
    'sphinx.ext.todo',
    'sphinx.ext.coverage',
    'sphinx.ext.mathjax',
    'sphinx.ext.ifconfig',
    'sphinx.ext.viewcode',
    'sphinx.ext.inheritance_diagram',
    'nbsphinx',
    'autodoc_facade',
]

#  Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

#  The suffix of source filenames.
source_suffix = '.rst'

add_module_names = False

#  The encoding of source files.
#  source_encoding = 'utf-8-sig'

#  The master toctree document.
master_doc = 'index'

#  General information about the project.
project = u'STochastic Engine for Pathway Simulation'
copyright = u'2020, The STEPS Development Team'

#  The version info for the project you're documenting, acts as replacement for
#  |version| and |release|, also used in various other places throughout the
#  built documents.
#
#  The short X.Y version.
version = steps.__version__
#  The full version, including alpha/beta/rc tags.
release = steps.__version__

#  The language for content autogenerated by Sphinx. Refer to documentation
#  for a list of supported languages.
#  language = None

#  There are two options for replacing |today|: either, you set today to some
#  non-false value, then it is used:
#  today = ''
#  Else, today_fmt is used as the format for a strftime call.
#  today_fmt = '%B %d, %Y'

#  List of patterns, relative to source directory, that match files and
#  directories to ignore when looking for source files.
exclude_patterns = []

#  The reST default role (used for this markup: `text`) to use for all
#  documents.
#  default_role = None

#  If true, '()' will be appended to :func: etc. cross-reference text.
#  add_function_parentheses = True

#  If true, the current module name will be prepended to all description
#  unit titles (such as .. function::).
#  add_module_names = True

#  If true, sectionauthor and moduleauthor directives will be shown in the
#  output. They are ignored by default.
#  show_authors = False

#  The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

#  A list of ignored prefixes for module index sorting.
#  modindex_common_prefix = []

#  If true, keep warnings as "system message" paragraphs in the built documents.
#  keep_warnings = False


#  -- Options for HTML output ----------------------------------------------

#  The theme to use for HTML and HTML Help pages.  See the documentation for
#  a list of builtin themes.
html_theme = 'sphinx_rtd_theme'

#  Theme options are theme-specific and customize the look and feel of a theme
#  further.  For a list of options available for each theme, see the
#  documentation.
html_theme_options = {'logo_only': True}

#  Add any paths that contain custom themes here, relative to this directory.
#  html_theme_path = []

#  The name for this set of Sphinx documents.  If None, it defaults to
#  "<project> v<release> documentation".
#  html_title = None

#  A shorter title for the navigation bar.  Default is the same as html_title.
#  html_short_title = None

#  The name of an image file (relative to this directory) to place at the top
#  of the sidebar.
html_logo = '_static/logo.svg'

#  The name of an image file (within the static path) to use as favicon of the
#  docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
#  pixels large.
#  html_favicon = None

#  Add any paths that contain custom static files (such as style sheets) here,
#  relative to this directory. They are copied after the builtin static files,
#  so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

html_css_files = ['css/paraview.css', 'css/user_guide.css']

html_js_files = ['js/simpath.js']

#  Add any extra paths that contain custom files (such as robots.txt or
#  .htaccess) here, relative to this directory. These files are copied
#  directly to the root of the documentation.
html_extra_path = [
    'simpath.json',
]

# Generate json

ALL_PATH_ITEMS = {
    # NameInMethods: (Full name, examples)
    # examples -> [('name in example', 'name in descr', optional: 'required kwarg 1', 'required kwarg 2', ...)]
    'Comp': (
        'Compartment',
        [('comp', '__CLS_geom.Compartment__ __CODE_comp__')],
    ),
    'Patch': (
        'Patch',
        [('patch', '__CLS_geom.Patch__ __CODE_patch__')],
    ),
    'Memb': (
        'Membrane',
        [('memb', '__CLS_geom.Membrane__ __CODE_memb__')],
    ),
    'DiffBoundary': (
        'Diff. Boundary',
        [('diffb', '__CLS_geom.DiffBoundary__ __CODE_diffb__'),
         ('diffb(direc=comp2)', '__CLS_geom.DiffBoundary__ diffb in direction of __CLS_geom.Compartment__ __CODE_comp2__', 'direction_comp')],
    ),
    'SDiffBoundary': (
        'Surf. Diff. Boundary',
        [('sdiffb', '__CLS_geom.SDiffBoundary__ __CODE_diffb__'),
         ('diffb(direc=patch2)', '__CLS_geom.SDiffBoundary__ diffb in direction of __CLS_geom.Patch__ __CODE_patch2_', 'direction_patch')],
    ),
    'ROI': (
        'Region of Interest',
        [('roi', '__CLS_geom.ROI__ __CODE_roi__')],
    ),
    'Tet': (
        'Tetrahedron',
        [('TET(tet)', '__CLS_geom.TetReference__ __CODE_tet__'),
         ('TETS(tetLst)', 'each tetrahedron in __CLS_geom.TetList__ __CODE_tetLst__')],
    ),
    'Tri': (
        'Triangle',
        [('TRI(tri)', '__CLS_geom.TriReference__ __CODE_tri__'),
         ('TRIS(triLst)', 'each triangle in __CLS_geom.TriList__ __CODE_triLst__')],
    ),
    'Vert': (
        'Vertex',
        [('VERT(vert)', '__CLS_geom.VertReference__ __CODE_vert__'),
         ('VERTS(vertLst)', 'each vertex in __CLS_geom.VertList__ __CODE_vertLst__')],
    ),
    'Vesicle': (
        'Vesicle type',
        [('ves', '__CLS_model.Vesicle__ __CODE_ves__')],
    ),
    'VesicleSurface': (
        'Vesicle type',
        [("ves('surf')", 'the surfaces of __CLS_model.Vesicle__s of type __CODE_ves__')],
    ),
    'VesicleInner': (
        'Vesicle type',
        [("ves('in')", 'the lumens of __CLS_model.Vesicle__s of type __CODE_ves__')],
    ),
    'SingleVesicle': (
        'Specific Vesicle',
        [('VESICLE(vesref)', '__CLS_sim.VesicleReference__ __CODE_vesref__'),
         ('VESICLES(vesLst)', 'each vesicle in __CLS_sim.VesicleList__ __CODE_vesLst__')],
    ),
    'SingleVesicleSurface': (
        'Specific Vesicle',
        [("VESICLE(vesref)('surf')", 'the surface of __CLS_sim.VesicleReference__ __CODE_vesref__'),
         ("VESICLES(vesLst)('surf')", 'the surface of each vesicle in __CLS_sim.VesicleList__ __CODE_vesLst__')],
    ),
    'SingleVesicleInner': (
        'Specific Vesicle',
        [("VESICLE(vesref)('in')", "the lumen of __CLS_sim.VesicleReference__ __CODE_vesref__"),
         ("VESICLES(vesLst)('in')", "the lumen of each vesicle in __CLS_sim.VesicleList__ __CODE_vesLst__")],
    ),
    'Raft': (
        'Raft type',
        [('raft', '__CLS_model.Raft__s of type __CODE_raft__')],
    ),
    'SingleRaft': (
        'Specific Raft',
        [('RAFT(raftref)', "__CLS_sim.RaftReference__ __CODE_raftref__"),
         ('RAFTS(raftLst)', "each raft in __CLS_sim.RaftList__ __CODE_raftLst__")],
    ),
    'EndocyticZone': (
        'Endocytic zone',
        [('endoZone', '__CLS_geom.EndocyticZone__ __CODE_endoZone__')],
    ),
    # Objects that can be used without location:
    # TODO: Add endocytosis
    'Spec': (
        'Species',
        [('spec', '__CLS_model.Species__ __CODE_spec__')],
    ),
    'SingleSpec': (
        'Specific Point Species',
        [("POINTSPEC(psref)", "__CLS_sim.PointSpecReference __CODE_psref__"),
         ("POINTSPECS(psLst)", "__CLS_sim.PointSpecList__ __CODE_psLst__")],
    ),
    'LinkSpec': (
        'Link Species',
        [('linkspec', '__CLS_model.LinkSpecies__ __CODE_linkspec__')],
    ),
    'SingleLinkSpec': (
        'Specific Link Species',
        [("LINKSPEC(lsref)", "__CLS_sim.LinkSpecReference __CODE_lsref__"),
         ("LINKSPECS(lsLst)", "__CLS_sim.LinkSpecList__ __CODE_lsLst__")],
    ),
    'Complex': (
        'Complex',
        [('cplx', '__CLS_model.Complex__ __CODE_cplx__')],
    ),
    'SUS': (
        'Subunit state',
        [('sus', '__CLS_model.SubUnitState__ __CODE_sus__')],
    ),
    'Reac': (
        'Reaction',
        [("reac['fwd']", 'the forward part of __CLS_model.Reaction__ __CODE_reac__'),
         ("reac['bkw']", 'the backward part of __CLS_model.Reaction__ __CODE_reac__')],
    ),
    'SReac': (
        'Reaction',
        [("sreac['fwd']", 'the forward part of __CLS_model.Reaction__ __CODE_sreac__'),
         ("sreac['bkw']", 'the backward part of __CLS_model.Reaction__ __CODE_sreac__')],
    ),
    'VDepSReac': (
        'Reaction',
        [("reac['fwd']", 'the forward part of __CLS_model.Reaction__ __CODE_reac__'),
         ("reac['bkw']", 'the backward part of __CLS_model.Reaction__ __CODE_reac__')],
    ),
    'VesSReac': (
        'Reaction',
        [("reac['fwd']", 'the forward part of __CLS_model.Reaction__ __CODE_reac__'),
         ("reac['bkw']", 'the backward part of __CLS_model.Reaction__ __CODE_reac__')],
    ),
    'ComplexReac': (
        'Reaction',
        [("reac['fwd']", 'the forward part of __CLS_model.Reaction__ __CODE_reac__'),
         ("reac['bkw']", 'the backward part of __CLS_model.Reaction__ __CODE_reac__')],
    ),
    'Diff': (
        'Diffusion',
        [('diff', '__CLS_model.Diffusion__ __CODE_diff__'),
         ('diff(direc=tet2)', '__CLS_model.Diffusion__ diff towards __CLS_geom.TetReference__ __CODE_tet2__', 'direction_tet')],
    ),
    'SDiff': (
        'Diffusion',
        [('sdiff', '__CLS_model.Diffusion__ __CODE_diff__'),
         ('sdiff(direc=tri2)', '__CLS_model.Diffusion__ diff towards __CLS_geom.TriReference__ __CODE_tri2__', 'direction_tri')],
    ),
    'Ohmic': (
        'Current',
        [('curr', '__CLS_model.OhmicCurr__ __CODE_curr__')],
    ),
    'GHK': (
        'Current',
        [('curr', '__CLS_model.GHKCurr__ __CODE_curr__')],
    ),
    'RaftEndocytosis': (
        'Raft Endocytosis',
        [('rendo', '__CLS_model.RaftEndocytosis__ __CODE_rendo__')],
    ),
    'Exocytosis': (
        'Exocytosis',
        [('exo', '__CLS_model.Exocytosis__ __CODE_exo__')],
    ),
    'Endocytosis': (
        'Endocytosis',
        [('endo', '__CLS_model.Endocytosis__ __CODE_endo__')],
    ),
}

# Order so that longer strings are attempted to match first
ALL_PATH_ITEMS = {name: vals for name, vals in sorted(ALL_PATH_ITEMS.items(), key=lambda x: len(x[0]), reverse=True)}


ALL_PROPERTIES = {
    # Prop: {prefixPattern: (getValue, setValue, short description)}
    'Count': {
        '.*': (
            'cnt',
            'n',
            'number',
        ),
    },
    'Conc': {
        '.*': (
            'conc',
            'conc',
            'concentration',
        ),
    },
    'Amount': {
        '.*': (
            'val',
            'a',
            'amount',
        ),
    },
    'Clamped': {
        '.*': (
            'clamped',
            'clamped',
            'clamped status',
        ),
    },
    'K': {
        '.*Reac.*': (
            'val',
            'kf',
            'reaction constant',
        ),
        '.*': (
            'val',
            'kf',
            'rate',
        ),
    },
    'Active': {
        '.*': (
            'active',
            'active',
            'active status',
        ),
    },
    'D': {
        '.*': (
            'dcst',
            'dcst',
            'diffusion constant',
        ),
    },
    'C': {
        '.*': (
            'val',
            'val',
            'stochastic reaction constant',
        ),
    },
    'H': {
        '.*': (
            'val',
            'val',
            'number of reactant combinations h_mu',
        ),
    },
    'A': {
        '.*': (
            'val',
            'val',
            'propensity',
        ),
    },
    'Extent': {
        '.*': (
            'val',
            'val',
            'extent',
        ),
    },
    'I': {
        '.*': (
            'val',
            'val',
            'current',
        ),
    },
    'DiffusionActive': {
        '.*': (
            'val',
            'val',
            'diffusion active status',
        ),
    },
    'Dcst': {
        '.*': (
            'val',
            'val',
            'diffusion constant',
        ),
    },
    'Pos': {
        '.*': (
            'pos',
            'pos',
            'position in cartesian coordinates',
        ),
    },
    'PosSpherical': {
        '.*': (
            'spos',
            'spos',
            'position in spherical coordinated',
        ),
    },
    'Indices': {
        '.*': (
            'idxs',
            'idxs',
            'indices',
        ),
    },
    'SDiffD': {
        '.*': (
            'dcst',
            'dcst',
            'surface diffusion constant',
        ),
    },
    'Area': {
        '.*': (
            'val',
            'val',
            'area',
        ),
    },
    'Vol': {
        '.*': (
            'val',
            'val',
            'volume',
        ),
    },
    'V': {
        '.*': (
            'val',
            'val',
            'potential',
        ),
    },
    'VClamped': {
        '.*': (
            'clamped',
            'clamped',
            'clamped status of potential',
        ),
    },
    'IClamp': {
        '.*': (
            'val',
            'i',
            'current clamp',
        ),
    },
    'Potential': {
        '.*': (
            'val',
            'val',
            'potential',
        ),
    },
    'Capac': {
        '.*': (
            'cap',
            'cap',
            'capacitance',
        ),
    },
    'VolRes': {
        '.*': (
            'val',
            'val',
            'bulk electrical resistivity',
        ),
    },
    'Res': {
        '.*': (
            'ro, vrev',
            'steps.utils.Params(ro, vrev)',
            'electrical resistivity and reversal potential',
        ),
    },
    'Erev': {
        '.*': (
            'val',
            'val',
            'reversal potential',
        ),
    },
    'Immobility': {
        '.*': (
            'immob',
            'immob',
            'immobility status',
        ),
    },
    'Events': {
        '.*': (
            'events',
            'events',
            'list of events',
        ),
    },
    'OverlapTets': {
        '.*': (
            'tetIdxs',
            'tetIdxs',
            'indices of the overlaped tetrahedron',
        ),
    },
    'ReducedVol': {
        '.*': (
            'vol',
            'vol',
            'reduced volume',
        ),
    },
    'LinkedTo': {
        '.*': (
            'lsidx',
            'lsidx',
            'index of the bound link species',
        ),
    },
    'Ves': {
        '.*': (
            'vidx',
            'vidx',
            'index of the vesicle',
        ),
    },
    'Compartment': {
        '.*': (
            'compname',
            'compname',
            'name of the current compartment',
        ),
    },
    'Patch': {
        '.*': (
            'patchname',
            'patchname',
            'name of the current patch',
        ),
    },
}

INVALID_EXAMPLES = [
    re.compile('^.+(TETS|TRIS).+diff\(direc=[^\)]+\)\..*$'),
]

# Ignore these kwargs because they are integrated in other API_2 objects in the SimPath
IGNORE_KWARGS = ['direction_tet', 'direction_tri', 'direction_comp', 'direction_patch', 'local']

KWARGS_DOC = {
    # Kwname: [(kwval, description)]
    'force': [('True', 'When __CODE_force__ is set to __CODE_True__, the vesicle is swapped with any vesicle that would prevent it from changing its position')],
    'distributionMethod': [
        ('DistributionMethod.MULTINOMIAL', 
         """The distributing is weighted with the volume or area fraction of elements: bigger elements get a higher amount of molecules.
         With __CLS_sim.DistributionMethod.UNIFORM__ (default), the distribution is deterministic (apart from roundings) and the number of
         molecules per element is e.g. n*V_tet/V_tot.
         With __CLS_sim.DistributionMethod.MULTINOMIAL__ the distribution is multinomial and the probability of putting a species in an
         element is e.g. V_tet/V_tot.
         """)],
}

INVALID_METHODS = [
    # (solver regexp, [method regexp])
    ('.*[tT]et.*', [
        'setCompVol',
        'setPatchArea',
    ]),
    ('(?!Wmdirect).*', [
        '.*Complex.*',
    ]),
]

INVALID_METHODS = [(re.compile(m), [re.compile(n) for n in methods]) for m, methods in INVALID_METHODS]

IGNORE_METHODS = [
    # (solver regexp, [method regexp])
    ('.*', [
        '_.+',
        '[gs]etBatch.+s',
        'sumBatch.+s',
        '[gs]etROI.*s',
        '[gs]etROIT(et|ri).*',
        '.*SpecCountDict$',
        '(delete|add).*',
        '.*(Name|Defined)$',
        'checkpoint',
        'restore',
        'getSolverEmail',
        'step',
        'setTemp',
        'setTime',
        'getA0',
        'advance',
        'getSolverName',
        'getSolverAuthors',
        'reset',
        'setNSteps',
        'run',
        'getSolverDesc',
        'getNSteps',
        'getTime',
        'setRk4DT',
        'setDT',
        'getTemp',
        'getEfieldDT',
        'saveMembOpt',
        'setEfieldDT',
        'setTolerances',
        'setMaxNumSteps',
        'getIdleTime',
        'getRDTime',
        'setDiffApplyThreshold',
        'getUpdPeriod',
        'getSyncTime',
        'repartitionAndReset',
        'getDataExchangeTime',
        'getEFieldTime',
        'getNIteration',
        'getCompTime',
        'getNPatches',
        'getNCompSpecs',
        'getNComps',
        'getNPatchSpecs',
        'setOutputSync',
        'getOutputSyncRank',
        'getAllVesicleIndices',
        'setVesicleDT',
        'getVesicleDT',
        'getOutputSyncStatus',
        'createPath',
        'getPatchMaxV',
        'dumpDepGraphToFile',
        'setPetscOptions',
    ]),
]

IGNORE_METHODS = [(re.compile(m), [re.compile(n) for n in methods]) for m, methods in IGNORE_METHODS]

def finalize_descr(descr):
    replacements = [
        ('__CLS_(\w+)\.([\w\.]+)__', '<a href="API_\g<1>.html#steps.API_2.\g<1>.\g<2>">\g<2></a>'),
        ('__CODE_([\w\.]+)__', '<code class="py py-class">\g<1></code>'),
    ]
    for pattern, repl in replacements:
        descr = re.sub(pattern, repl, descr)
    return descr

def getMethodInfos(methodName, prefix=''):
    if len(prefix) == 0:
        if m := re.match('([gs]et)(.*)', methodName):
            for methInfos in getMethodInfos(m.group(2), prefix=m.group(1)):
                yield (m.group(1),) + methInfos
    else:
        for prop, matchDct in ALL_PROPERTIES.items():
            for regexp, infos in matchDct.items():
                if re.match(regexp, prefix) and (m := re.match(f'{prop}$', methodName)):
                    yield ((prop, infos),)
                    break
        for part, infos in ALL_PATH_ITEMS.items():
            if m := re.match(f'{part}(.*)', methodName):
                for methInfos in getMethodInfos(m.group(1), prefix=prefix + part):
                    yield (infos,) + methInfos
                    return


def parseMethod(dct, solverName, method):
    if any(any(p.match(method.__name__) for p in methods) for sp, methods in INVALID_METHODS if sp.match(solverName)):
        return 1

    status = 0
    for infos in getMethodInfos(method.__name__):
        status |= generateDocumentation(dct, solverName, method, infos)
    return status

def generateDocumentation(dct, solverName, method, infos):
    # Extract kwargs
    signature, *doc = method.__doc__.split('\n')
    kwargs_pairs = re.findall(r'(\w+)\s*=\s*(?:_py_)?([\w\.]+)', signature)
    kwargs = {kwname: kwval for kwname, kwval in kwargs_pairs}

    if 'DEPRECATED' in method.__doc__:
        return 1 # Considered but not documented

    gs, *locobjs, prop = infos
    propName, (getValue, setValue, propDescr) = prop

    examples = [['sim']]
    descriptions = [[]]

    for item in locobjs:
        if item is not None:
            tpe, options = item
            options = [(sl, sl) if isinstance(sl, str) else sl for sl in options]
            new_examples = []
            new_descriptions = []
            for ex, dscr in zip(examples, descriptions):
                for name, descr, *kwarg_deps in options:
                    if all(kwdep in kwargs for kwdep in kwarg_deps):
                        new_examples.append(ex + [name])
                        new_descriptions.append(dscr + [finalize_descr(descr)])
            examples = new_examples
            descriptions = new_descriptions

    setValues = [(setValue, '')]
    # Process keywords
    for kwname, kwvalue in kwargs.items():
        if kwname not in IGNORE_KWARGS:
            if kwname in KWARGS_DOC:
                for val, descr in KWARGS_DOC[kwname]:
                    setValues.append((f'steps.utils.Params({setValue}, {kwname}={val})', finalize_descr(descr)))
            else:
                warnings.warn('Undocumented keyword arg {kwname} in method {method}. Add documentation to the KWARGS_DOC dict in conf.py.')

    propDescr = f'<a href="#steps.API_2.sim.SimPath.{propName}">{propDescr}</a>'
    # Add unit if available
    if propName in sim.SimPath._PATH_END_UNITS:
        unit = sim.SimPath._PATH_END_UNITS[propName]
        if isinstance(unit, utils.Units) and not unit._isDimensionless():
            propDescr += f' (in {unit._toUnicode()})'

    allDoc = []
    for setval, additionalDescr in setValues:
        for ex, descr in zip(examples, descriptions):
            if gs == 'get':
                exLine = f'{getValue} = {".".join(ex)}.{propName}'
                descrLine = 'Get'
            elif gs == 'set':
                exLine = f'{".".join(ex)}.{propName} = {setval}'
                descrLine = 'Set'

            if all(p.match(exLine) is None for p in INVALID_EXAMPLES):
                *descr, objDescr = descr
                descrLine += f' the {propDescr} of {objDescr}'
                while len(descr) > 0:
                    *descr, locDescr = descr
                    descrLine += f' in {locDescr}'
                descrLine += '. ' + additionalDescr
                allDoc.append({'@code': exLine, '@descr': descrLine})

    dct = dct.setdefault(gs, {}).setdefault(solverName, {})
    for item in locobjs:
        dct = dct.setdefault(item[0], {})
    docLst = dct.setdefault(propName, {}).setdefault('@doc', [])
    # Do not add duplicates
    docSet = set(tuple(doc.items()) for doc in docLst)
    docLst += [doc for doc in allDoc if tuple(doc.items()) not in docSet]
    return 2 # Considered and documented
            

def getSolverClass(solverStr):
    if solverStr in sim.Simulation.SERIAL_SOLVERS:
        return getattr(stepslib, utils._CYTHON_PREFIX + solverStr)
    elif solverStr in sim.Simulation.PARALLEL_SOLVERS and solverStr != 'TetVesicle':
        return sim.MPI._getSolver(solverStr)
    if solverStr == 'TetVesicle':
        return stepslib._py_TetVesicleVesRaft
    return None


def GenerateJSON(path):
    jsonData = {}
    solvers = sim.Simulation.SERIAL_SOLVERS + sim.Simulation.PARALLEL_SOLVERS
    for solverName in solvers:
        solvCls = getSolverClass(solverName)
        if solvCls is not None:
            allMethods = set()
            coveredMethods = set()
            for methodName in dir(solvCls):
            # for methodName, meth in solvCls.__dict__.items():
                meth = getattr(solvCls, methodName)
                if callable(meth):
                    if all(all(p.match(methodName) is None for p in methods) for sp, methods in IGNORE_METHODS if sp.match(solverName)):
                        allMethods.add(methodName)
                    if parseMethod(jsonData, solverName, meth) > 0:
                        coveredMethods.add(methodName)
            missingMethods = set(allMethods) - set(coveredMethods)
            if len(missingMethods) > 0:
                missingMethodsStr = '\n'.join('\t' + meth for meth in missingMethods)
                warnings.warn(f'The following methods from solver {solverName} are not documented:\n{missingMethodsStr}')

    with open(path, 'w') as f:
        json.dump(jsonData, f)


GenerateJSON(html_extra_path[0])

#  If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
#  using the given strftime format.
#  html_last_updated_fmt = '%b %d, %Y'

#  If true, SmartyPants will be used to convert quotes and dashes to
#  typographically correct entities.
#  html_use_smartypants = True

#  Custom sidebar templates, maps document names to template names.
#  html_sidebars = {}

#  Additional templates that should be rendered to pages, maps page names to
#  template names.
#  html_additional_pages = {}

#  If false, no module index is generated.
#  html_domain_indices = True

#  If false, no index is generated.
#  html_use_index = True

#  If true, the index is split into individual pages for each letter.
#  html_split_index = False

#  If true, links to the reST sources are added to the pages.
#  html_show_sourcelink = True

#  If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#  html_show_sphinx = True

#  If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#  html_show_copyright = True

#  If true, an OpenSearch description file will be output, and all pages will
#  contain a <link> tag referring to it.  The value of this option must be the
#  base URL from which the finished HTML is served.
#  html_use_opensearch = ''

#  This is the file name suffix for HTML files (e.g. ".xhtml").
#  html_file_suffix = None

#  Output file base name for HTML help builder.
htmlhelp_basename = 'STochasticEngineforPathwaySimulationdoc'


#  -- Options for LaTeX output ---------------------------------------------

latex_elements = {
    # The paper size ('letterpaper' or 'a4paper').
    # 'papersize': 'letterpaper',
    # The font size ('10pt', '11pt' or '12pt').
    # 'pointsize': '10pt',
    # Additional stuff for the LaTeX preamble.
    # 'preamble': '',
}

#  Grouping the document tree into LaTeX files. List of tuples
#  (source start file, target name, title,
#   author, documentclass [howto, manual, or own class]).
latex_documents = [
    (
        'index',
        'STochasticEngineforPathwaySimulation.tex',
        u'STochastic Engine for Pathway Simulation Documentation',
        u'The STEPS Development Team',
        'manual',
    )
]

#  The name of an image file (relative to this directory) to place at the top of
#  the title page.
#  latex_logo = None

#  For "manual" documents, if this is true, then toplevel headings are parts,
#  not chapters.
#  latex_use_parts = False

#  If true, show page references after internal links.
#  latex_show_pagerefs = False

#  If true, show URL addresses after external links.
#  latex_show_urls = False

#  Documents to append as an appendix to all manuals.
#  latex_appendices = []

#  If false, no module index is generated.
#  latex_domain_indices = True


#  -- Options for manual page output ---------------------------------------

#  One entry per manual page. List of tuples
#  (source start file, name, description, authors, manual section).
man_pages = [
    (
        'index',
        'stochasticengineforpathwaysimulation',
        u'STochastic Engine for Pathway Simulation Documentation',
        [u'The STEPS Development Team'],
        1,
    )
]

#  If true, show URL addresses after external links.
#  man_show_urls = False


#  -- Options for Texinfo output -------------------------------------------

#  Grouping the document tree into Texinfo files. List of tuples
#  (source start file, target name, title, author,
#   dir menu entry, description, category)
texinfo_documents = [
    (
        'index',
        'STochasticEngineforPathwaySimulation',
        u'STochastic Engine for Pathway Simulation Documentation',
        u'The STEPS Development Team',
        'STochasticEngineforPathwaySimulation',
        'One line description of project.',
        'Miscellaneous',
    )
]

#  Documents to append as an appendix to all manuals.
#  texinfo_appendices = []

#  If false, no module index is generated.
#  texinfo_domain_indices = True

#  How to display URL addresses: 'footnote', 'no', or 'inline'.
#  texinfo_show_urls = 'footnote'

#  If true, do not generate a @detailmenu in the "Top" node's menu.
#  texinfo_no_detailmenu = False


#  Example configuration for intersphinx: refer to the Python standard library.
intersphinx_mapping = {'python': ('http://docs.python.org/3', None)}

[extensions]
todo_include_todos = True


####################################################
# Configuration for generating API_2 documentation #
####################################################


# Not sure if there is a better way to do this but if we do not return the descriptor itself
# during documentation, the __doc__ from the original function is not taken into account.
# This might be due to how sphinx gets class attributes which trigger the call of the descriptor's
# __get__ method instead of returning the descriptor itself. To avoid this, we monkey patch the
# descriptor's __get__ method to return the descriptor instead of the normal value.
steps.API_2.utils.classproperty.__get__ = lambda self, *args: self

# -- Project information -----------------------------------------------------


# -- General configuration ---------------------------------------------------

# Add any Sphinx extension module names here, as strings. They can be
# extensions coming with Sphinx (named 'sphinx.ext.*') or your custom
# ones.
extensions += [
    'sphinx.ext.autosummary',
]

autodoc_default_options = {
    # 'members': True,
    'member-order': 'bysource',
    # 'special-members': True,
    # 'inherited-members': 'ndarray',
    # 'undoc-members': True,
    # 'exclude-members': '__weakref__'
}


def AllSubclasses(cls):
    for cls2 in cls.__subclasses__():
        yield cls2
        for cls3 in AllSubclasses(cls2):
            yield cls3


visualClasses = ['SimControl', 'PlotDisplay', 'TimePlot',
                 'SpatialPlot', 'NewRow', 'SimDisplay', 'ElementDisplay']

def getAutodocParent():
    for frame in inspect.stack():
        if frame.function == 'filter_members':
            return frame.frame.f_locals['self'].object
    return None

def getInheritedFrom(parentCls, name):
    if not inspect.isclass(parentCls):
        return False
    ancestorCls = None
    for cls in parentCls.__mro__:
        if name in cls.__dict__:
            ancestorCls = cls
            break
    return ancestorCls

def isInherited(name):
    parentCls = getAutodocParent()
    return getInheritedFrom(parentCls, name) is not parentCls

def autodoc_skip_member(app, what, name, obj, skip, options):
    if obj is not None and hasattr(obj, '__doc__'):
        if name.startswith('__'):
            if obj.__doc__ is not None and ':meta public:' in obj.__doc__ and not isInherited(name):
                return False
            else:
                return True
        elif obj.__doc__ is not None and ':meta private:' in obj.__doc__:
            return True
        elif isinstance(obj, (types.MethodType, property)):
            if isinstance(obj, types.MethodType) and obj.__self__.__name__ in visualClasses and obj.__name__ == 'Create':
                return True
            if not skip:
                # Skip members that are inherited from documented classes
                parentCls = getAutodocParent()
                ancestorCls = getInheritedFrom(parentCls, name)
                if ancestorCls is not None and ancestorCls is not parentCls:
                    mod = inspect.getmodule(ancestorCls)
                    mod_all = mod.__all__ if hasattr(mod, '__all__') else []
                    if ancestorCls.__name__ in mod_all or ancestorCls.__name__ in options.inherited_members:
                        return True
    return skip


replace_map = {
    '{{model.Reaction._FwdSpecifier}}': steps.API_2.model.Reaction._FwdSpecifier,
    '{{model.Reaction._BkwSpecifier}}': steps.API_2.model.Reaction._BkwSpecifier,
}
py_prefix = '_py_'


def autodoc_process_docstring(app, what, name, obj, options, lines):
    if isinstance(obj, types.MethodType) and obj.__name__ == 'Create' and obj.__self__.__name__ != 'NamedObject':
        lines[:] = [f"""
            Auto naming creation method, see :py:func:`steps.API_2.utils.NamedObject.Create` for auto naming syntax and :py:class:`{obj.__self__.__name__}` for arguments.
        """]
    # Replace the dosctring of ALL(...) methods
    if isinstance(obj, types.FunctionType) and obj.__name__ == 'ALL':
        if len(name.split('.')) > 2:
            *_, clsname, methname = name.split('.')
            if clsname not in ['NamedObject', 'SimPath', 'Simulation']:
                lines[:] = [f"""
                    Access the children of the object, see :py:func:`steps.API_2.utils.NamedObject.ALL` for details.
                """]
    # Replace the docstring of special methods in classes inheriting from RefList
    if isinstance(obj, types.FunctionType) and obj.__name__.startswith('__'):
        if len(name.split('.')) > 2:
            *_, clsname, methname = name.split('.')
            if methname == '__getattr__' and clsname not in ['NamedObject', 'SimPath', 'Simulation',
                                                             'ResultSelector', 'Parameter', 'SQLiteGroup', 'HDF5Group']:
                lines[:] = [f"""
                    Access the children of the object as if they were an attribute, see :py:func:`steps.API_2.utils.NamedObject.__getattr__` for details.
                """]
            elif clsname in [cls.__name__ for cls in steps.API_2.geom.RefList.__subclasses__()]:
                clsval = [cls for cls in steps.API_2.geom.RefList.__subclasses__(
                ) if cls.__name__ == clsname][0]
                refcls = clsval._refCls
                funcCls = obj.__qualname__.split('.')[0]
                if funcCls == steps.API_2.geom.RefList.__name__:
                    lines[:] = [f"""{lines[0]}

                        See :py:func:`RefList.{methname}` for details, replace 'RefList' by '{clsname}' and 'Reference' by '{refcls.__name__}' in the examples.
                    """]
            elif clsname in [cls.__name__ for cls in AllSubclasses(steps.API_2.model.ReactionElement)]:
                funcCls = obj.__qualname__.split('.')[0]
                if funcCls == steps.API_2.model.ReactionElement.__name__:
                    lines[:] = [f"""{lines[0]}

                        See :py:func:`ReactionElement.{methname}` for details.
                    """]
    for i in range(len(lines)):
        for key, repl in replace_map.items():
            if key in lines[i]:
                lines[i] = lines[i].replace(key, repl)

    if isinstance(obj, type) and 'API_1' in obj.__module__ and obj.__init__.__class__.__name__ == 'wrapper_descriptor':
        # Add __init__ docstring to the python class for cython classes
        for cls in obj.__mro__:
            if cls.__name__.startswith(py_prefix):
                lines[:] = lines + obj.__init__.__doc__.split('\n')
                break
    elif obj.__class__.__name__ == 'builtin_function_or_method' and obj.__name__.startswith(py_prefix):
        if re.match('\s*\w+\([\w\s,=]*\)', lines[0]) is not None:
            lines[:] = lines[1:]


def autodoc_process_signature(app, what, name, obj, options, signature, return_annotation):
    sig = tuple()
    if signature is None:
        # Try to build a signature from cython bindings
        if isinstance(obj, type) and 'API_1' in obj.__module__ and obj.__init__.__class__.__name__ == 'wrapper_descriptor':
            for cls in obj.__mro__:
                if cls.__name__.startswith(py_prefix):
                    signature = cls.__doc__.split('\n')[0].strip()
                    if '(' in signature:
                        signature = signature[signature.index('('):]
                    else:
                        signature = None
                    break

    if obj.__class__.__name__ == 'builtin_function_or_method' and obj.__name__.startswith(py_prefix):
        signature = obj.__doc__.split('\n')[0].strip()
        if '(' in signature:
            signature = signature[signature.index('('):]
        else:
            signature = None

    if signature is not None:
        for param in signature.strip('()').split(','):
            param = param.strip()
            if not (param.startswith('_') and '=' in param) and param != 'self':
                if ' ' in param:
                    sig += (param.split(' ')[-1],)
                else:
                    sig += (param,)
        return ('(' + ', '.join(sig) + ')', return_annotation)
    else:
        return (signature, return_annotation)


# Only display bases classes that are documented
def autodoc_process_bases(app, name, obj, options, bases):
    added = True
    while added:
        added = False
        for i, b in reversed(list(enumerate(bases))):
            mod = inspect.getmodule(b)
            try:
                _all = mod.__all__
            except:
                _all = []
            if b.__name__ not in _all:
                for b2 in b.__bases__:
                    if b2 not in bases:
                        bases.append(b2)
                        added = True
                del bases[i]


def setup(app):
    app.connect('autodoc-skip-member', autodoc_skip_member)
    app.connect('autodoc-process-docstring', autodoc_process_docstring)
    app.connect('autodoc-process-signature', autodoc_process_signature)
    app.connect('autodoc-process-bases', autodoc_process_bases)
