{"get": {"Wmdirect": {"Compartment": {"Species": {"Count": {"@code": ["cnt = sim.comp.spec.Count"], "@doc": "<p> Returns the number of molecules of a species with identifier string spec in compartment with identifier string comp.</p><p>In a mesh-based simulation this is the combined count from all tetrahedral elements in the compartment.</p>"}, "Conc": {"@code": ["conc = sim.comp.spec.Conc"], "@doc": "<p> Returns the concentration (in Molar units) of species with identifier string spec in compartment with identifier string comp.</p><p>Note: in a mesh-based simulation this is calculated from the combined number of molecules from all tetrahedral elements in the compartment and the total volume of the tetrahedrons.</p>"}, "Amount": {"@code": ["val = sim.comp.spec.Amount"], "@doc": "<p> Returns the amount (in mols) of species with identifier string spec in compartment with identifier string comp.</p><p>In a mesh-based simulation this is the combined amount from all tetrahedral elements in the compartment.</p>"}, "Clamped": {"@code": ["clamped = sim.comp.spec.Clamped"], "@doc": "<p> Returns True if species with identifier string spec in compartment with identifier string comp is clamped, which means the concentration remains the same regardless of reactions that consume or produce molecules of this species. Returns False if not.</p><p>Note: in a mesh-based simulation it returns True only if the species is clamped in all tetrahedral elements of the compartment.</p>"}}, "Reaction": {"K": {"@code": ["val = sim.comp.reac['fwd'].K", "val = sim.comp.reac['bkw'].K"], "@doc": "<p> Returns the macroscopic reaction constant of reaction with identifier string reac in compartment with identifier string comp. The unit of the reaction constant depends on the order of the reaction.</p><p>Note: In a mesh-based simulation the value for the compartment is returned, although individual tetrahedral elements may have different values (set with setTetReacK).</p>"}, "Active": {"@code": ["active = sim.comp.reac['fwd'].Active", "active = sim.comp.reac['bkw'].Active"], "@doc": "<p> Returns whether a reaction with identifier string reac in compartment with identifier string comp is active (True) or not (False). If it's not active this means that a reaction will never occur regardless of whether the reactants are present in sufficient numbers or not.</p><p>Note: In a mesh-based simulation this method will return True only if the reaction is active in all tetrahedral elements in the compartment.</p>"}, "C": {"@code": ["val = sim.comp.reac['fwd'].C", "val = sim.comp.reac['bkw'].C"], "@doc": "<p> Returns the 'stochastic reaction constant' (or 'specific probability rate constant') of reaction with identifier string reac in compartment with identifier string comp.</p><p>The 'stochastic reaction constant' multiplied by infinitesimal time interval dt gives the average probability that one reaction channel of this reaction type will react accordingly in dt.</p><p>Note: in a mesh-based simulation (i.e. Tetexact), the stochastic reaction constant is computed as the weighted mean of the stochastic reaction constants in all tetrahedral elements of the compartment.</p>"}, "H": {"@code": ["val = sim.comp.reac['fwd'].H", "val = sim.comp.reac['bkw'].H"], "@doc": "<p> Returns h_mu, the distinct number of ways in which reaction with identifier string reac can occur in compartment with identifier string comp, by computing the product of its reactants. Note: in a mesh-based simulation (i.e. Tetexact), returns the sum of the h_mu's over all tetrahedral elements in the compartment.</p>"}, "A": {"@code": ["val = sim.comp.reac['fwd'].A", "val = sim.comp.reac['bkw'].A"], "@doc": "<p> Returns the propensity of reaction with identifier string reac in compartment with identifier string comp.</p><p>The propensity of a reaction is a function of state and is defined as the function whose product with infinitesimal time dt gives the probability that the reaction will occur in the next dt. It is the 'stochastic reaction constant' multiplied by 'h_mu'.</p><p>Note: in a mesh-based simulation (i.e. Tetexact), the propensity of a reaction in a compartment is computed as the sum of the propensities in all tetrahedral elements of the compartment.</p>"}, "Extent": {"@code": ["val = sim.comp.reac['fwd'].Extent", "val = sim.comp.reac['bkw'].Extent"], "@doc": "<p> Return the extent of reaction with identifier string reac in compartment with identifier string comp, that is the number of times the reaction has occurred up to the current simulation time.</p><p>Note: in a mesh-based simulation (i.e. Tetexact), returns the sum of the reaction extents in all tetrahedral elements of the compartment.</p>"}}, "Vol": {"@code": ["val = sim.comp.Vol"], "@doc": "<p> Returns the volume of compartment with identifier string comp (in m^3).</p>"}}, "Patch": {"Species": {"Count": {"@code": ["cnt = sim.patch.spec.Count"], "@doc": "<p> Returns the number of molecules of species with identifier string spec in patch with identifier string patch.Note: in a mesh-based simulation this is the combined count from all triangular elements in the patch.</p>"}, "Amount": {"@code": ["val = sim.patch.spec.Amount"], "@doc": "<p> Returns the amount (in mols) of species with identifier string spec in patch with identifier string patch.</p><p>Note: in a mesh-based simulation this is the combined amount from all triangular elements in the patch.</p>"}, "Clamped": {"@code": ["clamped = sim.patch.spec.Clamped"], "@doc": "<p> Gets whether the species with identifier string spec in patch with identifier string patch is clamped (clamped = True) or not (clamped = False). If a species is clamped the number of molecules stays the same regardless of surface reactions that consume or produce molecules of the species.</p><p>Note: in a mesh-based simulation this will return whether all of the triangles of the patch have this species clamped.</p>"}}, "Reaction": {"K": {"@code": ["val = sim.patch.sreac['fwd'].K", "val = sim.patch.sreac['bkw'].K"], "@doc": "<p> Returns the macroscopic reaction constant of surface reaction with identifier string sreac in patch with identifier string patch. The unit of the reaction constant depends on the order of the reaction.</p><p>Note: In a mesh-based solver the value for the patch is returned, although individual triangle elements may have different values (set with setTriSReacK).</p>"}, "Active": {"@code": ["active = sim.patch.sreac['fwd'].Active", "active = sim.patch.sreac['bkw'].Active"], "@doc": "<p> Returns whether a surface reaction with identifier string sreac in patch with identifier string patch is active (True) or not (False). If it's not active this means that a surface reaction will never occur regardless of whether the reactants are present in sufficient numbers or not.</p><p>Note: In a mesh-based simulation this method will return True only if the surface reaction is active in all triangular elements in the patch.</p>"}, "C": {"@code": ["val = sim.patch.sreac['fwd'].C", "val = sim.patch.sreac['bkw'].C"], "@doc": "<p> Returns the 'stochastic reaction constant' (or 'specific probability rate constant') of surface reaction with identifier string sreac in patch with identifier string patch.</p><p>Note: in a mesh-based simulation (i.e. Tetexact), the stochastic reaction constant is computed as the weighted mean of the stochastic reaction constants in all triangular elements of the patch.</p>"}, "H": {"@code": ["val = sim.patch.sreac['fwd'].H", "val = sim.patch.sreac['bkw'].H"], "@doc": "<p> Returns h_mu, the distinct number of ways in which surface reaction with identifier string sreac can occur in patch with identifier string patch, by computing the product of its reactants. Note: in a mesh-based simulation (i.e. Tetexact), returns the sum of the h_mu's over all triangular elements in the patch.</p>"}, "A": {"@code": ["val = sim.patch.sreac['fwd'].A", "val = sim.patch.sreac['bkw'].A"], "@doc": "<p> Returns the propensity of surface reaction with identifier string sreac in patch with identifier string patch. Note: in a mesh-based simulation (i.e. Tetexact), the propensity of a surface reaction in a patch is computed as the sum of the propensities in all triangular elements of the patch.</p>"}, "Extent": {"@code": ["val = sim.patch.sreac['fwd'].Extent", "val = sim.patch.sreac['bkw'].Extent"], "@doc": "<p> Returns the extent of surface reaction with identifier string sreac in patch with identifier string patch, that is the number of times the surface reaction has occurred up to the current simulation time.</p><p>Note: in a mesh-based simulation (i.e. Tetexact), returns the sum of the reaction extents in all triangular elements of the patch.</p>"}}, "Area": {"@code": ["val = sim.patch.Area"], "@doc": "<p> Returns the area of patch with identifier string patch (in m^2).</p>"}}}, "Wmrssa": {"Compartment": {"Species": {"Count": {"@code": ["cnt = sim.comp.spec.Count"], "@doc": "<p> Returns the number of molecules of a species with identifier string spec in compartment with identifier string comp.</p><p>In a mesh-based simulation this is the combined count from all tetrahedral elements in the compartment.</p>"}, "Conc": {"@code": ["conc = sim.comp.spec.Conc"], "@doc": "<p> Returns the concentration (in Molar units) of species with identifier string spec in compartment with identifier string comp.</p><p>Note: in a mesh-based simulation this is calculated from the combined number of molecules from all tetrahedral elements in the compartment and the total volume of the tetrahedrons.</p>"}, "Amount": {"@code": ["val = sim.comp.spec.Amount"], "@doc": "<p> Returns the amount (in mols) of species with identifier string spec in compartment with identifier string comp.</p><p>In a mesh-based simulation this is the combined amount from all tetrahedral elements in the compartment.</p>"}, "Clamped": {"@code": ["clamped = sim.comp.spec.Clamped"], "@doc": "<p> Returns True if species with identifier string spec in compartment with identifier string comp is clamped, which means the concentration remains the same regardless of reactions that consume or produce molecules of this species. Returns False if not.</p><p>Note: in a mesh-based simulation it returns True only if the species is clamped in all tetrahedral elements of the compartment.</p>"}}, "Reaction": {"K": {"@code": ["val = sim.comp.reac['fwd'].K", "val = sim.comp.reac['bkw'].K"], "@doc": "<p> Returns the macroscopic reaction constant of reaction with identifier string reac in compartment with identifier string comp. The unit of the reaction constant depends on the order of the reaction.</p><p>Note: In a mesh-based simulation the value for the compartment is returned, although individual tetrahedral elements may have different values (set with setTetReacK).</p>"}, "Active": {"@code": ["active = sim.comp.reac['fwd'].Active", "active = sim.comp.reac['bkw'].Active"], "@doc": "<p> Returns whether a reaction with identifier string reac in compartment with identifier string comp is active (True) or not (False). If it's not active this means that a reaction will never occur regardless of whether the reactants are present in sufficient numbers or not.</p><p>Note: In a mesh-based simulation this method will return True only if the reaction is active in all tetrahedral elements in the compartment.</p>"}, "C": {"@code": ["val = sim.comp.reac['fwd'].C", "val = sim.comp.reac['bkw'].C"], "@doc": "<p> Returns the 'stochastic reaction constant' (or 'specific probability rate constant') of reaction with identifier string reac in compartment with identifier string comp.</p><p>The 'stochastic reaction constant' multiplied by infinitesimal time interval dt gives the average probability that one reaction channel of this reaction type will react accordingly in dt.</p><p>Note: in a mesh-based simulation (i.e. Tetexact), the stochastic reaction constant is computed as the weighted mean of the stochastic reaction constants in all tetrahedral elements of the compartment.</p>"}, "H": {"@code": ["val = sim.comp.reac['fwd'].H", "val = sim.comp.reac['bkw'].H"], "@doc": "<p> Returns h_mu, the distinct number of ways in which reaction with identifier string reac can occur in compartment with identifier string comp, by computing the product of its reactants. Note: in a mesh-based simulation (i.e. Tetexact), returns the sum of the h_mu's over all tetrahedral elements in the compartment.</p>"}, "A": {"@code": ["val = sim.comp.reac['fwd'].A", "val = sim.comp.reac['bkw'].A"], "@doc": "<p> Returns the propensity of reaction with identifier string reac in compartment with identifier string comp.</p><p>The propensity of a reaction is a function of state and is defined as the function whose product with infinitesimal time dt gives the probability that the reaction will occur in the next dt. It is the 'stochastic reaction constant' multiplied by 'h_mu'.</p><p>Note: in a mesh-based simulation (i.e. Tetexact), the propensity of a reaction in a compartment is computed as the sum of the propensities in all tetrahedral elements of the compartment.</p>"}, "Extent": {"@code": ["val = sim.comp.reac['fwd'].Extent", "val = sim.comp.reac['bkw'].Extent"], "@doc": "<p> Return the extent of reaction with identifier string reac in compartment with identifier string comp, that is the number of times the reaction has occurred up to the current simulation time.</p><p>Note: in a mesh-based simulation (i.e. Tetexact), returns the sum of the reaction extents in all tetrahedral elements of the compartment.</p>"}}, "Vol": {"@code": ["val = sim.comp.Vol"], "@doc": "<p> Returns the volume of compartment with identifier string comp (in m^3).</p>"}}, "Patch": {"Species": {"Count": {"@code": ["cnt = sim.patch.spec.Count"], "@doc": "<p> Returns the number of molecules of species with identifier string spec in patch with identifier string patch.Note: in a mesh-based simulation this is the combined count from all triangular elements in the patch.</p>"}, "Amount": {"@code": ["val = sim.patch.spec.Amount"], "@doc": "<p> Returns the amount (in mols) of species with identifier string spec in patch with identifier string patch.</p><p>Note: in a mesh-based simulation this is the combined amount from all triangular elements in the patch.</p>"}, "Clamped": {"@code": ["clamped = sim.patch.spec.Clamped"], "@doc": "<p> Gets whether the species with identifier string spec in patch with identifier string patch is clamped (clamped = True) or not (clamped = False). If a species is clamped the number of molecules stays the same regardless of surface reactions that consume or produce molecules of the species.</p><p>Note: in a mesh-based simulation this will return whether all of the triangles of the patch have this species clamped.</p>"}}, "Reaction": {"K": {"@code": ["val = sim.patch.sreac['fwd'].K", "val = sim.patch.sreac['bkw'].K"], "@doc": "<p> Returns the macroscopic reaction constant of surface reaction with identifier string sreac in patch with identifier string patch. The unit of the reaction constant depends on the order of the reaction.</p><p>Note: In a mesh-based solver the value for the patch is returned, although individual triangle elements may have different values (set with setTriSReacK).</p>"}, "Active": {"@code": ["active = sim.patch.sreac['fwd'].Active", "active = sim.patch.sreac['bkw'].Active"], "@doc": "<p> Returns whether a surface reaction with identifier string sreac in patch with identifier string patch is active (True) or not (False). If it's not active this means that a surface reaction will never occur regardless of whether the reactants are present in sufficient numbers or not.</p><p>Note: In a mesh-based simulation this method will return True only if the surface reaction is active in all triangular elements in the patch.</p>"}, "C": {"@code": ["val = sim.patch.sreac['fwd'].C", "val = sim.patch.sreac['bkw'].C"], "@doc": "<p> Returns the 'stochastic reaction constant' (or 'specific probability rate constant') of surface reaction with identifier string sreac in patch with identifier string patch.</p><p>Note: in a mesh-based simulation (i.e. Tetexact), the stochastic reaction constant is computed as the weighted mean of the stochastic reaction constants in all triangular elements of the patch.</p>"}, "H": {"@code": ["val = sim.patch.sreac['fwd'].H", "val = sim.patch.sreac['bkw'].H"], "@doc": "<p> Returns h_mu, the distinct number of ways in which surface reaction with identifier string sreac can occur in patch with identifier string patch, by computing the product of its reactants. Note: in a mesh-based simulation (i.e. Tetexact), returns the sum of the h_mu's over all triangular elements in the patch.</p>"}, "A": {"@code": ["val = sim.patch.sreac['fwd'].A", "val = sim.patch.sreac['bkw'].A"], "@doc": "<p> Returns the propensity of surface reaction with identifier string sreac in patch with identifier string patch. Note: in a mesh-based simulation (i.e. Tetexact), the propensity of a surface reaction in a patch is computed as the sum of the propensities in all triangular elements of the patch.</p>"}, "Extent": {"@code": ["val = sim.patch.sreac['fwd'].Extent", "val = sim.patch.sreac['bkw'].Extent"], "@doc": "<p> Returns the extent of surface reaction with identifier string sreac in patch with identifier string patch, that is the number of times the surface reaction has occurred up to the current simulation time.</p><p>Note: in a mesh-based simulation (i.e. Tetexact), returns the sum of the reaction extents in all triangular elements of the patch.</p>"}}, "Area": {"@code": ["val = sim.patch.Area"], "@doc": "<p> Returns the area of patch with identifier string patch (in m^2).</p>"}}}, "Wmrk4": {"Compartment": {"Species": {"Count": {"@code": ["cnt = sim.comp.spec.Count"], "@doc": "<p> Returns the number of molecules of a species with identifier string spec in compartment with identifier string comp.</p><p>In a mesh-based simulation this is the combined count from all tetrahedral elements in the compartment.</p>"}, "Conc": {"@code": ["conc = sim.comp.spec.Conc"], "@doc": "<p> Returns the concentration (in Molar units) of species with identifier string spec in compartment with identifier string comp.</p><p>Note: in a mesh-based simulation this is calculated from the combined number of molecules from all tetrahedral elements in the compartment and the total volume of the tetrahedrons.</p>"}, "Amount": {"@code": ["val = sim.comp.spec.Amount"], "@doc": "<p> Returns the amount (in mols) of species with identifier string spec in compartment with identifier string comp.</p><p>In a mesh-based simulation this is the combined amount from all tetrahedral elements in the compartment.</p>"}, "Clamped": {"@code": ["clamped = sim.comp.spec.Clamped"], "@doc": "<p> Returns True if species with identifier string spec in compartment with identifier string comp is clamped, which means the concentration remains the same regardless of reactions that consume or produce molecules of this species. Returns False if not.</p><p>Note: in a mesh-based simulation it returns True only if the species is clamped in all tetrahedral elements of the compartment.</p>"}}, "Reaction": {"K": {"@code": ["val = sim.comp.reac['fwd'].K", "val = sim.comp.reac['bkw'].K"], "@doc": "<p> Returns the macroscopic reaction constant of reaction with identifier string reac in compartment with identifier string comp. The unit of the reaction constant depends on the order of the reaction.</p><p>Note: In a mesh-based simulation the value for the compartment is returned, although individual tetrahedral elements may have different values (set with setTetReacK).</p>"}, "Active": {"@code": ["active = sim.comp.reac['fwd'].Active", "active = sim.comp.reac['bkw'].Active"], "@doc": "<p> Returns whether a reaction with identifier string reac in compartment with identifier string comp is active (True) or not (False). If it's not active this means that a reaction will never occur regardless of whether the reactants are present in sufficient numbers or not.</p><p>Note: In a mesh-based simulation this method will return True only if the reaction is active in all tetrahedral elements in the compartment.</p>"}, "C": {"@code": ["val = sim.comp.reac['fwd'].C", "val = sim.comp.reac['bkw'].C"], "@doc": "<p> Returns the 'stochastic reaction constant' (or 'specific probability rate constant') of reaction with identifier string reac in compartment with identifier string comp.</p><p>The 'stochastic reaction constant' multiplied by infinitesimal time interval dt gives the average probability that one reaction channel of this reaction type will react accordingly in dt.</p><p>Note: in a mesh-based simulation (i.e. Tetexact), the stochastic reaction constant is computed as the weighted mean of the stochastic reaction constants in all tetrahedral elements of the compartment.</p>"}, "H": {"@code": ["val = sim.comp.reac['fwd'].H", "val = sim.comp.reac['bkw'].H"], "@doc": "<p> Returns h_mu, the distinct number of ways in which reaction with identifier string reac can occur in compartment with identifier string comp, by computing the product of its reactants. Note: in a mesh-based simulation (i.e. Tetexact), returns the sum of the h_mu's over all tetrahedral elements in the compartment.</p>"}, "A": {"@code": ["val = sim.comp.reac['fwd'].A", "val = sim.comp.reac['bkw'].A"], "@doc": "<p> Returns the propensity of reaction with identifier string reac in compartment with identifier string comp.</p><p>The propensity of a reaction is a function of state and is defined as the function whose product with infinitesimal time dt gives the probability that the reaction will occur in the next dt. It is the 'stochastic reaction constant' multiplied by 'h_mu'.</p><p>Note: in a mesh-based simulation (i.e. Tetexact), the propensity of a reaction in a compartment is computed as the sum of the propensities in all tetrahedral elements of the compartment.</p>"}, "Extent": {"@code": ["val = sim.comp.reac['fwd'].Extent", "val = sim.comp.reac['bkw'].Extent"], "@doc": "<p> Return the extent of reaction with identifier string reac in compartment with identifier string comp, that is the number of times the reaction has occurred up to the current simulation time.</p><p>Note: in a mesh-based simulation (i.e. Tetexact), returns the sum of the reaction extents in all tetrahedral elements of the compartment.</p>"}}, "Vol": {"@code": ["val = sim.comp.Vol"], "@doc": "<p> Returns the volume of compartment with identifier string comp (in m^3).</p>"}}, "Patch": {"Species": {"Count": {"@code": ["cnt = sim.patch.spec.Count"], "@doc": "<p> Returns the number of molecules of species with identifier string spec in patch with identifier string patch.Note: in a mesh-based simulation this is the combined count from all triangular elements in the patch.</p>"}, "Amount": {"@code": ["val = sim.patch.spec.Amount"], "@doc": "<p> Returns the amount (in mols) of species with identifier string spec in patch with identifier string patch.</p><p>Note: in a mesh-based simulation this is the combined amount from all triangular elements in the patch.</p>"}, "Clamped": {"@code": ["clamped = sim.patch.spec.Clamped"], "@doc": "<p> Gets whether the species with identifier string spec in patch with identifier string patch is clamped (clamped = True) or not (clamped = False). If a species is clamped the number of molecules stays the same regardless of surface reactions that consume or produce molecules of the species.</p><p>Note: in a mesh-based simulation this will return whether all of the triangles of the patch have this species clamped.</p>"}}, "Reaction": {"K": {"@code": ["val = sim.patch.sreac['fwd'].K", "val = sim.patch.sreac['bkw'].K"], "@doc": "<p> Returns the macroscopic reaction constant of surface reaction with identifier string sreac in patch with identifier string patch. The unit of the reaction constant depends on the order of the reaction.</p><p>Note: In a mesh-based solver the value for the patch is returned, although individual triangle elements may have different values (set with setTriSReacK).</p>"}, "Active": {"@code": ["active = sim.patch.sreac['fwd'].Active", "active = sim.patch.sreac['bkw'].Active"], "@doc": "<p> Returns whether a surface reaction with identifier string sreac in patch with identifier string patch is active (True) or not (False). If it's not active this means that a surface reaction will never occur regardless of whether the reactants are present in sufficient numbers or not.</p><p>Note: In a mesh-based simulation this method will return True only if the surface reaction is active in all triangular elements in the patch.</p>"}, "C": {"@code": ["val = sim.patch.sreac['fwd'].C", "val = sim.patch.sreac['bkw'].C"], "@doc": "<p> Returns the 'stochastic reaction constant' (or 'specific probability rate constant') of surface reaction with identifier string sreac in patch with identifier string patch.</p><p>Note: in a mesh-based simulation (i.e. Tetexact), the stochastic reaction constant is computed as the weighted mean of the stochastic reaction constants in all triangular elements of the patch.</p>"}, "H": {"@code": ["val = sim.patch.sreac['fwd'].H", "val = sim.patch.sreac['bkw'].H"], "@doc": "<p> Returns h_mu, the distinct number of ways in which surface reaction with identifier string sreac can occur in patch with identifier string patch, by computing the product of its reactants. Note: in a mesh-based simulation (i.e. Tetexact), returns the sum of the h_mu's over all triangular elements in the patch.</p>"}, "A": {"@code": ["val = sim.patch.sreac['fwd'].A", "val = sim.patch.sreac['bkw'].A"], "@doc": "<p> Returns the propensity of surface reaction with identifier string sreac in patch with identifier string patch. Note: in a mesh-based simulation (i.e. Tetexact), the propensity of a surface reaction in a patch is computed as the sum of the propensities in all triangular elements of the patch.</p>"}, "Extent": {"@code": ["val = sim.patch.sreac['fwd'].Extent", "val = sim.patch.sreac['bkw'].Extent"], "@doc": "<p> Returns the extent of surface reaction with identifier string sreac in patch with identifier string patch, that is the number of times the surface reaction has occurred up to the current simulation time.</p><p>Note: in a mesh-based simulation (i.e. Tetexact), returns the sum of the reaction extents in all triangular elements of the patch.</p>"}}, "Area": {"@code": ["val = sim.patch.Area"], "@doc": "<p> Returns the area of patch with identifier string patch (in m^2).</p>"}}}, "Tetexact": {"Compartment": {"Species": {"Count": {"@code": ["cnt = sim.comp.spec.Count"], "@doc": "<p> Returns the number of molecules of a species with identifier string spec in compartment with identifier string comp.</p><p>In a mesh-based simulation this is the combined count from all tetrahedral elements in the compartment.</p>"}, "Conc": {"@code": ["conc = sim.comp.spec.Conc"], "@doc": "<p> Returns the concentration (in Molar units) of species with identifier string spec in compartment with identifier string comp.</p><p>Note: in a mesh-based simulation this is calculated from the combined number of molecules from all tetrahedral elements in the compartment and the total volume of the tetrahedrons.</p>"}, "Amount": {"@code": ["val = sim.comp.spec.Amount"], "@doc": "<p> Returns the amount (in mols) of species with identifier string spec in compartment with identifier string comp.</p><p>In a mesh-based simulation this is the combined amount from all tetrahedral elements in the compartment.</p>"}, "Clamped": {"@code": ["clamped = sim.comp.spec.Clamped"], "@doc": "<p> Returns True if species with identifier string spec in compartment with identifier string comp is clamped, which means the concentration remains the same regardless of reactions that consume or produce molecules of this species. Returns False if not.</p><p>Note: in a mesh-based simulation it returns True only if the species is clamped in all tetrahedral elements of the compartment.</p>"}}, "Reaction": {"K": {"@code": ["val = sim.comp.reac['fwd'].K", "val = sim.comp.reac['bkw'].K"], "@doc": "<p> Returns the macroscopic reaction constant of reaction with identifier string reac in compartment with identifier string comp. The unit of the reaction constant depends on the order of the reaction.</p><p>Note: In a mesh-based simulation the value for the compartment is returned, although individual tetrahedral elements may have different values (set with setTetReacK).</p>"}, "Active": {"@code": ["active = sim.comp.reac['fwd'].Active", "active = sim.comp.reac['bkw'].Active"], "@doc": "<p> Returns whether a reaction with identifier string reac in compartment with identifier string comp is active (True) or not (False). If it's not active this means that a reaction will never occur regardless of whether the reactants are present in sufficient numbers or not.</p><p>Note: In a mesh-based simulation this method will return True only if the reaction is active in all tetrahedral elements in the compartment.</p>"}, "C": {"@code": ["val = sim.comp.reac['fwd'].C", "val = sim.comp.reac['bkw'].C"], "@doc": "<p> Returns the 'stochastic reaction constant' (or 'specific probability rate constant') of reaction with identifier string reac in compartment with identifier string comp.</p><p>The 'stochastic reaction constant' multiplied by infinitesimal time interval dt gives the average probability that one reaction channel of this reaction type will react accordingly in dt.</p><p>Note: in a mesh-based simulation (i.e. Tetexact), the stochastic reaction constant is computed as the weighted mean of the stochastic reaction constants in all tetrahedral elements of the compartment.</p>"}, "H": {"@code": ["val = sim.comp.reac['fwd'].H", "val = sim.comp.reac['bkw'].H"], "@doc": "<p> Returns h_mu, the distinct number of ways in which reaction with identifier string reac can occur in compartment with identifier string comp, by computing the product of its reactants. Note: in a mesh-based simulation (i.e. Tetexact), returns the sum of the h_mu's over all tetrahedral elements in the compartment.</p>"}, "A": {"@code": ["val = sim.comp.reac['fwd'].A", "val = sim.comp.reac['bkw'].A"], "@doc": "<p> Returns the propensity of reaction with identifier string reac in compartment with identifier string comp.</p><p>The propensity of a reaction is a function of state and is defined as the function whose product with infinitesimal time dt gives the probability that the reaction will occur in the next dt. It is the 'stochastic reaction constant' multiplied by 'h_mu'.</p><p>Note: in a mesh-based simulation (i.e. Tetexact), the propensity of a reaction in a compartment is computed as the sum of the propensities in all tetrahedral elements of the compartment.</p>"}, "Extent": {"@code": ["val = sim.comp.reac['fwd'].Extent", "val = sim.comp.reac['bkw'].Extent"], "@doc": "<p> Return the extent of reaction with identifier string reac in compartment with identifier string comp, that is the number of times the reaction has occurred up to the current simulation time.</p><p>Note: in a mesh-based simulation (i.e. Tetexact), returns the sum of the reaction extents in all tetrahedral elements of the compartment.</p>"}}, "Diffusion": {"Active": {"@code": ["active = sim.comp.diff.Active"], "@doc": "<p> Returns whether a diffusion rule with identifier string diff in compartment with identifier string comp is active (True) or not (False). If diffusion of a species is inactive this means the molecules will remain in place and has the same effect as a diffusion constant of zero.</p>"}, "D": {"@code": ["dcst = sim.comp.diff.D"], "@doc": "<p> Returns the diffusion constant of diffusion rule with identifier string diff in compartment with identifier string comp. This constant is in units m^2/s.</p><p>Note: In a mesh-based solver the value for the compartment is returned, although individual or groups of tetrahedral elements may have different values (set with setTetDiffD).</p>"}}, "Vol": {"@code": ["val = sim.comp.Vol"], "@doc": "<p> Returns the volume of compartment with identifier string comp (in m^3).</p>"}}, "Patch": {"Species": {"Count": {"@code": ["cnt = sim.patch.spec.Count"], "@doc": "<p> Returns the number of molecules of species with identifier string spec in patch with identifier string patch.Note: in a mesh-based simulation this is the combined count from all triangular elements in the patch.</p>"}, "Amount": {"@code": ["val = sim.patch.spec.Amount"], "@doc": "<p> Returns the amount (in mols) of species with identifier string spec in patch with identifier string patch.</p><p>Note: in a mesh-based simulation this is the combined amount from all triangular elements in the patch.</p>"}, "Clamped": {"@code": ["clamped = sim.patch.spec.Clamped"], "@doc": "<p> Gets whether the species with identifier string spec in patch with identifier string patch is clamped (clamped = True) or not (clamped = False). If a species is clamped the number of molecules stays the same regardless of surface reactions that consume or produce molecules of the species.</p><p>Note: in a mesh-based simulation this will return whether all of the triangles of the patch have this species clamped.</p>"}}, "Reaction": {"K": {"@code": ["val = sim.patch.sreac['fwd'].K", "val = sim.patch.sreac['bkw'].K"], "@doc": "<p> Returns the macroscopic reaction constant of surface reaction with identifier string sreac in patch with identifier string patch. The unit of the reaction constant depends on the order of the reaction.</p><p>Note: In a mesh-based solver the value for the patch is returned, although individual triangle elements may have different values (set with setTriSReacK).</p>"}, "Active": {"@code": ["active = sim.patch.sreac['fwd'].Active", "active = sim.patch.sreac['bkw'].Active"], "@doc": "<p> Returns whether a surface reaction with identifier string sreac in patch with identifier string patch is active (True) or not (False). If it's not active this means that a surface reaction will never occur regardless of whether the reactants are present in sufficient numbers or not.</p><p>Note: In a mesh-based simulation this method will return True only if the surface reaction is active in all triangular elements in the patch.</p>"}, "C": {"@code": ["val = sim.patch.sreac['fwd'].C", "val = sim.patch.sreac['bkw'].C"], "@doc": "<p> Returns the 'stochastic reaction constant' (or 'specific probability rate constant') of surface reaction with identifier string sreac in patch with identifier string patch.</p><p>Note: in a mesh-based simulation (i.e. Tetexact), the stochastic reaction constant is computed as the weighted mean of the stochastic reaction constants in all triangular elements of the patch.</p>"}, "H": {"@code": ["val = sim.patch.sreac['fwd'].H", "val = sim.patch.sreac['bkw'].H"], "@doc": "<p> Returns h_mu, the distinct number of ways in which surface reaction with identifier string sreac can occur in patch with identifier string patch, by computing the product of its reactants. Note: in a mesh-based simulation (i.e. Tetexact), returns the sum of the h_mu's over all triangular elements in the patch.</p>"}, "A": {"@code": ["val = sim.patch.sreac['fwd'].A", "val = sim.patch.sreac['bkw'].A"], "@doc": "<p> Returns the propensity of surface reaction with identifier string sreac in patch with identifier string patch. Note: in a mesh-based simulation (i.e. Tetexact), the propensity of a surface reaction in a patch is computed as the sum of the propensities in all triangular elements of the patch.</p>"}, "Extent": {"@code": ["val = sim.patch.sreac['fwd'].Extent", "val = sim.patch.sreac['bkw'].Extent"], "@doc": "<p> Returns the extent of surface reaction with identifier string sreac in patch with identifier string patch, that is the number of times the surface reaction has occurred up to the current simulation time.</p><p>Note: in a mesh-based simulation (i.e. Tetexact), returns the sum of the reaction extents in all triangular elements of the patch.</p>"}}, "Area": {"@code": ["val = sim.patch.Area"], "@doc": "<p> Returns the area of patch with identifier string patch (in m^2).</p>"}}, "Diff. Boundary": {"Species": {"DiffusionActive": {"@code": ["val = sim.diffb.spec.DiffusionActive"], "@doc": "<p> Returns whether diffusion is active across a diffusion boundary for a species.</p>"}}}, "Surf. Diff. Boundary": {"Species": {"DiffusionActive": {"@code": ["val = sim.sdiffb.spec.DiffusionActive"], "@doc": "<p> Returns whether diffusion is active across a surface diffusion boundary for a species.</p>"}}}, "Region of Interest": {"Species": {"Count": {"@code": ["cnt = sim.roi.spec.Count"], "@doc": "<p> Get the count of a species in a ROI.</p>"}, "Conc": {"@code": ["conc = sim.roi.spec.Conc"], "@doc": "<p> Get the concentration of a species in a ROI.</p>"}, "Amount": {"@code": ["val = sim.roi.spec.Amount"], "@doc": "<p> Get the amount of a species in a ROI.</p>"}}, "Reaction": {"Extent": {"@code": ["val = sim.roi.reac['fwd'].Extent", "val = sim.roi.reac['bkw'].Extent"], "@doc": "<p> Return the extent of reaction with identifier string reac in ROI with identifier string roi, that is the number of times the reaction has occurred up to the current simulation time.</p>"}}, "Diffusion": {"Extent": {"@code": ["val = sim.roi.diff.Extent"], "@doc": "<p> Return the extent of diffusion with identifier string diff in ROI with identifier string roi, that is the number of times the diffusion has occurred up to the current simulation time.</p>"}}, "Area": {"@code": ["val = sim.roi.Area"], "@doc": "<p> Get the area of a ROI.</p>"}, "Vol": {"@code": ["val = sim.roi.Vol"], "@doc": "<p> Get the volume of a ROI.</p>"}}, "Tetrahedron": {"Species": {"Count": {"@code": ["cnt = sim.TET(tet).spec.Count", "cnt = sim.TETS(tetLst).spec.Count"], "@doc": "<p> Returns the number of molecules of species with identifier string spec in the tetrahedral element tet.</p>"}, "Conc": {"@code": ["conc = sim.TET(tet).spec.Conc", "conc = sim.TETS(tetLst).spec.Conc"], "@doc": "<p> Returns the concentration (in Molar units) of species with identifier string spec in a tetrahedral element tet.</p>"}, "Amount": {"@code": ["val = sim.TET(tet).spec.Amount", "val = sim.TETS(tetLst).spec.Amount"], "@doc": "<p> Returns the amount (in mols) of species with identifier string spec in tetrahedral element tet.</p>"}, "Clamped": {"@code": ["clamped = sim.TET(tet).spec.Clamped", "clamped = sim.TETS(tetLst).spec.Clamped"], "@doc": "<p> Returns True if concentration of species with identifier string spec in tetrahedral element tet is clamped, which means the concentration stays the same regardless of reactions that consume or produce molecules of this species or diffusion of this species into or out of the tetrahedral element. Returns False if not.</p>"}}, "Reaction": {"K": {"@code": ["val = sim.TET(tet).reac['fwd'].K", "val = sim.TET(tet).reac['bkw'].K", "val = sim.TETS(tetLst).reac['fwd'].K", "val = sim.TETS(tetLst).reac['bkw'].K"], "@doc": "<p> Returns the macroscopic reaction constant of reaction with identifier string reac in tetrahedral element tet. The unit of the reaction constant depends on the order of the reaction.</p>"}, "Active": {"@code": ["active = sim.TET(tet).reac['fwd'].Active", "active = sim.TET(tet).reac['bkw'].Active", "active = sim.TETS(tetLst).reac['fwd'].Active", "active = sim.TETS(tetLst).reac['bkw'].Active"], "@doc": "<p> Returns whether reaction with identifier string reac in tetrahedral element tet is active (True) or not (False). If it's not active this means that the reaction will never occur regardless of whether reactants are present in sufficient numbers or not.</p>"}, "C": {"@code": ["val = sim.TET(tet).reac['fwd'].C", "val = sim.TET(tet).reac['bkw'].C", "val = sim.TETS(tetLst).reac['fwd'].C", "val = sim.TETS(tetLst).reac['bkw'].C"], "@doc": "<p> Returns the 'stochastic reaction constant' (or 'specific probability rate constant') of reaction with identifier string reac in tetrahedral element tet.</p>"}, "H": {"@code": ["val = sim.TET(tet).reac['fwd'].H", "val = sim.TET(tet).reac['bkw'].H", "val = sim.TETS(tetLst).reac['fwd'].H", "val = sim.TETS(tetLst).reac['bkw'].H"], "@doc": "<p> Returns h_mu, the distinct number of ways in which reaction with identifier string reac can occur in tetrahedral element tet, by computing the product of its reactants.</p>"}, "A": {"@code": ["val = sim.TET(tet).reac['fwd'].A", "val = sim.TET(tet).reac['bkw'].A", "val = sim.TETS(tetLst).reac['fwd'].A", "val = sim.TETS(tetLst).reac['bkw'].A"], "@doc": "<p> Returns the propensity of reaction with identifier string reac in tetrahedral element tet.</p>"}}, "Diffusion": {"Active": {"@code": ["active = sim.TET(tet).diff.Active", "active = sim.TETS(tetLst).diff.Active"], "@doc": "<p> Returns whether diffusion with identifier string diff in tetrahedral element tet is active (True) or not (False). If diffusion of a species is inactive this means the molecules will never diffuse out of the tetrahedron and has the same effect as a diffusion constant of zero.</p>"}, "D": {"@code": ["dcst = sim.TET(tet).diff.D", "dcst = sim.TET(tet).diff(direc=tet2).D", "dcst = sim.TETS(tetLst).diff.D"], "@doc": "<p> Returns the diffusion constant of diffusion rule with identifier string diff in tetrahedral element tet. This constant is in units m^2/s. If direc is specified, return the diffusion constant towards that direction.</p>"}, "A": {"@code": ["val = sim.TET(tet).diff.A", "val = sim.TETS(tetLst).diff.A"], "@doc": "<p> Returns the propensity of diffusion rule with identifier string diff in tetrahedral element tet.</p>"}}, "Vol": {"@code": ["val = sim.TET(tet).Vol", "val = sim.TETS(tetLst).Vol"], "@doc": "<p> Returns the volume (in m^3) of the tetrahedral element tet.</p>"}, "V": {"@code": ["val = sim.TET(tet).V", "val = sim.TETS(tetLst).V"], "@doc": "<p> Returns the potential (in volts) of tetrahedral element tet, taken at the barycenter.</p>"}, "VClamped": {"@code": ["clamped = sim.TET(tet).VClamped", "clamped = sim.TETS(tetLst).VClamped"], "@doc": "<p> Returns true if the potential of tetrahedral element tet is clamped to some voltage.</p>"}}, "Triangle": {"Species": {"Count": {"@code": ["cnt = sim.TRI(tri).spec.Count", "cnt = sim.TRIS(triLst).spec.Count"], "@doc": "<p> Returns the number of molecules of species with identifier string spec in the triangular element tri.</p>"}, "Amount": {"@code": ["val = sim.TRI(tri).spec.Amount", "val = sim.TRIS(triLst).spec.Amount"], "@doc": "<p> Returns the amount (in mols) of species with identifier string spec in triangular element tri.</p>"}, "Clamped": {"@code": ["clamped = sim.TRI(tri).spec.Clamped", "clamped = sim.TRIS(triLst).spec.Clamped"], "@doc": "<p> Returns True if the species with identifier string spec in triangular element tri is clamped, which means the number of molecules stays the same regardless of reactions that consume or produce molecules of this species. Returns False if not.</p>"}}, "Reaction": {"K": {"@code": ["val = sim.TRI(tri).sreac['fwd'].K", "val = sim.TRI(tri).sreac['bkw'].K", "val = sim.TRIS(triLst).sreac['fwd'].K", "val = sim.TRIS(triLst).sreac['bkw'].K"], "@doc": "<p> Returns the macroscopic reaction constant of surface reaction with identifier string sreac in triangular element tri. The units of the reaction constant depends on the order of the reaction.</p>"}, "Active": {"@code": ["active = sim.TRI(tri).sreac['fwd'].Active", "active = sim.TRI(tri).sreac['bkw'].Active", "active = sim.TRIS(triLst).sreac['fwd'].Active", "active = sim.TRIS(triLst).sreac['bkw'].Active"], "@doc": "<p> Returns whether surface reaction with identifier string sreac in triangular element tri is active (True) or not (False). If it's not active this means that the surface reaction will never occur regardless of whether reactants are present in sufficient numbers or not.</p>"}, "C": {"@code": ["val = sim.TRI(tri).sreac['fwd'].C", "val = sim.TRI(tri).sreac['bkw'].C", "val = sim.TRIS(triLst).sreac['fwd'].C", "val = sim.TRIS(triLst).sreac['bkw'].C"], "@doc": "<p> Returns the 'stochastic reaction constant' (or 'specific probability rate constant') of surface reaction with identifier string sreac in triangular element tri.</p>"}, "H": {"@code": ["val = sim.TRI(tri).sreac['fwd'].H", "val = sim.TRI(tri).sreac['bkw'].H", "val = sim.TRIS(triLst).sreac['fwd'].H", "val = sim.TRIS(triLst).sreac['bkw'].H"], "@doc": "<p> Returns h_mu, the distinct number of ways in which surface reaction with identifier string sreac can occur in triangular element tri, by computing the product of its reactants.</p>"}, "A": {"@code": ["val = sim.TRI(tri).sreac['fwd'].A", "val = sim.TRI(tri).sreac['bkw'].A", "val = sim.TRIS(triLst).sreac['fwd'].A", "val = sim.TRIS(triLst).sreac['bkw'].A"], "@doc": "<p> Returns the propensity of surface reaction with identifier string sreac in triangular element tri.</p>"}}, "Diffusion": {"D": {"@code": ["dcst = sim.TRI(tri).sdiff.D", "dcst = sim.TRI(tri).sdiff(direc=tri2).D", "dcst = sim.TRIS(triLst).sdiff.D"], "@doc": "<p> Returns the diffusion constant of diffusion rule with identifier string diff in triangle element tri. If direc is specified, return the diffusion constant towards that direction.</p>"}}, "Current": {"I": {"@code": ["val = sim.TRI(tri).curr.I", "val = sim.TRIS(triLst).curr.I"], "@doc": "<p> Returns the ohmic or GHK current with string identifier curr of triangle element tri, in amps.</p>"}}, "Area": {"@code": ["val = sim.TRI(tri).Area", "val = sim.TRIS(triLst).Area"], "@doc": "<p> Returns the area (in m^2) of the triangular element tri.</p>"}, "V": {"@code": ["val = sim.TRI(tri).V", "val = sim.TRIS(triLst).V"], "@doc": "<p> Returns the potential (in volts) of triangle element tri, taken at the barycenter.</p>"}, "VClamped": {"@code": ["clamped = sim.TRI(tri).VClamped", "clamped = sim.TRIS(triLst).VClamped"], "@doc": "<p> Returns true if the potential of triangle element tri is clamped to some voltage.</p>"}, "IClamp": {"@code": ["val = sim.TRI(tri).IClamp", "val = sim.TRIS(triLst).IClamp"], "@doc": "<p> Get current clamp to triangle element tri. NOTE: Convention is maintained that a positive current clamp is depolarizing, a negative current clamp is hyperpolarizing.</p>"}, "I": {"@code": ["val = sim.TRI(tri).I", "val = sim.TRIS(triLst).I"], "@doc": "<p> Returns the current of triangle element tri, in amps, at the last EField calculation step.</p>"}}, "Membrane": {"Res": {"@code": ["ro, vrev = sim.memb.Res"], "@doc": "<p> Gets the surface electrical resistivity (ro) in ohm.m^2 of the membrane with string identifier memb, and the reversal potential (vrev) in Volts.</p>"}}, "Vertex": {"V": {"@code": ["val = sim.VERT(vert).V", "val = sim.VERTS(vertLst).V"], "@doc": "<p> Returns the potential (in volts) of vertex element vert.</p>"}, "VClamped": {"@code": ["clamped = sim.VERT(vert).VClamped", "clamped = sim.VERTS(vertLst).VClamped"], "@doc": "<p> Returns true if the potential of vertex element vert is clamped to some voltage.</p>"}, "IClamp": {"@code": ["val = sim.VERT(vert).IClamp", "val = sim.VERTS(vertLst).IClamp"], "@doc": "<p> Get current clamp to vertex element with index vidx (Amps). NOTE: Convention is maintained that a positive current clamp is depolarizing, a negative current clamp is hyperpolarizing.</p>"}}}, "TetODE": {"Compartment": {"Species": {"Count": {"@code": ["cnt = sim.comp.spec.Count"], "@doc": "<p> Returns the number of molecules of a species with identifier string spec in compartment with identifier string comp.</p><p>In a mesh-based simulation this is the combined count from all tetrahedral elements in the compartment.</p>"}, "Conc": {"@code": ["conc = sim.comp.spec.Conc"], "@doc": "<p> Returns the concentration (in Molar units) of species with identifier string spec in compartment with identifier string comp.</p><p>Note: in a mesh-based simulation this is calculated from the combined number of molecules from all tetrahedral elements in the compartment and the total volume of the tetrahedrons.</p>"}, "Amount": {"@code": ["val = sim.comp.spec.Amount"], "@doc": "<p> Returns the amount (in mols) of species with identifier string spec in compartment with identifier string comp.</p><p>In a mesh-based simulation this is the combined amount from all tetrahedral elements in the compartment.</p>"}, "Clamped": {"@code": ["clamped = sim.comp.spec.Clamped"], "@doc": "<p> Returns True if species with identifier string spec in compartment with identifier string comp is clamped, which means the concentration remains the same regardless of reactions that consume or produce molecules of this species. Returns False if not.</p><p>Note: in a mesh-based simulation it returns True only if the species is clamped in all tetrahedral elements of the compartment.</p>"}}, "Reaction": {"K": {"@code": ["val = sim.comp.reac['fwd'].K", "val = sim.comp.reac['bkw'].K"], "@doc": "<p> Returns the macroscopic reaction constant of reaction with identifier string reac in compartment with identifier string comp. The unit of the reaction constant depends on the order of the reaction.</p><p>Note: In a mesh-based simulation the value for the compartment is returned, although individual tetrahedral elements may have different values (set with setTetReacK).</p>"}, "Active": {"@code": ["active = sim.comp.reac['fwd'].Active", "active = sim.comp.reac['bkw'].Active"], "@doc": "<p> Returns whether a reaction with identifier string reac in compartment with identifier string comp is active (True) or not (False). If it's not active this means that a reaction will never occur regardless of whether the reactants are present in sufficient numbers or not.</p><p>Note: In a mesh-based simulation this method will return True only if the reaction is active in all tetrahedral elements in the compartment.</p>"}, "C": {"@code": ["val = sim.comp.reac['fwd'].C", "val = sim.comp.reac['bkw'].C"], "@doc": "<p> Returns the 'stochastic reaction constant' (or 'specific probability rate constant') of reaction with identifier string reac in compartment with identifier string comp.</p><p>The 'stochastic reaction constant' multiplied by infinitesimal time interval dt gives the average probability that one reaction channel of this reaction type will react accordingly in dt.</p><p>Note: in a mesh-based simulation (i.e. Tetexact), the stochastic reaction constant is computed as the weighted mean of the stochastic reaction constants in all tetrahedral elements of the compartment.</p>"}, "H": {"@code": ["val = sim.comp.reac['fwd'].H", "val = sim.comp.reac['bkw'].H"], "@doc": "<p> Returns h_mu, the distinct number of ways in which reaction with identifier string reac can occur in compartment with identifier string comp, by computing the product of its reactants. Note: in a mesh-based simulation (i.e. Tetexact), returns the sum of the h_mu's over all tetrahedral elements in the compartment.</p>"}, "A": {"@code": ["val = sim.comp.reac['fwd'].A", "val = sim.comp.reac['bkw'].A"], "@doc": "<p> Returns the propensity of reaction with identifier string reac in compartment with identifier string comp.</p><p>The propensity of a reaction is a function of state and is defined as the function whose product with infinitesimal time dt gives the probability that the reaction will occur in the next dt. It is the 'stochastic reaction constant' multiplied by 'h_mu'.</p><p>Note: in a mesh-based simulation (i.e. Tetexact), the propensity of a reaction in a compartment is computed as the sum of the propensities in all tetrahedral elements of the compartment.</p>"}, "Extent": {"@code": ["val = sim.comp.reac['fwd'].Extent", "val = sim.comp.reac['bkw'].Extent"], "@doc": "<p> Return the extent of reaction with identifier string reac in compartment with identifier string comp, that is the number of times the reaction has occurred up to the current simulation time.</p><p>Note: in a mesh-based simulation (i.e. Tetexact), returns the sum of the reaction extents in all tetrahedral elements of the compartment.</p>"}}, "Diffusion": {"Active": {"@code": ["active = sim.comp.diff.Active"], "@doc": "<p> Returns whether a diffusion rule with identifier string diff in compartment with identifier string comp is active (True) or not (False). If diffusion of a species is inactive this means the molecules will remain in place and has the same effect as a diffusion constant of zero.</p>"}, "D": {"@code": ["dcst = sim.comp.diff.D"], "@doc": "<p> Returns the diffusion constant of diffusion rule with identifier string diff in compartment with identifier string comp. This constant is in units m^2/s.</p><p>Note: In a mesh-based solver the value for the compartment is returned, although individual or groups of tetrahedral elements may have different values (set with setTetDiffD).</p>"}}, "Vol": {"@code": ["val = sim.comp.Vol"], "@doc": "<p> Returns the volume of compartment with identifier string comp (in m^3).</p>"}}, "Patch": {"Species": {"Count": {"@code": ["cnt = sim.patch.spec.Count"], "@doc": "<p> Returns the number of molecules of species with identifier string spec in patch with identifier string patch.Note: in a mesh-based simulation this is the combined count from all triangular elements in the patch.</p>"}, "Amount": {"@code": ["val = sim.patch.spec.Amount"], "@doc": "<p> Returns the amount (in mols) of species with identifier string spec in patch with identifier string patch.</p><p>Note: in a mesh-based simulation this is the combined amount from all triangular elements in the patch.</p>"}, "Clamped": {"@code": ["clamped = sim.patch.spec.Clamped"], "@doc": "<p> Gets whether the species with identifier string spec in patch with identifier string patch is clamped (clamped = True) or not (clamped = False). If a species is clamped the number of molecules stays the same regardless of surface reactions that consume or produce molecules of the species.</p><p>Note: in a mesh-based simulation this will return whether all of the triangles of the patch have this species clamped.</p>"}}, "Reaction": {"K": {"@code": ["val = sim.patch.sreac['fwd'].K", "val = sim.patch.sreac['bkw'].K"], "@doc": "<p> Returns the macroscopic reaction constant of surface reaction with identifier string sreac in patch with identifier string patch. The unit of the reaction constant depends on the order of the reaction.</p><p>Note: In a mesh-based solver the value for the patch is returned, although individual triangle elements may have different values (set with setTriSReacK).</p>"}, "Active": {"@code": ["active = sim.patch.sreac['fwd'].Active", "active = sim.patch.sreac['bkw'].Active"], "@doc": "<p> Returns whether a surface reaction with identifier string sreac in patch with identifier string patch is active (True) or not (False). If it's not active this means that a surface reaction will never occur regardless of whether the reactants are present in sufficient numbers or not.</p><p>Note: In a mesh-based simulation this method will return True only if the surface reaction is active in all triangular elements in the patch.</p>"}, "C": {"@code": ["val = sim.patch.sreac['fwd'].C", "val = sim.patch.sreac['bkw'].C"], "@doc": "<p> Returns the 'stochastic reaction constant' (or 'specific probability rate constant') of surface reaction with identifier string sreac in patch with identifier string patch.</p><p>Note: in a mesh-based simulation (i.e. Tetexact), the stochastic reaction constant is computed as the weighted mean of the stochastic reaction constants in all triangular elements of the patch.</p>"}, "H": {"@code": ["val = sim.patch.sreac['fwd'].H", "val = sim.patch.sreac['bkw'].H"], "@doc": "<p> Returns h_mu, the distinct number of ways in which surface reaction with identifier string sreac can occur in patch with identifier string patch, by computing the product of its reactants. Note: in a mesh-based simulation (i.e. Tetexact), returns the sum of the h_mu's over all triangular elements in the patch.</p>"}, "A": {"@code": ["val = sim.patch.sreac['fwd'].A", "val = sim.patch.sreac['bkw'].A"], "@doc": "<p> Returns the propensity of surface reaction with identifier string sreac in patch with identifier string patch. Note: in a mesh-based simulation (i.e. Tetexact), the propensity of a surface reaction in a patch is computed as the sum of the propensities in all triangular elements of the patch.</p>"}, "Extent": {"@code": ["val = sim.patch.sreac['fwd'].Extent", "val = sim.patch.sreac['bkw'].Extent"], "@doc": "<p> Returns the extent of surface reaction with identifier string sreac in patch with identifier string patch, that is the number of times the surface reaction has occurred up to the current simulation time.</p><p>Note: in a mesh-based simulation (i.e. Tetexact), returns the sum of the reaction extents in all triangular elements of the patch.</p>"}}, "Area": {"@code": ["val = sim.patch.Area"], "@doc": "<p> Returns the area of patch with identifier string patch (in m^2).</p>"}}, "Diff. Boundary": {"Species": {"DiffusionActive": {"@code": ["val = sim.diffb.spec.DiffusionActive"], "@doc": "<p> Returns whether diffusion is active across a diffusion boundary for a species.</p>"}}}, "Surf. Diff. Boundary": {"Species": {"DiffusionActive": {"@code": ["val = sim.sdiffb.spec.DiffusionActive"], "@doc": "<p> Returns whether diffusion is active across a surface diffusion boundary for a species.</p>"}}}, "Tetrahedron": {"Species": {"Count": {"@code": ["cnt = sim.TET(tet).spec.Count", "cnt = sim.TETS(tetLst).spec.Count"], "@doc": "<p> Returns the number of molecules of species with identifier string spec in the tetrahedral element tet.</p>"}, "Conc": {"@code": ["conc = sim.TET(tet).spec.Conc", "conc = sim.TETS(tetLst).spec.Conc"], "@doc": "<p> Returns the concentration (in Molar units) of species with identifier string spec in a tetrahedral element tet.</p>"}, "Amount": {"@code": ["val = sim.TET(tet).spec.Amount", "val = sim.TETS(tetLst).spec.Amount"], "@doc": "<p> Returns the amount (in mols) of species with identifier string spec in tetrahedral element tet.</p>"}, "Clamped": {"@code": ["clamped = sim.TET(tet).spec.Clamped", "clamped = sim.TETS(tetLst).spec.Clamped"], "@doc": "<p> Returns True if concentration of species with identifier string spec in tetrahedral element tet is clamped, which means the concentration stays the same regardless of reactions that consume or produce molecules of this species or diffusion of this species into or out of the tetrahedral element. Returns False if not.</p>"}}, "Reaction": {"K": {"@code": ["val = sim.TET(tet).reac['fwd'].K", "val = sim.TET(tet).reac['bkw'].K", "val = sim.TETS(tetLst).reac['fwd'].K", "val = sim.TETS(tetLst).reac['bkw'].K"], "@doc": "<p> Returns the macroscopic reaction constant of reaction with identifier string reac in tetrahedral element tet. The unit of the reaction constant depends on the order of the reaction.</p>"}, "Active": {"@code": ["active = sim.TET(tet).reac['fwd'].Active", "active = sim.TET(tet).reac['bkw'].Active", "active = sim.TETS(tetLst).reac['fwd'].Active", "active = sim.TETS(tetLst).reac['bkw'].Active"], "@doc": "<p> Returns whether reaction with identifier string reac in tetrahedral element tet is active (True) or not (False). If it's not active this means that the reaction will never occur regardless of whether reactants are present in sufficient numbers or not.</p>"}, "C": {"@code": ["val = sim.TET(tet).reac['fwd'].C", "val = sim.TET(tet).reac['bkw'].C", "val = sim.TETS(tetLst).reac['fwd'].C", "val = sim.TETS(tetLst).reac['bkw'].C"], "@doc": "<p> Returns the 'stochastic reaction constant' (or 'specific probability rate constant') of reaction with identifier string reac in tetrahedral element tet.</p>"}, "H": {"@code": ["val = sim.TET(tet).reac['fwd'].H", "val = sim.TET(tet).reac['bkw'].H", "val = sim.TETS(tetLst).reac['fwd'].H", "val = sim.TETS(tetLst).reac['bkw'].H"], "@doc": "<p> Returns h_mu, the distinct number of ways in which reaction with identifier string reac can occur in tetrahedral element tet, by computing the product of its reactants.</p>"}, "A": {"@code": ["val = sim.TET(tet).reac['fwd'].A", "val = sim.TET(tet).reac['bkw'].A", "val = sim.TETS(tetLst).reac['fwd'].A", "val = sim.TETS(tetLst).reac['bkw'].A"], "@doc": "<p> Returns the propensity of reaction with identifier string reac in tetrahedral element tet.</p>"}}, "Diffusion": {"Active": {"@code": ["active = sim.TET(tet).diff.Active", "active = sim.TETS(tetLst).diff.Active"], "@doc": "<p> Returns whether diffusion with identifier string diff in tetrahedral element tet is active (True) or not (False). If diffusion of a species is inactive this means the molecules will never diffuse out of the tetrahedron and has the same effect as a diffusion constant of zero.</p>"}, "D": {"@code": ["dcst = sim.TET(tet).diff.D", "dcst = sim.TET(tet).diff(direc=tet2).D", "dcst = sim.TETS(tetLst).diff.D"], "@doc": "<p> Returns the diffusion constant of diffusion rule with identifier string diff in tetrahedral element tet. This constant is in units m^2/s. If direc is specified, return the diffusion constant towards that direction.</p>"}, "A": {"@code": ["val = sim.TET(tet).diff.A", "val = sim.TETS(tetLst).diff.A"], "@doc": "<p> Returns the propensity of diffusion rule with identifier string diff in tetrahedral element tet.</p>"}}, "Vol": {"@code": ["val = sim.TET(tet).Vol", "val = sim.TETS(tetLst).Vol"], "@doc": "<p> Returns the volume (in m^3) of the tetrahedral element tet.</p>"}, "V": {"@code": ["val = sim.TET(tet).V", "val = sim.TETS(tetLst).V"], "@doc": "<p> Returns the potential (in volts) of tetrahedral element tet, taken at the barycenter.</p>"}, "VClamped": {"@code": ["clamped = sim.TET(tet).VClamped", "clamped = sim.TETS(tetLst).VClamped"], "@doc": "<p> Returns true if the potential of tetrahedral element tet is clamped to some voltage.</p>"}}, "Triangle": {"Species": {"Count": {"@code": ["cnt = sim.TRI(tri).spec.Count", "cnt = sim.TRIS(triLst).spec.Count"], "@doc": "<p> Returns the number of molecules of species with identifier string spec in the triangular element tri.</p>"}, "Amount": {"@code": ["val = sim.TRI(tri).spec.Amount", "val = sim.TRIS(triLst).spec.Amount"], "@doc": "<p> Returns the amount (in mols) of species with identifier string spec in triangular element tri.</p>"}, "Clamped": {"@code": ["clamped = sim.TRI(tri).spec.Clamped", "clamped = sim.TRIS(triLst).spec.Clamped"], "@doc": "<p> Returns True if the species with identifier string spec in triangular element tri is clamped, which means the number of molecules stays the same regardless of reactions that consume or produce molecules of this species. Returns False if not.</p>"}}, "Reaction": {"K": {"@code": ["val = sim.TRI(tri).sreac['fwd'].K", "val = sim.TRI(tri).sreac['bkw'].K", "val = sim.TRIS(triLst).sreac['fwd'].K", "val = sim.TRIS(triLst).sreac['bkw'].K"], "@doc": "<p> Returns the macroscopic reaction constant of surface reaction with identifier string sreac in triangular element tri. The units of the reaction constant depends on the order of the reaction.</p>"}, "Active": {"@code": ["active = sim.TRI(tri).sreac['fwd'].Active", "active = sim.TRI(tri).sreac['bkw'].Active", "active = sim.TRIS(triLst).sreac['fwd'].Active", "active = sim.TRIS(triLst).sreac['bkw'].Active"], "@doc": "<p> Returns whether surface reaction with identifier string sreac in triangular element tri is active (True) or not (False). If it's not active this means that the surface reaction will never occur regardless of whether reactants are present in sufficient numbers or not.</p>"}, "C": {"@code": ["val = sim.TRI(tri).sreac['fwd'].C", "val = sim.TRI(tri).sreac['bkw'].C", "val = sim.TRIS(triLst).sreac['fwd'].C", "val = sim.TRIS(triLst).sreac['bkw'].C"], "@doc": "<p> Returns the 'stochastic reaction constant' (or 'specific probability rate constant') of surface reaction with identifier string sreac in triangular element tri.</p>"}, "H": {"@code": ["val = sim.TRI(tri).sreac['fwd'].H", "val = sim.TRI(tri).sreac['bkw'].H", "val = sim.TRIS(triLst).sreac['fwd'].H", "val = sim.TRIS(triLst).sreac['bkw'].H"], "@doc": "<p> Returns h_mu, the distinct number of ways in which surface reaction with identifier string sreac can occur in triangular element tri, by computing the product of its reactants.</p>"}, "A": {"@code": ["val = sim.TRI(tri).sreac['fwd'].A", "val = sim.TRI(tri).sreac['bkw'].A", "val = sim.TRIS(triLst).sreac['fwd'].A", "val = sim.TRIS(triLst).sreac['bkw'].A"], "@doc": "<p> Returns the propensity of surface reaction with identifier string sreac in triangular element tri.</p>"}}, "Diffusion": {"D": {"@code": ["dcst = sim.TRI(tri).sdiff.D", "dcst = sim.TRI(tri).sdiff(direc=tri2).D", "dcst = sim.TRIS(triLst).sdiff.D"], "@doc": "<p> Returns the diffusion constant of diffusion rule with identifier string diff in triangle element tri. If direc is specified, return the diffusion constant towards that direction.</p>"}}, "Current": {"I": {"@code": ["val = sim.TRI(tri).curr.I", "val = sim.TRIS(triLst).curr.I"], "@doc": "<p> Returns the ohmic or GHK current with string identifier curr of triangle element tri, in amps.</p>"}}, "Area": {"@code": ["val = sim.TRI(tri).Area", "val = sim.TRIS(triLst).Area"], "@doc": "<p> Returns the area (in m^2) of the triangular element tri.</p>"}, "V": {"@code": ["val = sim.TRI(tri).V", "val = sim.TRIS(triLst).V"], "@doc": "<p> Returns the potential (in volts) of triangle element tri, taken at the barycenter.</p>"}, "VClamped": {"@code": ["clamped = sim.TRI(tri).VClamped", "clamped = sim.TRIS(triLst).VClamped"], "@doc": "<p> Returns true if the potential of triangle element tri is clamped to some voltage.</p>"}, "IClamp": {"@code": ["val = sim.TRI(tri).IClamp", "val = sim.TRIS(triLst).IClamp"], "@doc": "<p> Get current clamp to triangle element tri. NOTE: Convention is maintained that a positive current clamp is depolarizing, a negative current clamp is hyperpolarizing.</p>"}, "I": {"@code": ["val = sim.TRI(tri).I", "val = sim.TRIS(triLst).I"], "@doc": "<p> Returns the current of triangle element tri, in amps, at the last EField calculation step.</p>"}}, "Membrane": {"Res": {"@code": ["ro, vrev = sim.memb.Res"], "@doc": "<p> Gets the surface electrical resistivity (ro) in ohm.m^2 of the membrane with string identifier memb, and the reversal potential (vrev) in Volts.</p>"}}, "Vertex": {"V": {"@code": ["val = sim.VERT(vert).V", "val = sim.VERTS(vertLst).V"], "@doc": "<p> Returns the potential (in volts) of vertex element vert.</p>"}, "VClamped": {"@code": ["clamped = sim.VERT(vert).VClamped", "clamped = sim.VERTS(vertLst).VClamped"], "@doc": "<p> Returns true if the potential of vertex element vert is clamped to some voltage.</p>"}, "IClamp": {"@code": ["val = sim.VERT(vert).IClamp", "val = sim.VERTS(vertLst).IClamp"], "@doc": "<p> Get current clamp to vertex element with index vidx (Amps). NOTE: Convention is maintained that a positive current clamp is depolarizing, a negative current clamp is hyperpolarizing.</p>"}}}, "TetOpSplit": {"Compartment": {"Species": {"Count": {"@code": ["cnt = sim.comp.spec.Count"], "@doc": "<p> Returns the number of molecules of a species with identifier string spec in compartment with identifier string comp.</p><p>In a mesh-based simulation this is the combined count from all tetrahedral elements in the compartment.</p>"}, "Conc": {"@code": ["conc = sim.comp.spec.Conc"], "@doc": "<p> Returns the concentration (in Molar units) of species with identifier string spec in compartment with identifier string comp.</p><p>Note: in a mesh-based simulation this is calculated from the combined number of molecules from all tetrahedral elements in the compartment and the total volume of the tetrahedrons.</p>"}, "Amount": {"@code": ["val = sim.comp.spec.Amount"], "@doc": "<p> Returns the amount (in mols) of species with identifier string spec in compartment with identifier string comp.</p><p>In a mesh-based simulation this is the combined amount from all tetrahedral elements in the compartment.</p>"}, "Clamped": {"@code": ["clamped = sim.comp.spec.Clamped"], "@doc": "<p> Returns True if species with identifier string spec in compartment with identifier string comp is clamped, which means the concentration remains the same regardless of reactions that consume or produce molecules of this species. Returns False if not.</p><p>Note: in a mesh-based simulation it returns True only if the species is clamped in all tetrahedral elements of the compartment.</p>"}}, "Reaction": {"K": {"@code": ["val = sim.comp.reac['fwd'].K", "val = sim.comp.reac['bkw'].K"], "@doc": "<p> Returns the macroscopic reaction constant of reaction with identifier string reac in compartment with identifier string comp. The unit of the reaction constant depends on the order of the reaction.</p><p>Note: In a mesh-based simulation the value for the compartment is returned, although individual tetrahedral elements may have different values (set with setTetReacK).</p>"}, "Active": {"@code": ["active = sim.comp.reac['fwd'].Active", "active = sim.comp.reac['bkw'].Active"], "@doc": "<p> Returns whether a reaction with identifier string reac in compartment with identifier string comp is active (True) or not (False). If it's not active this means that a reaction will never occur regardless of whether the reactants are present in sufficient numbers or not.</p><p>Note: In a mesh-based simulation this method will return True only if the reaction is active in all tetrahedral elements in the compartment.</p>"}, "C": {"@code": ["val = sim.comp.reac['fwd'].C", "val = sim.comp.reac['bkw'].C"], "@doc": "<p> Returns the 'stochastic reaction constant' (or 'specific probability rate constant') of reaction with identifier string reac in compartment with identifier string comp.</p><p>The 'stochastic reaction constant' multiplied by infinitesimal time interval dt gives the average probability that one reaction channel of this reaction type will react accordingly in dt.</p><p>Note: in a mesh-based simulation (i.e. Tetexact), the stochastic reaction constant is computed as the weighted mean of the stochastic reaction constants in all tetrahedral elements of the compartment.</p>"}, "H": {"@code": ["val = sim.comp.reac['fwd'].H", "val = sim.comp.reac['bkw'].H"], "@doc": "<p> Returns h_mu, the distinct number of ways in which reaction with identifier string reac can occur in compartment with identifier string comp, by computing the product of its reactants. Note: in a mesh-based simulation (i.e. Tetexact), returns the sum of the h_mu's over all tetrahedral elements in the compartment.</p>"}, "A": {"@code": ["val = sim.comp.reac['fwd'].A", "val = sim.comp.reac['bkw'].A"], "@doc": "<p> Returns the propensity of reaction with identifier string reac in compartment with identifier string comp.</p><p>The propensity of a reaction is a function of state and is defined as the function whose product with infinitesimal time dt gives the probability that the reaction will occur in the next dt. It is the 'stochastic reaction constant' multiplied by 'h_mu'.</p><p>Note: in a mesh-based simulation (i.e. Tetexact), the propensity of a reaction in a compartment is computed as the sum of the propensities in all tetrahedral elements of the compartment.</p>"}, "Extent": {"@code": ["val = sim.comp.reac['fwd'].Extent", "val = sim.comp.reac['bkw'].Extent"], "@doc": "<p> Return the extent of reaction with identifier string reac in compartment with identifier string comp, that is the number of times the reaction has occurred up to the current simulation time.</p><p>Note: in a mesh-based simulation (i.e. Tetexact), returns the sum of the reaction extents in all tetrahedral elements of the compartment.</p>"}}, "Diffusion": {"Active": {"@code": ["active = sim.comp.diff.Active"], "@doc": "<p> Returns whether a diffusion rule with identifier string diff in compartment with identifier string comp is active (True) or not (False). If diffusion of a species is inactive this means the molecules will remain in place and has the same effect as a diffusion constant of zero.</p>"}, "D": {"@code": ["dcst = sim.comp.diff.D"], "@doc": "<p> Returns the diffusion constant of diffusion rule with identifier string diff in compartment with identifier string comp. This constant is in units m^2/s.</p><p>Note: In a mesh-based solver the value for the compartment is returned, although individual or groups of tetrahedral elements may have different values (set with setTetDiffD).</p>"}}, "Vol": {"@code": ["val = sim.comp.Vol"], "@doc": "<p> Returns the volume of compartment with identifier string comp (in m^3).</p>"}}, "Patch": {"Species": {"Count": {"@code": ["cnt = sim.patch.spec.Count"], "@doc": "<p> Returns the number of molecules of species with identifier string spec in patch with identifier string patch.Note: in a mesh-based simulation this is the combined count from all triangular elements in the patch.</p>"}, "Amount": {"@code": ["val = sim.patch.spec.Amount"], "@doc": "<p> Returns the amount (in mols) of species with identifier string spec in patch with identifier string patch.</p><p>Note: in a mesh-based simulation this is the combined amount from all triangular elements in the patch.</p>"}, "Clamped": {"@code": ["clamped = sim.patch.spec.Clamped"], "@doc": "<p> Gets whether the species with identifier string spec in patch with identifier string patch is clamped (clamped = True) or not (clamped = False). If a species is clamped the number of molecules stays the same regardless of surface reactions that consume or produce molecules of the species.</p><p>Note: in a mesh-based simulation this will return whether all of the triangles of the patch have this species clamped.</p>"}}, "Reaction": {"K": {"@code": ["val = sim.patch.sreac['fwd'].K", "val = sim.patch.sreac['bkw'].K"], "@doc": "<p> Returns the macroscopic reaction constant of surface reaction with identifier string sreac in patch with identifier string patch. The unit of the reaction constant depends on the order of the reaction.</p><p>Note: In a mesh-based solver the value for the patch is returned, although individual triangle elements may have different values (set with setTriSReacK).</p>"}, "Active": {"@code": ["active = sim.patch.sreac['fwd'].Active", "active = sim.patch.sreac['bkw'].Active"], "@doc": "<p> Returns whether a surface reaction with identifier string sreac in patch with identifier string patch is active (True) or not (False). If it's not active this means that a surface reaction will never occur regardless of whether the reactants are present in sufficient numbers or not.</p><p>Note: In a mesh-based simulation this method will return True only if the surface reaction is active in all triangular elements in the patch.</p>"}, "C": {"@code": ["val = sim.patch.sreac['fwd'].C", "val = sim.patch.sreac['bkw'].C"], "@doc": "<p> Returns the 'stochastic reaction constant' (or 'specific probability rate constant') of surface reaction with identifier string sreac in patch with identifier string patch.</p><p>Note: in a mesh-based simulation (i.e. Tetexact), the stochastic reaction constant is computed as the weighted mean of the stochastic reaction constants in all triangular elements of the patch.</p>"}, "H": {"@code": ["val = sim.patch.sreac['fwd'].H", "val = sim.patch.sreac['bkw'].H"], "@doc": "<p> Returns h_mu, the distinct number of ways in which surface reaction with identifier string sreac can occur in patch with identifier string patch, by computing the product of its reactants. Note: in a mesh-based simulation (i.e. Tetexact), returns the sum of the h_mu's over all triangular elements in the patch.</p>"}, "A": {"@code": ["val = sim.patch.sreac['fwd'].A", "val = sim.patch.sreac['bkw'].A"], "@doc": "<p> Returns the propensity of surface reaction with identifier string sreac in patch with identifier string patch. Note: in a mesh-based simulation (i.e. Tetexact), the propensity of a surface reaction in a patch is computed as the sum of the propensities in all triangular elements of the patch.</p>"}, "Extent": {"@code": ["val = sim.patch.sreac['fwd'].Extent", "val = sim.patch.sreac['bkw'].Extent"], "@doc": "<p> Returns the extent of surface reaction with identifier string sreac in patch with identifier string patch, that is the number of times the surface reaction has occurred up to the current simulation time.</p><p>Note: in a mesh-based simulation (i.e. Tetexact), returns the sum of the reaction extents in all triangular elements of the patch.</p>"}}, "Area": {"@code": ["val = sim.patch.Area"], "@doc": "<p> Returns the area of patch with identifier string patch (in m^2).</p>"}}, "Diff. Boundary": {"Species": {"DiffusionActive": {"@code": ["val = sim.diffb.spec.DiffusionActive"], "@doc": "<p> Returns whether diffusion is active across a diffusion boundary for a species.</p>"}}}, "Surf. Diff. Boundary": {"Species": {"DiffusionActive": {"@code": ["val = sim.sdiffb.spec.DiffusionActive"], "@doc": "<p> Returns whether diffusion is active across a surface diffusion boundary for a species.</p>"}}}, "Region of Interest": {"Species": {"Count": {"@code": ["cnt = sim.roi.spec.Count"], "@doc": "<p> Get the count of a species in a ROI.</p>"}, "Conc": {"@code": ["conc = sim.roi.spec.Conc"], "@doc": "<p> Get the concentration of a species in a ROI.</p>"}, "Amount": {"@code": ["val = sim.roi.spec.Amount"], "@doc": "<p> Get the amount of a species in a ROI.</p>"}}, "Reaction": {"Extent": {"@code": ["val = sim.roi.reac['fwd'].Extent", "val = sim.roi.reac['bkw'].Extent"], "@doc": "<p> Return the extent of reaction with identifier string reac in ROI with identifier string roi, that is the number of times the reaction has occurred up to the current simulation time.</p>"}}, "Diffusion": {"Extent": {"@code": ["val = sim.roi.diff.Extent"], "@doc": "<p> Return the extent of diffusion with identifier string diff in ROI with identifier string roi, that is the number of times the diffusion has occurred up to the current simulation time.</p>"}}, "Area": {"@code": ["val = sim.roi.Area"], "@doc": "<p> Get the area of a ROI.</p>"}, "Vol": {"@code": ["val = sim.roi.Vol"], "@doc": "<p> Get the volume of a ROI.</p>"}}, "Tetrahedron": {"Species": {"Count": {"@code": ["cnt = sim.TET(tet).spec.Count", "cnt = sim.TETS(tetLst).spec.Count"], "@doc": "<p> Returns the number of molecules of species with identifier string spec in the tetrahedral element tet.</p>"}, "Conc": {"@code": ["conc = sim.TET(tet).spec.Conc", "conc = sim.TETS(tetLst).spec.Conc"], "@doc": "<p> Returns the concentration (in Molar units) of species with identifier string spec in a tetrahedral element tet.</p>"}, "Amount": {"@code": ["val = sim.TET(tet).spec.Amount", "val = sim.TETS(tetLst).spec.Amount"], "@doc": "<p> Returns the amount (in mols) of species with identifier string spec in tetrahedral element tet.</p>"}, "Clamped": {"@code": ["clamped = sim.TET(tet).spec.Clamped", "clamped = sim.TETS(tetLst).spec.Clamped"], "@doc": "<p> Returns True if concentration of species with identifier string spec in tetrahedral element tet is clamped, which means the concentration stays the same regardless of reactions that consume or produce molecules of this species or diffusion of this species into or out of the tetrahedral element. Returns False if not.</p>"}}, "Reaction": {"K": {"@code": ["val = sim.TET(tet).reac['fwd'].K", "val = sim.TET(tet).reac['bkw'].K", "val = sim.TETS(tetLst).reac['fwd'].K", "val = sim.TETS(tetLst).reac['bkw'].K"], "@doc": "<p> Returns the macroscopic reaction constant of reaction with identifier string reac in tetrahedral element tet. The unit of the reaction constant depends on the order of the reaction.</p>"}, "Active": {"@code": ["active = sim.TET(tet).reac['fwd'].Active", "active = sim.TET(tet).reac['bkw'].Active", "active = sim.TETS(tetLst).reac['fwd'].Active", "active = sim.TETS(tetLst).reac['bkw'].Active"], "@doc": "<p> Returns whether reaction with identifier string reac in tetrahedral element tet is active (True) or not (False). If it's not active this means that the reaction will never occur regardless of whether reactants are present in sufficient numbers or not.</p>"}, "C": {"@code": ["val = sim.TET(tet).reac['fwd'].C", "val = sim.TET(tet).reac['bkw'].C", "val = sim.TETS(tetLst).reac['fwd'].C", "val = sim.TETS(tetLst).reac['bkw'].C"], "@doc": "<p> Returns the 'stochastic reaction constant' (or 'specific probability rate constant') of reaction with identifier string reac in tetrahedral element tet.</p>"}, "H": {"@code": ["val = sim.TET(tet).reac['fwd'].H", "val = sim.TET(tet).reac['bkw'].H", "val = sim.TETS(tetLst).reac['fwd'].H", "val = sim.TETS(tetLst).reac['bkw'].H"], "@doc": "<p> Returns h_mu, the distinct number of ways in which reaction with identifier string reac can occur in tetrahedral element tet, by computing the product of its reactants.</p>"}, "A": {"@code": ["val = sim.TET(tet).reac['fwd'].A", "val = sim.TET(tet).reac['bkw'].A", "val = sim.TETS(tetLst).reac['fwd'].A", "val = sim.TETS(tetLst).reac['bkw'].A"], "@doc": "<p> Returns the propensity of reaction with identifier string reac in tetrahedral element tet.</p>"}}, "Diffusion": {"Active": {"@code": ["active = sim.TET(tet).diff.Active", "active = sim.TETS(tetLst).diff.Active"], "@doc": "<p> Returns whether diffusion with identifier string diff in tetrahedral element tet is active (True) or not (False). If diffusion of a species is inactive this means the molecules will never diffuse out of the tetrahedron and has the same effect as a diffusion constant of zero.</p>"}, "D": {"@code": ["dcst = sim.TET(tet).diff.D", "dcst = sim.TET(tet).diff(direc=tet2).D", "dcst = sim.TETS(tetLst).diff.D"], "@doc": "<p> Returns the diffusion constant of diffusion rule with identifier string diff in tetrahedral element tet. This constant is in units m^2/s. If direc is specified, return the diffusion constant towards that direction.</p>"}, "A": {"@code": ["val = sim.TET(tet).diff.A", "val = sim.TETS(tetLst).diff.A"], "@doc": "<p> Returns the propensity of diffusion rule with identifier string diff in tetrahedral element tet.</p>"}}, "Vol": {"@code": ["val = sim.TET(tet).Vol", "val = sim.TETS(tetLst).Vol"], "@doc": "<p> Returns the volume (in m^3) of the tetrahedral element tet.</p>"}, "V": {"@code": ["val = sim.TET(tet).V", "val = sim.TETS(tetLst).V"], "@doc": "<p> Returns the potential (in volts) of tetrahedral element tet, taken at the barycenter.</p>"}, "VClamped": {"@code": ["clamped = sim.TET(tet).VClamped", "clamped = sim.TETS(tetLst).VClamped"], "@doc": "<p> Returns true if the potential of tetrahedral element tet is clamped to some voltage.</p>"}}, "Triangle": {"Species": {"Count": {"@code": ["cnt = sim.TRI(tri).spec.Count", "cnt = sim.TRIS(triLst).spec.Count"], "@doc": "<p> Returns the number of molecules of species with identifier string spec in the triangular element tri.</p>"}, "Amount": {"@code": ["val = sim.TRI(tri).spec.Amount", "val = sim.TRIS(triLst).spec.Amount"], "@doc": "<p> Returns the amount (in mols) of species with identifier string spec in triangular element tri.</p>"}, "Clamped": {"@code": ["clamped = sim.TRI(tri).spec.Clamped", "clamped = sim.TRIS(triLst).spec.Clamped"], "@doc": "<p> Returns True if the species with identifier string spec in triangular element tri is clamped, which means the number of molecules stays the same regardless of reactions that consume or produce molecules of this species. Returns False if not.</p>"}}, "Reaction": {"K": {"@code": ["val = sim.TRI(tri).sreac['fwd'].K", "val = sim.TRI(tri).sreac['bkw'].K", "val = sim.TRIS(triLst).sreac['fwd'].K", "val = sim.TRIS(triLst).sreac['bkw'].K"], "@doc": "<p> Returns the macroscopic reaction constant of surface reaction with identifier string sreac in triangular element tri. The units of the reaction constant depends on the order of the reaction.</p>"}, "Active": {"@code": ["active = sim.TRI(tri).sreac['fwd'].Active", "active = sim.TRI(tri).sreac['bkw'].Active", "active = sim.TRIS(triLst).sreac['fwd'].Active", "active = sim.TRIS(triLst).sreac['bkw'].Active"], "@doc": "<p> Returns whether surface reaction with identifier string sreac in triangular element tri is active (True) or not (False). If it's not active this means that the surface reaction will never occur regardless of whether reactants are present in sufficient numbers or not.</p>"}, "C": {"@code": ["val = sim.TRI(tri).sreac['fwd'].C", "val = sim.TRI(tri).sreac['bkw'].C", "val = sim.TRIS(triLst).sreac['fwd'].C", "val = sim.TRIS(triLst).sreac['bkw'].C"], "@doc": "<p> Returns the 'stochastic reaction constant' (or 'specific probability rate constant') of surface reaction with identifier string sreac in triangular element tri.</p>"}, "H": {"@code": ["val = sim.TRI(tri).sreac['fwd'].H", "val = sim.TRI(tri).sreac['bkw'].H", "val = sim.TRIS(triLst).sreac['fwd'].H", "val = sim.TRIS(triLst).sreac['bkw'].H"], "@doc": "<p> Returns h_mu, the distinct number of ways in which surface reaction with identifier string sreac can occur in triangular element tri, by computing the product of its reactants.</p>"}, "A": {"@code": ["val = sim.TRI(tri).sreac['fwd'].A", "val = sim.TRI(tri).sreac['bkw'].A", "val = sim.TRIS(triLst).sreac['fwd'].A", "val = sim.TRIS(triLst).sreac['bkw'].A"], "@doc": "<p> Returns the propensity of surface reaction with identifier string sreac in triangular element tri.</p>"}}, "Diffusion": {"D": {"@code": ["dcst = sim.TRI(tri).sdiff.D", "dcst = sim.TRI(tri).sdiff(direc=tri2).D", "dcst = sim.TRIS(triLst).sdiff.D"], "@doc": "<p> Returns the diffusion constant of diffusion rule with identifier string diff in triangle element tri. If direc is specified, return the diffusion constant towards that direction.</p>"}}, "Current": {"I": {"@code": ["val = sim.TRI(tri).curr.I", "val = sim.TRIS(triLst).curr.I"], "@doc": "<p> Returns the ohmic or GHK current with string identifier curr of triangle element tri, in amps.</p>"}}, "Area": {"@code": ["val = sim.TRI(tri).Area", "val = sim.TRIS(triLst).Area"], "@doc": "<p> Returns the area (in m^2) of the triangular element tri.</p>"}, "V": {"@code": ["val = sim.TRI(tri).V", "val = sim.TRIS(triLst).V"], "@doc": "<p> Returns the potential (in volts) of triangle element tri, taken at the barycenter.</p>"}, "VClamped": {"@code": ["clamped = sim.TRI(tri).VClamped", "clamped = sim.TRIS(triLst).VClamped"], "@doc": "<p> Returns true if the potential of triangle element tri is clamped to some voltage.</p>"}, "IClamp": {"@code": ["val = sim.TRI(tri).IClamp", "val = sim.TRIS(triLst).IClamp"], "@doc": "<p> Get current clamp to triangle element tri. NOTE: Convention is maintained that a positive current clamp is depolarizing, a negative current clamp is hyperpolarizing.</p>"}, "I": {"@code": ["val = sim.TRI(tri).I", "val = sim.TRIS(triLst).I"], "@doc": "<p> Returns the current of triangle element tri, in amps, at the last EField calculation step.</p>"}}, "Membrane": {"Res": {"@code": ["ro, vrev = sim.memb.Res"], "@doc": "<p> Gets the surface electrical resistivity (ro) in ohm.m^2 of the membrane with string identifier memb, and the reversal potential (vrev) in Volts.</p>"}}, "Vertex": {"V": {"@code": ["val = sim.VERT(vert).V", "val = sim.VERTS(vertLst).V"], "@doc": "<p> Returns the potential (in volts) of vertex element vert.</p>"}, "VClamped": {"@code": ["clamped = sim.VERT(vert).VClamped", "clamped = sim.VERTS(vertLst).VClamped"], "@doc": "<p> Returns true if the potential of vertex element vert is clamped to some voltage.</p>"}, "IClamp": {"@code": ["val = sim.VERT(vert).IClamp", "val = sim.VERTS(vertLst).IClamp"], "@doc": "<p> Get current clamp to vertex element with index vidx (Amps). NOTE: Convention is maintained that a positive current clamp is depolarizing, a negative current clamp is hyperpolarizing.</p>"}}}, "TetVesicle": {"Compartment": {"Species": {"Count": {"@code": ["cnt = sim.comp.spec.Count"], "@doc": "<p> Returns the number of molecules of species s in compartment c. NOTE: in a mesh-based simulation, the total count is computed as the sum of the counts in all tetrahedrons of the compartment.</p><p>:param c: Name of the compartment. :type c: str :param s: Name of the species. :type s: str</p><p> :rtype: float</p>"}, "Conc": {"@code": ["conc = sim.comp.spec.Conc"], "@doc": "<p> Returns the concentration (in molar units) of species s in compartment c. NOTE: in a mesh-based simulation, the overall concentration in a compartment is computed by taking the volume-weighted sum of the concentration in all tetrahedrons of the compartment.</p><p>:param c: Name of the compartment. :type c: str :param s: Name of the species. :type s: str</p><p> :rtype: float</p>"}, "Amount": {"@code": ["val = sim.comp.spec.Amount"], "@doc": "<p> Returns the amount (in mols) of species s in compartment c. NOTE: in a mesh-based simulation, the total amount is computed as the sum of the amounts in all tetrahedrons of the compartment.</p><p>:param c: Name of the compartment. :type c: str :param s: Name of the species. :type s: str</p><p> :rtype: float</p>"}, "Clamped": {"@code": ["clamped = sim.comp.spec.Clamped"], "@doc": "<p> Returns whether the concentration of species s in compartment c remains constant over time (unless changed explicitly). NOTE: in a mesh-based simulation, this method will only return true only if the species has been clamped in all tetrahedrons of the compartment. \\param c Name of the compartment. \\param s Name of the species.</p><p>:param c: :type c: str :param s: :type s: str</p><p> :rtype: bool</p>"}}, "Reaction": {"K": {"@code": ["val = sim.comp.reac['fwd'].K", "val = sim.comp.reac['bkw'].K"], "@doc": "<p> Returns the macroscopic reaction constant of reaction r in compartment c. Note: in a mesh-based simulation, the value is computed as the volume-weighted sum of the reaction constants in all tetrahedrons of the compartment.</p><p>:param c: :type c: str :param r: :type r: str</p><p> :rtype: float</p>"}, "Active": {"@code": ["active = sim.comp.reac['fwd'].Active", "active = sim.comp.reac['bkw'].Active"], "@doc": "<p> Returns whether reaction r in compartment c is active or not NOTE: in a mesh-based simulation, this method returns false only when the reaction has been inactivated in all tetrahedrons.</p><p>:param c: Name of the compartment. :type c: str :param r: Name of the reaction. :type r: str</p><p> :rtype: bool</p>"}, "C": {"@code": ["val = sim.comp.reac['fwd'].C", "val = sim.comp.reac['bkw'].C"], "@doc": "<p> Returns c_mu, the mesoscopic reaction constant of reaction r in compartment c. NOTE: in a mesh-based simulation, the mesoscopic reaction constant is computed as the sum of the mesoscopic constants in all tetrahedrons of the compartment.</p><p>:param c: Name of the compartment. :type c: str :param r: Name of the reaction. :type r: str</p><p> :rtype: float</p>"}, "H": {"@code": ["val = sim.comp.reac['fwd'].H", "val = sim.comp.reac['bkw'].H"], "@doc": "<p> Returns h_mu, the distinct number of ways in which reaction r can occur in compartment c, by computing the product of its reactants. NOTE: in a mesh-based simulation, it returns the sum of the h_mu's over all tetrahedrons of the compartment. This can become a very large value.</p><p>:param c: Name of the compartment. :type c: str :param r: Name of the reaction. :type r: str</p><p> :rtype: float</p>"}, "A": {"@code": ["val = sim.comp.reac['fwd'].A", "val = sim.comp.reac['bkw'].A"], "@doc": "<p> Returns the propensity, a_mu, of reaction r in compartment c. The propensity value gives the probability per unit time that this reaction will occur in the current state. NOTE: in a mesh-based simulation, a_mu is computed as the sum of the a_mu in all tetrahedrons of the compartment.</p><p>:param c: Name of the compartment. :type c: str :param r: Name of the reaction. :type r: str</p><p> :rtype: float</p>"}, "Extent": {"@code": ["val = sim.comp.reac['fwd'].Extent", "val = sim.comp.reac['bkw'].Extent"], "@doc": "<p> Returns the extent of reaction r in compartment c. NOTE: in a mesh-based simulation, returns the sum of the reaction extents in all tetrahedrons of the compartment.</p><p>:param c: Name of the compartment. :type c: str :param r: Name of the reaction. :type r: str</p><p> :rtype: unsigned long long</p>"}}, "Diffusion": {"Active": {"@code": ["active = sim.comp.diff.Active"], "@doc": "<p> Returns whether diffusion rule d in compartment c is active or not.</p><p>:param c: Name of the compartment. :type c: str :param d: Name of the diffusion. :type d: str</p><p> :rtype: bool</p>"}, "D": {"@code": ["dcst = sim.comp.diff.D"], "@doc": "<p> Returns the diffusion constant of diffusion rule d in compartment c.</p><p>:param c: Name of the compartment. :type c: str :param d: Name of the diffusion. :type d: str</p><p> :rtype: float</p>"}}, "Vesicle": {"Count": {"@code": ["cnt = sim.comp.ves.Count"], "@doc": "<p> Returns the number of vesicles v in compartment c</p><p>:param c: Name of the compartment. :type c: str :param v: Name of the vesicle. :type v: str</p><p> :rtype: int</p>"}}, "Vol": {"@code": ["val = sim.comp.Vol"], "@doc": "<p> Returns the volume of compartment c (in m^3).</p><p>:param c: Name of the compartment. :type c: str</p><p> :rtype: float</p>"}}, "Patch": {"Species": {"Count": {"@code": ["cnt = sim.patch.spec.Count"], "@doc": "<p> Returns the number of molecules of species s in patch p. NOTE: in a mesh-based simulation, the total count is computed as the sum of the counts in all triangles of the patch.</p><p>:param p: Name of the path. :type p: str :param s: Name of the species. :type s: str</p><p> :rtype: float</p>"}, "Amount": {"@code": ["val = sim.patch.spec.Amount"], "@doc": "<p> Returns the amount (in mols) of species s in patch p. NOTE: in a mesh-based simulation, the total amount is computed as the sum of the amounts in all triangles of the patch.</p><p>:param p: Name of the patch. :type p: str :param s: Name of the species. :type s: str</p><p> :rtype: float</p>"}, "Clamped": {"@code": ["clamped = sim.patch.spec.Clamped"], "@doc": "<p> Returns whether the count of species s in patch p remains constant. over time (unless changed explicitly). NOTE: this method will only return true if the species has been clamped in all triangles in the patch.</p><p>:param p: Name of the patch. :type p: str :param s: Name of the species. :type s: str</p><p> :rtype: bool</p>"}}, "Reaction": {"K": {"@code": ["val = sim.patch.sreac['fwd'].K", "val = sim.patch.sreac['bkw'].K"], "@doc": "<p> Returns the macroscopic reaction constant of surface reaction r in patch p. NOTE: in a mesh-based simulation, the value is computed as the area-weighted sum of the reaction constants in all triangles of the patch.</p><p>:param p: Name of the patch. :type p: str :param r: Name of the reaction. :type r: str</p><p> :rtype: float</p>"}, "Active": {"@code": ["active = sim.patch.sreac['fwd'].Active", "active = sim.patch.sreac['bkw'].Active"], "@doc": "<p> Returns whether surface reaction r in patch p is active or not. NOTE: in a mesh-based simulation, only returns false when the reaction has been inactivated in all triangles.</p><p>:param p: Name of the patch. :type p: str :param r: Name of the reaction. :type r: str</p><p> :rtype: bool</p>"}, "C": {"@code": ["val = sim.patch.sreac['fwd'].C", "val = sim.patch.sreac['bkw'].C"], "@doc": "<p> Returns c_mu, the mesoscopic reaction constant of surface reaction r in patch p. NOTE: in a mesh_based simulation, the mesoscopic reaction constant is computed as the sum of the mesoscopic reaction constants from all triangles of the patch.</p><p>:param p: Name of the patch. :type p: str :param r: Name of the reacton. :type r: str</p><p> :rtype: float</p>"}, "H": {"@code": ["val = sim.patch.sreac['fwd'].H", "val = sim.patch.sreac['bkw'].H"], "@doc": "<p> Returns h_mu, the distinct number of ways in which a surface reaction r can occur in patch p, by computing the product of its reactants. NOTE: in a mesh-based simulation, it returns the sum of the h_mu's over all triangles triangles of the patch.</p><p>:param p: Name of the patch. :type p: str :param r: Name of the reaction. :type r: str</p><p> :rtype: float</p>"}, "A": {"@code": ["val = sim.patch.sreac['fwd'].A", "val = sim.patch.sreac['bkw'].A"], "@doc": "<p> Returns the propensity, a_mu of surface reaction r in patch p. This propensity value gives the probability per unit time that this surface reaction will occur in the current state. NOTE: in a mesh-based simulation, a_mu is computed as the sum of the a_mu in all triangles in the patch.</p><p>:param p: Name of the patch. :type p: str :param r: Name of the reaction. :type r: str</p><p> :rtype: float</p>"}, "Extent": {"@code": ["val = sim.patch.sreac['fwd'].Extent", "val = sim.patch.sreac['bkw'].Extent"], "@doc": "<p> Returns the extent of surface reaction r in patch p. NOTE: in a mesh-based simulation, returns the sum of the extents in all triangles of the patch.</p><p>:param p: Name of the patch. :type p: str :param r: Name of the reaction. :type r: str</p><p> :rtype: unsigned long long</p>"}}, "Raft": {"Count": {"@code": ["cnt = sim.patch.raft.Count"], "@doc": "<p> Returns the number of rafts r in patch p</p><p>:param p: Name of the patch. :type p: str :param r: Name of the raft. :type r: str</p><p> :rtype: int</p>"}}, "Area": {"@code": ["val = sim.patch.Area"], "@doc": "<p> Returns the area of patch p (in m^2)</p><p>:param p: Name of the patch. :type p: str</p><p> :rtype: float</p>"}}, "Diff. Boundary": {"Species": {"DiffusionActive": {"@code": ["val = sim.diffb.spec.DiffusionActive"], "@doc": "<p> Returns whether diffusion is active across a diffusion boundary for a species.</p><p>:param db: Name of the diffusion boundary. :type db: str :param s: Name of the species. :type s: str</p><p> :rtype: bool</p>"}}}, "Surf. Diff. Boundary": {"Species": {"DiffusionActive": {"@code": ["val = sim.sdiffb.spec.DiffusionActive"], "@doc": "<p> Returns whether diffusion is active across a surface diffusion boundary for a species.</p><p>:param sdb: Name of the surface diffusion boundary. :type sdb: str :param s: Name of the species. :type s: str</p><p> :rtype: bool</p>"}}}, "Region of Interest": {"Species": {"Count": {"@code": ["cnt = sim.roi.spec.Count"], "@doc": "<p> Get the count of a species in a ROI.</p><p>:param roi: :type roi: str :param s: :type s: str</p><p> :rtype: float</p>"}, "Conc": {"@code": ["conc = sim.roi.spec.Conc"], "@doc": "<p> Get the concentration of a species in a ROI.</p><p>:param roi: :type roi: str :param s: :type s: str</p><p> :rtype: float</p>"}, "Amount": {"@code": ["val = sim.roi.spec.Amount"], "@doc": "<p> Get the amount of a species in a ROI.</p><p>:param roi: :type roi: str :param s: :type s: str</p><p> :rtype: float</p>"}}, "Reaction": {"Extent": {"@code": ["val = sim.roi.reac['fwd'].Extent", "val = sim.roi.reac['bkw'].Extent"], "@doc": "<p> Return the extent of reaction with identifier string reac in ROI with identifier string roi, that is the number of times the reaction has occurred up to the current simulation time.</p><p>:param roi: :type roi: str :param r: :type r: str</p><p> :rtype: unsigned long long</p>"}}, "Diffusion": {"Extent": {"@code": ["val = sim.roi.diff.Extent"], "@doc": "<p> Return the extent of diffusion with identifier string diff in ROI with identifier string roi, that is the number of times the diffusion has occurred up to the current simulation time.</p><p>:param roi: :type roi: str :param d: :type d: str</p><p> :rtype: unsigned long long</p>"}}, "Area": {"@code": ["val = sim.roi.Area"], "@doc": "<p> Get the area of a ROI.</p><p>:param roi: :type roi: str</p><p> :rtype: float</p>"}, "Vol": {"@code": ["val = sim.roi.Vol"], "@doc": "<p> Get the volume of a ROI.</p><p>:param roi: :type roi: str</p><p> :rtype: float</p>"}}, "Tetrahedron": {"Species": {"Count": {"@code": ["cnt = sim.TET(tet).spec.Count", "cnt = sim.TETS(tetLst).spec.Count"], "@doc": "<p> Returns the number of molecules of species s in a tetrahedron</p><p>:param idx: Index of the tetrahedron. :type idx: steps.index_t :param s: Name of the species. :type s: str</p><p> :rtype: float</p>"}, "Conc": {"@code": ["conc = sim.TET(tet).spec.Conc", "conc = sim.TETS(tetLst).spec.Conc"], "@doc": "<p> Returns the concentration (in molar units) of species s in a tetrahedron.</p><p>:param idx: Index of the tetrahedron. :type idx: steps.index_t :param s: Name of the species. :type s: str</p><p> :rtype: float</p>"}, "Amount": {"@code": ["val = sim.TET(tet).spec.Amount", "val = sim.TETS(tetLst).spec.Amount"], "@doc": "<p> Returns the amount (in mols) of species s in a tetrahedron.</p><p>:param idx: Index of the tetrahedron. :type idx: steps.index_t :param s: Name of the species. :type s: str</p><p> :rtype: float</p>"}, "Clamped": {"@code": ["clamped = sim.TET(tet).spec.Clamped", "clamped = sim.TETS(tetLst).spec.Clamped"], "@doc": "<p> Returns whether the concentration of species s in a tetrahedron remains constant over time (unless changed explicitly).</p><p>:param idx: Index of the tetrahedron. :type idx: steps.index_t :param s: Name of the species. :type s: str</p><p> :rtype: bool</p>"}}, "Reaction": {"K": {"@code": ["val = sim.TET(tet).reac['fwd'].K", "val = sim.TET(tet).reac['bkw'].K", "val = sim.TETS(tetLst).reac['fwd'].K", "val = sim.TETS(tetLst).reac['bkw'].K"], "@doc": "<p> Returns the macroscopic reaction constant of reaction r in a tetrahedron (units vary with order of reaction).</p><p>:param idx: Index of the tetrahedron. :type idx: steps.index_t :param r: Name of the reaction. :type r: str</p><p> :rtype: float</p>"}, "Active": {"@code": ["active = sim.TET(tet).reac['fwd'].Active", "active = sim.TET(tet).reac['bkw'].Active", "active = sim.TETS(tetLst).reac['fwd'].Active", "active = sim.TETS(tetLst).reac['bkw'].Active"], "@doc": "<p> Returns whether reaction r in a tetrahedron is active or not</p><p>:param idx: Index of the tetrahedron. :type idx: steps.index_t :param r: Name of the reaction. :type r: str</p><p> :rtype: bool</p>"}, "C": {"@code": ["val = sim.TET(tet).reac['fwd'].C", "val = sim.TET(tet).reac['bkw'].C", "val = sim.TETS(tetLst).reac['fwd'].C", "val = sim.TETS(tetLst).reac['bkw'].C"], "@doc": "<p> Returns c_mu, the mesoscopic reaction constant of reaction r in a tetrahedron</p><p>:param idx: Index of the diffusion. :type idx: steps.index_t :param r: Name of the reaction. :type r: str</p><p> :rtype: float</p>"}, "H": {"@code": ["val = sim.TET(tet).reac['fwd'].H", "val = sim.TET(tet).reac['bkw'].H", "val = sim.TETS(tetLst).reac['fwd'].H", "val = sim.TETS(tetLst).reac['bkw'].H"], "@doc": "<p> Returns h_mu, the distinct number of ways in which reaction r can occur in a tetrahedron, by computing the product of its reactants.</p><p>:param idx: Index of the tetrahedron. :type idx: steps.index_t :param r: :type r: str</p><p> :rtype: float</p>"}, "A": {"@code": ["val = sim.TET(tet).reac['fwd'].A", "val = sim.TET(tet).reac['bkw'].A", "val = sim.TETS(tetLst).reac['fwd'].A", "val = sim.TETS(tetLst).reac['bkw'].A"], "@doc": "<p> Returns the propensity, a_mu, of reaction r in a tetrahedron. The propensity value gives the probability per unit time that this reaction will occur in the current state.</p><p>:param idx: Index of the tetrahedron. :type idx: steps.index_t :param r: Name of the reaction. :type r: str</p><p> :rtype: float</p>"}}, "Diffusion": {"Active": {"@code": ["active = sim.TET(tet).diff.Active", "active = sim.TETS(tetLst).diff.Active"], "@doc": "<p> Returns whether diffusion rule d in a tetrahedron is active or not.</p><p>:param idx: Index of the tetrahedron. :type idx: steps.index_t :param d: Name of the diffusion. :type d: str</p><p> :rtype: bool</p>"}, "D": {"@code": ["dcst = sim.TET(tet).diff.D", "dcst = sim.TET(tet).diff(direc=tet2).D", "dcst = sim.TETS(tetLst).diff.D"], "@doc": "<p> Returns the diffusion constant of diffusion rule d in a tetrahedron.</p><p>:param idx: Index of the tetrahedron. :type idx: steps.index_t :param d: Name of the deffusion. :type d: str :param direc: Tetrahedron index which specifies diffusion direction. :type direc: steps.index_t</p><p> :rtype: float</p>"}, "A": {"@code": ["val = sim.TET(tet).diff.A", "val = sim.TETS(tetLst).diff.A"], "@doc": "<p> Returns the propensity, a_mu of diffusion rule d in a tetrahedron.</p><p>:param idx: Index of the tetrahedron. :type idx: steps.index_t :param d: Name of the diffusion. :type d: str</p><p> :rtype: float</p>"}}, "Vol": {"@code": ["val = sim.TET(tet).Vol", "val = sim.TETS(tetLst).Vol"], "@doc": "<p> Returns the volume of a tetrahedron (in m^3).</p><p>:param idx: Index of the tetrahedron. :type idx: steps.index_t</p><p> :rtype: float</p>"}, "V": {"@code": ["val = sim.TET(tet).V", "val = sim.TETS(tetLst).V"], "@doc": "<p> Returns the potential of tetrahedron in Volts.</p><p>:param idx: Index of the tetrahedron. :type idx: steps.index_t</p><p> :rtype: float</p>"}, "VClamped": {"@code": ["clamped = sim.TET(tet).VClamped", "clamped = sim.TETS(tetLst).VClamped"], "@doc": "<p> Returns whether the potential of tetrahedron is clamped over time (unless changed explicitly)</p><p>:param idx: Index of the tetrahedron :type idx: steps.index_t</p><p> :rtype: bool</p>"}}, "Triangle": {"Species": {"Count": {"@code": ["cnt = sim.TRI(tri).spec.Count", "cnt = sim.TRIS(triLst).spec.Count"], "@doc": "<p> Returns the number of molecules of species s in a triangle.</p><p>:param idx: Index of the triangle. :type idx: steps.index_t :param s: Name of the species. :type s: str</p><p> :rtype: float</p>"}, "Amount": {"@code": ["val = sim.TRI(tri).spec.Amount", "val = sim.TRIS(triLst).spec.Amount"], "@doc": "<p> Returns the amount (in mols) of species s in a triangle.</p><p>:param idx: Index of the triangle. :type idx: steps.index_t :param s: Name of the species. :type s: str</p><p> :rtype: float</p>"}, "Clamped": {"@code": ["clamped = sim.TRI(tri).spec.Clamped", "clamped = sim.TRIS(triLst).spec.Clamped"], "@doc": "<p> Returns whether the number of molecules of species s in a triangle remains constant over time (unless changed explicitly)</p><p>:param idx: Index of the triangle. :type idx: steps.index_t :param s: name of the species. :type s: str</p><p> :rtype: bool</p>"}}, "Reaction": {"K": {"@code": ["val = sim.TRI(tri).sreac['fwd'].K", "val = sim.TRI(tri).sreac['bkw'].K", "val = sim.TRIS(triLst).sreac['fwd'].K", "val = sim.TRIS(triLst).sreac['bkw'].K"], "@doc": "<p> Returns the macroscopic reaction constant of surface reaction r in a triangle (units vary with order of reaction).</p><p>:param idx: Index of the triangle. :type idx: steps.index_t :param r: name of the reaction. :type r: str</p><p> :rtype: float</p>"}, "Active": {"@code": ["active = sim.TRI(tri).sreac['fwd'].Active", "active = sim.TRI(tri).sreac['bkw'].Active", "active = sim.TRIS(triLst).sreac['fwd'].Active", "active = sim.TRIS(triLst).sreac['bkw'].Active"], "@doc": "<p> Returns whether surface reaction r in a triangle is active or not.</p><p>:param idx: Index of the triangle. :type idx: steps.index_t :param r: name of the reaction. :type r: str</p><p> :rtype: bool</p>"}, "C": {"@code": ["val = sim.TRI(tri).sreac['fwd'].C", "val = sim.TRI(tri).sreac['bkw'].C", "val = sim.TRIS(triLst).sreac['fwd'].C", "val = sim.TRIS(triLst).sreac['bkw'].C"], "@doc": "<p> Returns c_mu, the mesoscopic reaction constant of surface reaction r in a triangle.</p><p>:param idx: Index of the triangle. :type idx: steps.index_t :param r: name of the reaction. :type r: str</p><p> :rtype: float</p>"}, "H": {"@code": ["val = sim.TRI(tri).sreac['fwd'].H", "val = sim.TRI(tri).sreac['bkw'].H", "val = sim.TRIS(triLst).sreac['fwd'].H", "val = sim.TRIS(triLst).sreac['bkw'].H"], "@doc": "<p> Returns h_mu, the distinct number of ways in which surface reaction r can occur in a triangle, by computing the product of it's reactants.</p><p>:param idx: Index of the triangle. :type idx: steps.index_t :param r: name of the reaction. :type r: str</p><p> :rtype: float</p>"}, "A": {"@code": ["val = sim.TRI(tri).sreac['fwd'].A", "val = sim.TRI(tri).sreac['bkw'].A", "val = sim.TRIS(triLst).sreac['fwd'].A", "val = sim.TRIS(triLst).sreac['bkw'].A"], "@doc": "<p> Returns the propensity, a_mu, of surface reaction r in a triangle. The propensity value gives the probability per unit time that this surface reaction will occur in the current state.</p><p>:param idx: Index of the triangle. :type idx: steps.index_t :param r: name of the reaction. :type r: str</p><p> :rtype: float</p>"}}, "Diffusion": {"D": {"@code": ["dcst = sim.TRI(tri).diff.D", "dcst = sim.TRI(tri).diff(direc=tet2).D", "dcst = sim.TRIS(triLst).diff.D"], "@doc": "<p> outdate function</p><p>:param idx: :type idx: steps.index_t :param d: :type d: str :param direc: :type direc: int</p><p> :rtype: float</p>"}}, "Current": {"I": {"@code": ["val = sim.TRI(tri).curr.I", "val = sim.TRIS(triLst).curr.I"], "@doc": "<p> Returns the ohmic or GHK current with string identifier curr of triangle in amperes.</p><p>:param idx: Index of the triangle. :type idx: steps.index_t :param oc: name of the ohmic or GHK current with string identifier curr :type oc: str</p><p> :rtype: float</p>"}}, "Raft": {"Count": {"@code": ["cnt = sim.TRI(tri).raft.Count", "cnt = sim.TRIS(triLst).raft.Count"], "@doc": "<p> Returns the number of rafts in a triangle</p><p>:param idx: Index of the triangle. :type idx: steps.index_t :param r: Name of the raft. :type r: str</p><p> :rtype: int</p>"}}, "Exocytosis": {"Active": {"@code": ["active = sim.TRI(tri).exo.Active", "active = sim.TRIS(triLst).exo.Active"], "@doc": "<p> Returns whether exocytotic reaction in a triangle is active or not.</p><p>:param idx: Index of the triangle. :type idx: steps.index_t :param er: name of the exocytotic reaction. :type er: str</p><p> :rtype: bool</p>"}}, "Area": {"@code": ["val = sim.TRI(tri).Area", "val = sim.TRIS(triLst).Area"], "@doc": "<p> Returns the area of the triangle (in m^2).</p><p>:param idx: Index of the triangle. :type idx: steps.index_t</p><p> :rtype: float</p>"}, "V": {"@code": ["val = sim.TRI(tri).V", "val = sim.TRIS(triLst).V"], "@doc": "<p> Returns the potential of triangle in Volts.</p><p>:param idx: Index of the triangle. :type idx: steps.index_t</p><p> :rtype: float</p>"}, "VClamped": {"@code": ["clamped = sim.TRI(tri).VClamped", "clamped = sim.TRIS(triLst).VClamped"], "@doc": "<p> Returns whether the potential of triangle is clamped over time (unless changed explicitly).</p><p>:param idx: Index of the triangle :type idx: steps.index_t</p><p> :rtype: bool</p>"}, "IClamp": {"@code": ["val = sim.TRI(tri).IClamp", "val = sim.TRIS(triLst).IClamp"], "@doc": "<p> Gets current injection to triangle.</p><p>:param idx: Index of the triangle :type idx: steps.index_t</p><p> :rtype: float</p>"}, "I": {"@code": ["val = sim.TRI(tri).I", "val = sim.TRIS(triLst).I"], "@doc": "<p> Returns the current of a triangle in amperes from the last EField calculation step.</p><p>:param idx: Index of the triangle :type idx: steps.index_t</p><p> :rtype: float</p>"}}, "Vesicle": {"Reaction": {"Extent": {"@code": ["val = sim.ves.sreac['fwd'].Extent", "val = sim.ves.sreac['bkw'].Extent"], "@doc": "<p> Get the reaction extent of vesicle surface reaction. Not compartment-specific.</p><p>:param vsr: Name of the vesicle surface reaction :type vsr: str</p><p> :rtype: int</p>"}}, "Pos": {"@code": ["pos = sim.VESICLE(vesref).Pos", "pos = sim.VESICLES(vesLst).Pos"], "@doc": "<p> Returns the position of vesicle of type v with unique index ves_unique_index  (in cartesian coordinates)</p><p>:param v: Name of the vesicle. :type v: str :param ves_unique_index: Unique index of the individual vesicle :type ves_unique_index: steps.index_t</p><p> :rtype: List[float]</p>"}, "Immobility": {"@code": ["immob = sim.VESICLE(vesref).Immobility", "immob = sim.VESICLES(vesLst).Immobility"], "@doc": "<p> Get the 'immobility' of vesicle of type v and unique index ves_unique_index. All non-zero numbers mean vesicle is immobile.</p><p>:param v: Name of the vesicle. :type v: str :param ves_unique_index: Unique index of the individual vesicle :type ves_unique_index: steps.index_t</p><p> :rtype: int</p>"}}, "Vesicle surface": {"Species": {"Count": {"@code": ["cnt = sim.VESICLE(vesref)('surf').spec.Count", "cnt = sim.VESICLES(vesLst)('surf').spec.Count"], "@doc": "<p> Get the surface count of species s on vesicle of type v and unique index ves_unique_index.</p><p>:param v: Name of the vesicle. :type v: str :param ves_unique_index: Unique index of the individual vesicle :type ves_unique_index: steps.index_t :param s: Name of the species :type s: str</p><p> :rtype: int</p>"}, "Pos": {"@code": ["pos = sim.VESICLE(vesref)('surf').spec.Pos", "pos = sim.VESICLES(vesLst)('surf').spec.Pos"], "@doc": "<p> Get the cartesian coordinates of species s on vesicle of type v and unique index ves_unique_index. Position is absolute,</p><p>:param v: Name of the vesicle. :type v: str :param ves_unique_index: Unique index of the individual vesicle :type ves_unique_index: steps.index_t :param s: Name of the species :type s: str</p><p> :rtype: List[List[float]]</p>"}, "PosSpherical": {"@code": ["spos = sim.VESICLE(vesref)('surf').spec.PosSpherical", "spos = sim.VESICLES(vesLst)('surf').spec.PosSpherical"], "@doc": "<p> Get the spherical coordinates of species s on vesicle of type v and unique index ves_unique_index.</p><p>:param v: Name of the vesicle. :type v: str :param ves_unique_index: Unique index of the individual vesicle :type ves_unique_index: steps.index_t :param s: Name of the species :type s: str</p><p>:rtype: List[List[float]]</p>"}}, "Link Species": {"Count": {"@code": ["cnt = sim.VESICLE(vesref)('surf').linkspec.Count", "cnt = sim.VESICLES(vesLst)('surf').linkspec.Count"], "@doc": "<p> Returns the count of 'link' species ls on vesicle of type v with unique index vesicle_unique_index.</p><p>:param v: Name of the vesicle. :type v: str :param ves_unique_index: Unique index of the individual vesicle :type ves_unique_index: steps.index_t :param ls: Name of the link species :type ls: str</p><p> :rtype: int</p>"}, "Pos": {"@code": ["pos = sim.VESICLE(vesref)('surf').linkspec.Pos", "pos = sim.VESICLES(vesLst)('surf').linkspec.Pos"], "@doc": "<p> Returns the positions of 'link' species ls on vesicle of type v and unique index ves_unique_index.</p><p>:param v: Name of the vesicle. :type v: str :param ves_unique_index: Unique index of the individual vesicle :type ves_unique_index: steps.index_t :param ls: Name of the link species :type ls: str</p><p> :rtype: List[List[float]]</p>"}}}, "Vesicle inside": {"Species": {"Count": {"@code": ["cnt = sim.VESICLE(vesref)('in').spec.Count", "cnt = sim.VESICLES(vesLst)('in').spec.Count"], "@doc": "<p> Get the inner count of species s on vesicle of type v and unique index ves_unique_index.</p><p>:param v: Name of the vesicle. :type v: str :param ves_unique_index: Unique index of the individual vesicle :type ves_unique_index: steps.index_t :param s: Name of the species :type s: str</p><p> :rtype: int</p>"}}}, "Raft": {"Species": {"Count": {"@code": ["cnt = sim.RAFT(raftref).spec.Count", "cnt = sim.RAFTS(raftLst).spec.Count"], "@doc": "<p> Get the count of species s on raft of type r and unique index raft_unique_index.</p><p>:param r: Name of the raft. :type r: str :param raft_unique_index: Unique index of the individual raft. :type raft_unique_index: steps.index_t :param s: Name of the species :type s: str</p><p> :rtype: int</p>"}}, "Reaction": {"Active": {"@code": ["active = sim.RAFT(raftref).sreac['fwd'].Active", "active = sim.RAFT(raftref).sreac['bkw'].Active", "active = sim.RAFTS(raftLst).sreac['fwd'].Active", "active = sim.RAFTS(raftLst).sreac['bkw'].Active"], "@doc": "<p> Get whether raft surface reaction on a raft is active or not</p><p>:param r: Name of the raft. :type r: str :param raft_unique_index: Unique index of the individual raft. :type raft_unique_index: steps.index_t :param rsreac: Name of the raft surface reaction :type rsreac: str</p><p> :rtype: bool</p>"}}, "Raft Endocytosis": {"K": {"@code": ["val = sim.RAFT(raftref).rendo.K", "val = sim.RAFTS(raftLst).rendo.K"], "@doc": "<p> Get the raft endocytosis rate of a raft</p><p>:param r: Name of the raft. :type r: str :param raft_unique_index: Unique index of the individual raft. :type raft_unique_index: steps.index_t :param rendo: Name of the raft endocytosis :type rendo: str</p><p> :rtype: float</p>"}}, "Pos": {"@code": ["pos = sim.RAFT(raftref).Pos", "pos = sim.RAFTS(raftLst).Pos"], "@doc": "<p> Returns the position of raft of type r with unique index raft_unique_index (in cartesian coordinates)</p><p>:param r: Name of the raft. :type r: str :param raft_unique_index: Unique index of the individual raft. :type raft_unique_index: steps.index_t</p><p> :rtype: List[float]</p>"}, "Immobility": {"@code": ["immob = sim.RAFT(raftref).Immobility", "immob = sim.RAFTS(raftLst).Immobility"], "@doc": "<p> Get the 'immobility' of raft of type r and unique index raft_unique_index. All non-zero numbers mean raft is immobile.</p><p>:param r: Name of the raft. :type r: str :param raft_unique_index: Unique index of the individual raft. :type raft_unique_index: steps.index_t</p><p> :rtype: int</p>"}}, "Membrane": {"Res": {"@code": ["ro, vrev = sim.memb.Res"], "@doc": "<p> Gets the surface electrical resistivity (ro) in ohm.m^2 of the membrane with string identifier memb, and the reversal potential (vrev) in Volts.</p>"}}, "Vertex": {"V": {"@code": ["val = sim.VERT(vert).V", "val = sim.VERTS(vertLst).V"], "@doc": "<p> Returns the potential of vertex in Volts.</p><p>:param vidx: Index of the vertex. :type vidx: steps.index_t</p><p> :rtype: float</p>"}, "VClamped": {"@code": ["clamped = sim.VERT(vert).VClamped", "clamped = sim.VERTS(vertLst).VClamped"], "@doc": "<p> Returns whether the potential of vertex is clamped over time (unless changed explicitly).</p><p>:param vidx: Index of the vertex :type vidx: steps.index_t</p><p> :rtype: bool</p>"}, "IClamp": {"@code": ["val = sim.VERT(vert).IClamp", "val = sim.VERTS(vertLst).IClamp"], "@doc": "<p> Gets current injection to vertex.</p><p>:param vidx: Index of the vertex :type vidx: steps.index_t</p><p> :rtype: float</p>"}}, "Exocytosis": {"Events": {"@code": ["events = sim.exo.Events"], "@doc": "<p> Get the vesicle exocytosis events that happened since last call. Not compartment-specific.</p><p>Returns a list of tuple with each tuple containing: (time of event, individual index of vesicle, triangle index where the exocytosis happened, individual index of raft or None)</p><p>:param exo: Name of the vesicle exocytosis :type exo: str</p><p>:rtype: List[Tuple[float, steps.index_t, steps.index_t, steps.index_t]]</p>"}}, "Raft Endocytosis": {"Events": {"@code": ["events = sim.rendo.Events"], "@doc": "<p> Get the raft endocytosis events that happened since last call. Not patch-specific.</p><p>Returns a list of tuple with each tuple containing: (time of event, individual index of raft, triangle index where the endocytosis happened, individual index of vesicle)</p><p>:param rendo: Name of the raft endocytosis :type rendo: str</p><p>:rtype: List[Tuple[float, steps.index_t, steps.index_t, steps.index_t]]</p>"}}}, "DistTetOpSplit": {"Compartment": {"Species": {"Count": {"@code": ["cnt = sim.comp.spec.Count"], "@doc": "<p> Returns the number of molecules of a species with identifier string spec in compartment with identifier string comp.</p><p>In a mesh-based simulation this is the combined count from all tetrahedral elements in the compartment.</p>"}, "Conc": {"@code": ["conc = sim.comp.spec.Conc"], "@doc": "<p> Returns the concentration (in Molar units) of species with identifier string spec in compartment with identifier string comp.</p><p>Note: in a mesh-based simulation this is calculated from the combined number of molecules from all tetrahedral elements in the compartment and the total volume of the tetrahedrons.</p>"}}}, "Patch": {"Species": {"Count": {"@code": ["cnt = sim.patch.spec.Count"], "@doc": "<p> Returns the number of molecules of species with identifier string spec in patch with identifier string pat.Note: in a mesh-based simulation this is the combined count from all triangular elements in the patch.</p>"}}}, "Diff. Boundary": {"Species": {"DiffusionActive": {"@code": ["val = sim.diffb.spec.DiffusionActive"], "@doc": "<p> Returns whether diffusion is active across a diffusion boundary for a species.</p>"}}}, "Tetrahedron": {"Species": {"Count": {"@code": ["cnt = sim.TET(tet).spec.Count", "cnt = sim.TETS(tetLst).spec.Count"], "@doc": "<p> Returns the number of molecules of species with identifier string spec in the tetrahedral element tet.</p>"}, "Conc": {"@code": ["conc = sim.TET(tet).spec.Conc", "conc = sim.TETS(tetLst).spec.Conc"], "@doc": "<p> Returns the concentration (in Molar units) of species with identifier string spec in a tetrahedral element tet.</p>"}}, "V": {"@code": ["val = sim.TET(tet).V", "val = sim.TETS(tetLst).V"], "@doc": "<p> Returns the potential (in volts) of tetrahdron element tet.</p>"}}, "Triangle": {"Species": {"Count": {"@code": ["cnt = sim.TRI(tri).spec.Count", "cnt = sim.TRIS(triLst).spec.Count"], "@doc": "<p> Returns the number of molecules of species with identifier string spec in the triangular element tri.</p>"}}, "Current": {"I": {"@code": ["val = sim.TRI(tri).curr.I", "val = sim.TRIS(triLst).curr.I"], "@doc": "<p> Returns the ohmic or GHK current with string identifier curr of triangle element tri, in amps.</p>"}}, "V": {"@code": ["val = sim.TRI(tri).V", "val = sim.TRIS(triLst).V"], "@doc": "<p> Returns the potential (in volts) of triangle element tri.</p>"}}, "Membrane": {"Res": {"@code": ["ro, vrev = sim.memb.Res"], "@doc": "<p> Gets the resistance and the reversal potential of the membrane with string identifier membrane.</p>"}}, "Vertex": {"V": {"@code": ["val = sim.VERT(vert).V", "val = sim.VERTS(vertLst).V"], "@doc": "<p> Returns the potential (in volts) of vertex element vert.</p>"}, "IClamp": {"@code": ["val = sim.VERT(vert).IClamp", "val = sim.VERTS(vertLst).IClamp"], "@doc": "<p> Returns the current clamp on the vertex vert, in ampere. NOTE: Convention is maintained that a positive current clamp is depolarizing, a negative current clamp is hyperpolarizing.</p>"}}}}, "set": {"Wmdirect": {"Compartment": {"Species": {"Count": {"@code": ["sim.comp.spec.Count = n"], "@doc": "<p> Set the number of molecules of a species with identifier string spec in compartment with identifier string comp.</p><p>In a mesh-based simulation this is the combined count from all tetrahedral elements in the compartment.</p>"}, "Conc": {"@code": ["sim.comp.spec.Conc = conc"], "@doc": "<p> Sets the concentration (in Molar units) of species with identifier string spec in compartment with identifier string comp to conc. In a discrete solver the continuous concentration is converted to a discrete number of molecules.</p><p>Note: in a mesh-based simulation the molecules are divided as equally as possible over all tetrahedral elements in the compartment (i.e. a uniform distribution).</p>"}, "Amount": {"@code": ["sim.comp.spec.Amount = a"], "@doc": "<p> Set the amount (in mols) of species with identifier string spec in compartment with identifier string comp.</p><p>In a mesh-based simulation this is the combined amount from all tetrahedral elements in the compartment.</p>"}, "Clamped": {"@code": ["sim.comp.spec.Clamped = clamped"], "@doc": "<p> Sets whether the concentration of species with identifier string spec in compartment with identifier string comp is clamped (clamped = True) or not (clamped = False). If a species is clamped the concentration stays the same regardless of reactions that consume or produce molecules of the species.</p><p>Note: in a mesh-based simulation this will set the species to be clamped or not in all tetrahedral elements of the compartment.</p>"}}, "Reaction": {"K": {"@code": ["sim.comp.reac['fwd'].K = kf", "sim.comp.reac['bkw'].K = kf"], "@doc": "<p> Sets the macroscopic reaction constant of reaction with identifier string reac in compartment with identifier string comp to kf. The unit of the reaction constant depends on the order of the reaction.</p><p>Note: In a mesh-based simulation this method sets the reaction constant in all tetrahedral elements of the compartment to kf</p><p>Note: The default value still comes from the steps.model description, so calling reset() will return the reaction constant to that value.</p>"}, "Active": {"@code": ["sim.comp.reac['fwd'].Active = active", "sim.comp.reac['bkw'].Active = active"], "@doc": "<p> Activate (active = True) or deactivate (active = False) a reaction with identifier string reac in compartment with identifier string comp. If a reaction is not active this means that a reaction will never occur regardless of whether the reactants are present in sufficient numbers or not.</p><p>Note: In a mesh-based simulation this will activate/deactivate the reaction in all tetrahedral elements in the compartment.</p>"}}, "Vol": {"@code": ["sim.comp.Vol = val"], "@doc": "<p> Set the volume of compartment with identifier string comp (in m^3).</p>"}}, "Patch": {"Species": {"Count": {"@code": ["sim.patch.spec.Count = n"], "@doc": "<p> Sets the number of molecules of species with identifier string spec in patch with identifier string patch to n. Note: in a mesh-based simulation the molecules are divided as equally as possible over all triangular elements in the patch (i.e. a uniform distribution).</p>"}, "Amount": {"@code": ["sim.patch.spec.Amount = a"], "@doc": "<p> Sets the amount (in mols) of species with identifier string spec in patch with identifier string patch to a. In a discrete solver, such as Wmdirect and Tetexact, this continuous value is converted internally into a discrete number of molecules by multiplication with Avogadro's number.</p><p>Note: in a mesh-based simulation the molecules are divided as equally as possible over all triangular elements in the patch (i.e. a uniform distribution).</p>"}, "Clamped": {"@code": ["sim.patch.spec.Clamped = clamped"], "@doc": "<p> Sets whether the species with identifier string spec in patch with identifier string patch is clamped (clamped = True) or not (clamped = False). If a species is clamped the number of molecules stays the same regardless of surface reactions that consume or produce molecules of the species.</p><p>Note: in a mesh-based simulation this will set the species to be clamped in all triangular elements of the patch.</p>"}}, "Reaction": {"K": {"@code": ["sim.patch.sreac['fwd'].K = kf", "sim.patch.sreac['bkw'].K = kf"], "@doc": "<p> Sets the macroscopic reaction constant of surface reaction with identifier string sreac in patch with identifier string patch to kf. The unit of the reaction constant depends on the order of the reaction.</p><p>Note: In a mesh-based simulation this method sets the surface reaction constant in all triangular elements of the patch to kf.</p><p>Note: The default value still comes from the steps.model description, so calling reset() will return the surface reaction constant to that value.</p>"}, "Active": {"@code": ["sim.patch.sreac['fwd'].Active = active", "sim.patch.sreac['bkw'].Active = active"], "@doc": "<p> Activate (active = True) or deactivate (active = False) a surface reaction with identifier string sreac in patch with identifier string patch. If a surface reaction is not active this means that a reaction will never occur regardless of whether the reactants are present in sufficient numbers or not.</p><p>Note: In a mesh-based simulation this will activate/ deactivate the reaction in all triangular elements in the patch.</p>"}}, "Area": {"@code": ["sim.patch.Area = val"], "@doc": "<p> Sets the area of patch with identifier string patch to area a (in m^2).</p>"}}}, "Wmrssa": {"Compartment": {"Species": {"Count": {"@code": ["sim.comp.spec.Count = n"], "@doc": "<p> Set the number of molecules of a species with identifier string spec in compartment with identifier string comp.</p><p>In a mesh-based simulation this is the combined count from all tetrahedral elements in the compartment.</p>"}, "Conc": {"@code": ["sim.comp.spec.Conc = conc"], "@doc": "<p> Sets the concentration (in Molar units) of species with identifier string spec in compartment with identifier string comp to conc. In a discrete solver the continuous concentration is converted to a discrete number of molecules.</p><p>Note: in a mesh-based simulation the molecules are divided as equally as possible over all tetrahedral elements in the compartment (i.e. a uniform distribution).</p>"}, "Amount": {"@code": ["sim.comp.spec.Amount = a"], "@doc": "<p> Set the amount (in mols) of species with identifier string spec in compartment with identifier string comp.</p><p>In a mesh-based simulation this is the combined amount from all tetrahedral elements in the compartment.</p>"}, "Clamped": {"@code": ["sim.comp.spec.Clamped = clamped"], "@doc": "<p> Sets whether the concentration of species with identifier string spec in compartment with identifier string comp is clamped (clamped = True) or not (clamped = False). If a species is clamped the concentration stays the same regardless of reactions that consume or produce molecules of the species.</p><p>Note: in a mesh-based simulation this will set the species to be clamped or not in all tetrahedral elements of the compartment.</p>"}}, "Reaction": {"K": {"@code": ["sim.comp.reac['fwd'].K = kf", "sim.comp.reac['bkw'].K = kf"], "@doc": "<p> Sets the macroscopic reaction constant of reaction with identifier string reac in compartment with identifier string comp to kf. The unit of the reaction constant depends on the order of the reaction.</p><p>Note: In a mesh-based simulation this method sets the reaction constant in all tetrahedral elements of the compartment to kf</p><p>Note: The default value still comes from the steps.model description, so calling reset() will return the reaction constant to that value.</p>"}, "Active": {"@code": ["sim.comp.reac['fwd'].Active = active", "sim.comp.reac['bkw'].Active = active"], "@doc": "<p> Activate (active = True) or deactivate (active = False) a reaction with identifier string reac in compartment with identifier string comp. If a reaction is not active this means that a reaction will never occur regardless of whether the reactants are present in sufficient numbers or not.</p><p>Note: In a mesh-based simulation this will activate/deactivate the reaction in all tetrahedral elements in the compartment.</p>"}}, "Vol": {"@code": ["sim.comp.Vol = val"], "@doc": "<p> Set the volume of compartment with identifier string comp (in m^3).</p>"}}, "Patch": {"Species": {"Count": {"@code": ["sim.patch.spec.Count = n"], "@doc": "<p> Sets the number of molecules of species with identifier string spec in patch with identifier string patch to n. Note: in a mesh-based simulation the molecules are divided as equally as possible over all triangular elements in the patch (i.e. a uniform distribution).</p>"}, "Amount": {"@code": ["sim.patch.spec.Amount = a"], "@doc": "<p> Sets the amount (in mols) of species with identifier string spec in patch with identifier string patch to a. In a discrete solver, such as Wmdirect and Tetexact, this continuous value is converted internally into a discrete number of molecules by multiplication with Avogadro's number.</p><p>Note: in a mesh-based simulation the molecules are divided as equally as possible over all triangular elements in the patch (i.e. a uniform distribution).</p>"}, "Clamped": {"@code": ["sim.patch.spec.Clamped = clamped"], "@doc": "<p> Sets whether the species with identifier string spec in patch with identifier string patch is clamped (clamped = True) or not (clamped = False). If a species is clamped the number of molecules stays the same regardless of surface reactions that consume or produce molecules of the species.</p><p>Note: in a mesh-based simulation this will set the species to be clamped in all triangular elements of the patch.</p>"}}, "Reaction": {"K": {"@code": ["sim.patch.sreac['fwd'].K = kf", "sim.patch.sreac['bkw'].K = kf"], "@doc": "<p> Sets the macroscopic reaction constant of surface reaction with identifier string sreac in patch with identifier string patch to kf. The unit of the reaction constant depends on the order of the reaction.</p><p>Note: In a mesh-based simulation this method sets the surface reaction constant in all triangular elements of the patch to kf.</p><p>Note: The default value still comes from the steps.model description, so calling reset() will return the surface reaction constant to that value.</p>"}, "Active": {"@code": ["sim.patch.sreac['fwd'].Active = active", "sim.patch.sreac['bkw'].Active = active"], "@doc": "<p> Activate (active = True) or deactivate (active = False) a surface reaction with identifier string sreac in patch with identifier string patch. If a surface reaction is not active this means that a reaction will never occur regardless of whether the reactants are present in sufficient numbers or not.</p><p>Note: In a mesh-based simulation this will activate/ deactivate the reaction in all triangular elements in the patch.</p>"}}, "Area": {"@code": ["sim.patch.Area = val"], "@doc": "<p> Sets the area of patch with identifier string patch to area a (in m^2).</p>"}}}, "Wmrk4": {"Compartment": {"Species": {"Count": {"@code": ["sim.comp.spec.Count = n"], "@doc": "<p> Set the number of molecules of a species with identifier string spec in compartment with identifier string comp.</p><p>In a mesh-based simulation this is the combined count from all tetrahedral elements in the compartment.</p>"}, "Conc": {"@code": ["sim.comp.spec.Conc = conc"], "@doc": "<p> Sets the concentration (in Molar units) of species with identifier string spec in compartment with identifier string comp to conc. In a discrete solver the continuous concentration is converted to a discrete number of molecules.</p><p>Note: in a mesh-based simulation the molecules are divided as equally as possible over all tetrahedral elements in the compartment (i.e. a uniform distribution).</p>"}, "Amount": {"@code": ["sim.comp.spec.Amount = a"], "@doc": "<p> Set the amount (in mols) of species with identifier string spec in compartment with identifier string comp.</p><p>In a mesh-based simulation this is the combined amount from all tetrahedral elements in the compartment.</p>"}, "Clamped": {"@code": ["sim.comp.spec.Clamped = clamped"], "@doc": "<p> Sets whether the concentration of species with identifier string spec in compartment with identifier string comp is clamped (clamped = True) or not (clamped = False). If a species is clamped the concentration stays the same regardless of reactions that consume or produce molecules of the species.</p><p>Note: in a mesh-based simulation this will set the species to be clamped or not in all tetrahedral elements of the compartment.</p>"}}, "Reaction": {"K": {"@code": ["sim.comp.reac['fwd'].K = kf", "sim.comp.reac['bkw'].K = kf"], "@doc": "<p> Sets the macroscopic reaction constant of reaction with identifier string reac in compartment with identifier string comp to kf. The unit of the reaction constant depends on the order of the reaction.</p><p>Note: In a mesh-based simulation this method sets the reaction constant in all tetrahedral elements of the compartment to kf</p><p>Note: The default value still comes from the steps.model description, so calling reset() will return the reaction constant to that value.</p>"}, "Active": {"@code": ["sim.comp.reac['fwd'].Active = active", "sim.comp.reac['bkw'].Active = active"], "@doc": "<p> Activate (active = True) or deactivate (active = False) a reaction with identifier string reac in compartment with identifier string comp. If a reaction is not active this means that a reaction will never occur regardless of whether the reactants are present in sufficient numbers or not.</p><p>Note: In a mesh-based simulation this will activate/deactivate the reaction in all tetrahedral elements in the compartment.</p>"}}, "Vol": {"@code": ["sim.comp.Vol = val"], "@doc": "<p> Set the volume of compartment with identifier string comp (in m^3).</p>"}}, "Patch": {"Species": {"Count": {"@code": ["sim.patch.spec.Count = n"], "@doc": "<p> Sets the number of molecules of species with identifier string spec in patch with identifier string patch to n. Note: in a mesh-based simulation the molecules are divided as equally as possible over all triangular elements in the patch (i.e. a uniform distribution).</p>"}, "Amount": {"@code": ["sim.patch.spec.Amount = a"], "@doc": "<p> Sets the amount (in mols) of species with identifier string spec in patch with identifier string patch to a. In a discrete solver, such as Wmdirect and Tetexact, this continuous value is converted internally into a discrete number of molecules by multiplication with Avogadro's number.</p><p>Note: in a mesh-based simulation the molecules are divided as equally as possible over all triangular elements in the patch (i.e. a uniform distribution).</p>"}, "Clamped": {"@code": ["sim.patch.spec.Clamped = clamped"], "@doc": "<p> Sets whether the species with identifier string spec in patch with identifier string patch is clamped (clamped = True) or not (clamped = False). If a species is clamped the number of molecules stays the same regardless of surface reactions that consume or produce molecules of the species.</p><p>Note: in a mesh-based simulation this will set the species to be clamped in all triangular elements of the patch.</p>"}}, "Reaction": {"K": {"@code": ["sim.patch.sreac['fwd'].K = kf", "sim.patch.sreac['bkw'].K = kf"], "@doc": "<p> Sets the macroscopic reaction constant of surface reaction with identifier string sreac in patch with identifier string patch to kf. The unit of the reaction constant depends on the order of the reaction.</p><p>Note: In a mesh-based simulation this method sets the surface reaction constant in all triangular elements of the patch to kf.</p><p>Note: The default value still comes from the steps.model description, so calling reset() will return the surface reaction constant to that value.</p>"}, "Active": {"@code": ["sim.patch.sreac['fwd'].Active = active", "sim.patch.sreac['bkw'].Active = active"], "@doc": "<p> Activate (active = True) or deactivate (active = False) a surface reaction with identifier string sreac in patch with identifier string patch. If a surface reaction is not active this means that a reaction will never occur regardless of whether the reactants are present in sufficient numbers or not.</p><p>Note: In a mesh-based simulation this will activate/ deactivate the reaction in all triangular elements in the patch.</p>"}}, "Area": {"@code": ["sim.patch.Area = val"], "@doc": "<p> Sets the area of patch with identifier string patch to area a (in m^2).</p>"}}}, "Tetexact": {"Compartment": {"Species": {"Count": {"@code": ["sim.comp.spec.Count = n"], "@doc": "<p> Set the number of molecules of a species with identifier string spec in compartment with identifier string comp.</p><p>In a mesh-based simulation this is the combined count from all tetrahedral elements in the compartment.</p>"}, "Conc": {"@code": ["sim.comp.spec.Conc = conc"], "@doc": "<p> Sets the concentration (in Molar units) of species with identifier string spec in compartment with identifier string comp to conc. In a discrete solver the continuous concentration is converted to a discrete number of molecules.</p><p>Note: in a mesh-based simulation the molecules are divided as equally as possible over all tetrahedral elements in the compartment (i.e. a uniform distribution).</p>"}, "Amount": {"@code": ["sim.comp.spec.Amount = a"], "@doc": "<p> Set the amount (in mols) of species with identifier string spec in compartment with identifier string comp.</p><p>In a mesh-based simulation this is the combined amount from all tetrahedral elements in the compartment.</p>"}, "Clamped": {"@code": ["sim.comp.spec.Clamped = clamped"], "@doc": "<p> Sets whether the concentration of species with identifier string spec in compartment with identifier string comp is clamped (clamped = True) or not (clamped = False). If a species is clamped the concentration stays the same regardless of reactions that consume or produce molecules of the species.</p><p>Note: in a mesh-based simulation this will set the species to be clamped or not in all tetrahedral elements of the compartment.</p>"}}, "Reaction": {"K": {"@code": ["sim.comp.reac['fwd'].K = kf", "sim.comp.reac['bkw'].K = kf"], "@doc": "<p> Sets the macroscopic reaction constant of reaction with identifier string reac in compartment with identifier string comp to kf. The unit of the reaction constant depends on the order of the reaction.</p><p>Note: In a mesh-based simulation this method sets the reaction constant in all tetrahedral elements of the compartment to kf</p><p>Note: The default value still comes from the steps.model description, so calling reset() will return the reaction constant to that value.</p>"}, "Active": {"@code": ["sim.comp.reac['fwd'].Active = active", "sim.comp.reac['bkw'].Active = active"], "@doc": "<p> Activate (active = True) or deactivate (active = False) a reaction with identifier string reac in compartment with identifier string comp. If a reaction is not active this means that a reaction will never occur regardless of whether the reactants are present in sufficient numbers or not.</p><p>Note: In a mesh-based simulation this will activate/deactivate the reaction in all tetrahedral elements in the compartment.</p>"}}, "Diffusion": {"Active": {"@code": ["sim.comp.diff.Active = active"], "@doc": "<p> Activate (active = True) or deactivate (active = False) a diffusion rule with identifier string diff in compartment with identifier string comp. If diffusion of a species is inactive this means the molecules will remain in place and is effectively the same as setting the diffusion constant to zero</p>"}, "D": {"@code": ["sim.comp.diff.D = dcst"], "@doc": "<p> Sets the diffusion constant of diffusion rule with identifier string diff in compartment with identifier string comp to dcst (in m^2/s).</p><p>Note: This method will set the diffusion constant in all tetrahedral elements in the compartment.</p><p>Note: The default value still comes from the steps.model description, so calling reset() will return the diffusion constants to that value.</p>"}}}, "Patch": {"Species": {"Count": {"@code": ["sim.patch.spec.Count = n"], "@doc": "<p> Sets the number of molecules of species with identifier string spec in patch with identifier string patch to n. Note: in a mesh-based simulation the molecules are divided as equally as possible over all triangular elements in the patch (i.e. a uniform distribution).</p>"}, "Amount": {"@code": ["sim.patch.spec.Amount = a"], "@doc": "<p> Sets the amount (in mols) of species with identifier string spec in patch with identifier string patch to a. In a discrete solver, such as Wmdirect and Tetexact, this continuous value is converted internally into a discrete number of molecules by multiplication with Avogadro's number.</p><p>Note: in a mesh-based simulation the molecules are divided as equally as possible over all triangular elements in the patch (i.e. a uniform distribution).</p>"}, "Clamped": {"@code": ["sim.patch.spec.Clamped = clamped"], "@doc": "<p> Sets whether the species with identifier string spec in patch with identifier string patch is clamped (clamped = True) or not (clamped = False). If a species is clamped the number of molecules stays the same regardless of surface reactions that consume or produce molecules of the species.</p><p>Note: in a mesh-based simulation this will set the species to be clamped in all triangular elements of the patch.</p>"}}, "Reaction": {"K": {"@code": ["sim.patch.sreac['fwd'].K = kf", "sim.patch.sreac['bkw'].K = kf"], "@doc": "<p> Sets the macroscopic reaction constant of surface reaction with identifier string sreac in patch with identifier string patch to kf. The unit of the reaction constant depends on the order of the reaction.</p><p>Note: In a mesh-based simulation this method sets the surface reaction constant in all triangular elements of the patch to kf.</p><p>Note: The default value still comes from the steps.model description, so calling reset() will return the surface reaction constant to that value.</p>"}, "Active": {"@code": ["sim.patch.sreac['fwd'].Active = active", "sim.patch.sreac['bkw'].Active = active"], "@doc": "<p> Activate (active = True) or deactivate (active = False) a surface reaction with identifier string sreac in patch with identifier string patch. If a surface reaction is not active this means that a reaction will never occur regardless of whether the reactants are present in sufficient numbers or not.</p><p>Note: In a mesh-based simulation this will activate/ deactivate the reaction in all triangular elements in the patch.</p>"}}}, "Diff. Boundary": {"Species": {"DiffusionActive": {"@code": ["sim.diffb.spec.DiffusionActive = val"], "@doc": "<p> Activates or inactivates diffusion across a diffusion boundary for a species.</p>"}, "Dcst": {"@code": ["sim.diffb.spec.Dcst = val", "sim.diffb(direc=comp2).spec.Dcst = val"], "@doc": "<p> Set the diffusion constant of tetrahedrons across a diffusion boundary. If direc is provided, only set dcsts of diffusion towards it (Directional dcsts of diffusions in tetrahedrons in the other compartment of the diffusion boundary towards tetrahedons in the direction compartment).</p>"}}}, "Surf. Diff. Boundary": {"Species": {"DiffusionActive": {"@code": ["sim.sdiffb.spec.DiffusionActive = val"], "@doc": "<p> Activates or inactivates diffusion across a surface diffusion boundary for a species.</p>"}, "Dcst": {"@code": ["sim.sdiffb.spec.Dcst = val", "sim.diffb(direc=patch2).spec.Dcst = val"], "@doc": "<p> Set the diffusion constant of triangles across a surface diffusion boundary. If direc is provided, only set dcsts of diffusion towards it (Directional dcsts of diffusions in triangles in the other patches of the diffusion boundary towards triangles in the direction patch).</p>"}}}, "Region of Interest": {"Species": {"Count": {"@code": ["sim.roi.spec.Count = n"], "@doc": "<p> Set the count of a species in a ROI.</p>"}, "Conc": {"@code": ["sim.roi.spec.Conc = conc"], "@doc": "<p> Set the concentration of a species in a ROI.</p>"}, "Amount": {"@code": ["sim.roi.spec.Amount = a"], "@doc": "<p> Set the amount of a species in a ROI.</p>"}, "Clamped": {"@code": ["sim.roi.spec.Clamped = clamped"], "@doc": "<p> Set a species in a ROI to be clamped or not. The count of species spec in the ROI is clamped if clamped is True, not clamped if clamped is False.</p>"}}, "Reaction": {"K": {"@code": ["sim.roi.reac['fwd'].K = kf", "sim.roi.reac['bkw'].K = kf"], "@doc": "<p> Sets the macroscopic reaction constant of reaction with identifier string r in a ROI with identifier string roi to kf. The unit of the reaction constant depends on the order of the reaction.</p><p>Note: The default value still comes from the steps.model description, so calling reset() will return the reaction constant to that value.</p>"}, "Active": {"@code": ["sim.roi.reac['fwd'].Active = active", "sim.roi.reac['bkw'].Active = active"], "@doc": "<p> Set reaction r in a ROI to be active or not.</p>"}}, "Diffusion": {"Active": {"@code": ["sim.roi.diff.Active = active"], "@doc": "<p> Set diffusion d in a ROI to be active or not.</p>"}, "D": {"@code": ["sim.roi.diff.D = dcst", "sim.roi.diff(direc=tet2).D = dcst"], "@doc": "<p> Sets the macroscopic diffusion constant of diffusion with identifier string diff in a ROI with identifier string roi to dcst.</p><p>Note: The default value still comes from the steps.model description, so calling reset() will return the diffusion constant to that value.</p>"}}}, "Tetrahedron": {"Species": {"Count": {"@code": ["sim.TET(tet).spec.Count = n", "sim.TETS(tetLst).spec.Count = n"], "@doc": "<p> Sets the number of molecules of species with identifier string spec in tetrahedral element tet to n.</p>"}, "Conc": {"@code": ["sim.TET(tet).spec.Conc = conc", "sim.TETS(tetLst).spec.Conc = conc"], "@doc": "<p> Sets the concentration (in Molar units) of species with identifier string spec in a tetrahedral element tet to conc.This continuous value must be converted internally to a discrete number of molecules.</p><p>Due to the small volumes of tetrahedral elements the difference between 'rounding up' and 'rounding down' can be a large difference in concentration.</p>"}, "Amount": {"@code": ["sim.TET(tet).spec.Amount = a", "sim.TETS(tetLst).spec.Amount = a"], "@doc": "<p> Sets the amount (in mols) of species with identifier string spec in tetrahedral element tet to a. This continuous value must be converted internally to a discrete number of molecules by multiplication with Avogadro's number.</p><p>Due to the small volumes of tetrahedral elements the difference between 'rounding up' and 'rounding down' can be a significant difference in concentration.</p>"}, "Clamped": {"@code": ["sim.TET(tet).spec.Clamped = clamped", "sim.TETS(tetLst).spec.Clamped = clamped"], "@doc": "<p> Sets whether the concentration of species spec in tetrahedral element tet is clamped (clamped = True) or not (clamped = False). If a species is clamped the concentration stays the same regardless of reactions that consume or produce molecules of the species or diffusion of the species into or out of the tetrahedral element.</p>"}}, "Reaction": {"K": {"@code": ["sim.TET(tet).reac['fwd'].K = kf", "sim.TET(tet).reac['bkw'].K = kf", "sim.TETS(tetLst).reac['fwd'].K = kf", "sim.TETS(tetLst).reac['bkw'].K = kf"], "@doc": "<p> Sets the macroscopic reaction constant of reaction with identifier string reac in tetrahedral element tet to kf. The units of the reaction constant depends on the order of the reaction.</p>"}, "Active": {"@code": ["sim.TET(tet).reac['fwd'].Active = active", "sim.TET(tet).reac['bkw'].Active = active", "sim.TETS(tetLst).reac['fwd'].Active = active", "sim.TETS(tetLst).reac['bkw'].Active = active"], "@doc": "<p> Activate (active = True) or deactivate (active = False) a reaction with identifier string reac in tetrahedral element tet. If it's not active this means that the reaction will never occur regardless of whether reactants are present in sufficient numbers or not.</p>"}}, "Diffusion": {"Active": {"@code": ["sim.TET(tet).diff.Active = active", "sim.TETS(tetLst).diff.Active = active"], "@doc": "<p> Activate (active = True) or deactivate (active = False) diffusion rule with identifier string diff in tetrahedral element tet. If diffusion of a species is inactive this means the molecules will never diffuse out of the tetrahedron and has the same effect as a diffusion constant of zero.</p>"}, "D": {"@code": ["sim.TET(tet).diff.D = dcst", "sim.TET(tet).diff(direc=tet2).D = dcst", "sim.TETS(tetLst).diff.D = dcst"], "@doc": "<p> Sets the diffusion constant of diffusion rule with identifier string diff in tetrahedral element tet to dcst (in m^2/s). Specify direc to set the constant only towards a given tetrahedron direction.</p>"}}, "V": {"@code": ["sim.TET(tet).V = val", "sim.TETS(tetLst).V = val"], "@doc": "<p> Set the potential (in volts) of tetrahedral element tet.</p>"}, "VClamped": {"@code": ["sim.TET(tet).VClamped = clamped", "sim.TETS(tetLst).VClamped = clamped"], "@doc": "<p> Sets whether the potential of tetrahedral element tet is clamped (clamped = True) or not (clamped = False).</p>"}}, "Triangle": {"Species": {"Count": {"@code": ["sim.TRI(tri).spec.Count = n", "sim.TRIS(triLst).spec.Count = n"], "@doc": "<p> Sets the number of molecules of species with identifier string spec in triangular element tri to n.</p>"}, "Amount": {"@code": ["sim.TRI(tri).spec.Amount = a", "sim.TRIS(triLst).spec.Amount = a"], "@doc": "<p> Sets the amount (in mols) of species with identifier string spec in triangular element tri to a. This continuous value must be converted internally to a discrete number of molecules by multiplication with Avogadro's number.</p>"}, "Clamped": {"@code": ["sim.TRI(tri).spec.Clamped = clamped", "sim.TRIS(triLst).spec.Clamped = clamped"], "@doc": "<p> Sets whether the concentration of species spec in triangular element tri is clamped (clamped = True) or not (clamped = False). If a species is clamped the concentration stays the same regardless of reactions that consume or produce molecules of the species.</p>"}}, "Reaction": {"K": {"@code": ["sim.TRI(tri).sreac['fwd'].K = kf", "sim.TRI(tri).sreac['bkw'].K = kf", "sim.TRIS(triLst).sreac['fwd'].K = kf", "sim.TRIS(triLst).sreac['bkw'].K = kf"], "@doc": "<p> Sets the macroscopic reaction constant of surface reaction with identifier string sreac in triangular element tri to kf. The units of the reaction constant depends on the order of the reaction.</p>"}, "Active": {"@code": ["sim.TRI(tri).sreac['fwd'].Active = active", "sim.TRI(tri).sreac['bkw'].Active = active", "sim.TRIS(triLst).sreac['fwd'].Active = active", "sim.TRIS(triLst).sreac['bkw'].Active = active"], "@doc": "<p> Activate (active = True) or deactivate (active = False) a surface reaction with identifier string sreac in triangular element tri. If it's not active this means that the surface reaction will never occur regardless of whether reactants are present in sufficient numbers or not.</p>"}}, "Diffusion": {"D": {"@code": ["sim.TRI(tri).sdiff.D = dcst", "sim.TRI(tri).sdiff(direc=tri2).D = dcst", "sim.TRIS(triLst).sdiff.D = dcst"], "@doc": "<p> Sets the diffusion constant of diffusion rule with identifier string diff in triangle element tri to dcst. Specify direc to set the constant only towards a given triangle direction.</p>"}}, "V": {"@code": ["sim.TRI(tri).V = val", "sim.TRIS(triLst).V = val"], "@doc": "<p> Set the potential (in volts) of triangle element tri.</p>"}, "VClamped": {"@code": ["sim.TRI(tri).VClamped = clamped", "sim.TRIS(triLst).VClamped = clamped"], "@doc": "<p> Sets whether the potential of triangle element tri is clamped (clamped = True) or not (clamped = False).</p>"}, "IClamp": {"@code": ["sim.TRI(tri).IClamp = i", "sim.TRIS(triLst).IClamp = i"], "@doc": "<p> Set current clamp to triangle element tri to current i (amps). NOTE: Convention is maintained that a positive current clamp is depolarizing, a negative current clamp is hyperpolarizing.</p>"}, "Capac": {"@code": ["sim.TRI(tri).Capac = cap", "sim.TRIS(triLst).Capac = cap"], "@doc": "<p> Sets the specific membrane capacitance (in farad / m^2) of tri tri.</p>"}}, "Membrane": {"Potential": {"@code": ["sim.memb.Potential = val"], "@doc": "<p> Sets the potential (in volts) of membrane with string identifier memb. NOTE: This method will set the potential of all nodes in the volume conductor to the same value.</p>"}, "Capac": {"@code": ["sim.memb.Capac = cap"], "@doc": "<p> Sets the specific membrane capacitance (in farad / m^2) of membrane with string identifier memb.</p>"}, "VolRes": {"@code": ["sim.memb.VolRes = val"], "@doc": "<p> Sets the bulk electrical resistivity (in ohm.m) of the volume conductor assocaited with membrane with string identifier memb.</p>"}, "Res": {"@code": ["sim.memb.Res = steps.utils.Params(ro, vrev)"], "@doc": "<p> Sets the surface electrical resistivity ro (in ohm.m^2) of the membrane with string identifier memb. Reversal potential vrev is required in Volts.</p>"}}, "Vertex": {"V": {"@code": ["sim.VERT(vert).V = val", "sim.VERTS(vertLst).V = val"], "@doc": "<p> Set the potential (in volts) of vertex element vert.</p>"}, "VClamped": {"@code": ["sim.VERT(vert).VClamped = clamped", "sim.VERTS(vertLst).VClamped = clamped"], "@doc": "<p> Sets whether the potential of vertex element vert is clamped (clamped = True) or not (clamped = False).</p>"}, "IClamp": {"@code": ["sim.VERT(vert).IClamp = i", "sim.VERTS(vertLst).IClamp = i"], "@doc": "<p> Set current clamp to vertex element vert to current i (Amps). NOTE: Convention is maintained that a positive current clamp is depolarizing, a negative current clamp is hyperpolarizing.</p>"}}}, "TetODE": {"Compartment": {"Species": {"Count": {"@code": ["sim.comp.spec.Count = n"], "@doc": "<p> Set the number of molecules of a species with identifier string spec in compartment with identifier string comp.</p><p>In a mesh-based simulation this is the combined count from all tetrahedral elements in the compartment.</p>"}, "Conc": {"@code": ["sim.comp.spec.Conc = conc"], "@doc": "<p> Sets the concentration (in Molar units) of species with identifier string spec in compartment with identifier string comp to conc. In a discrete solver the continuous concentration is converted to a discrete number of molecules.</p><p>Note: in a mesh-based simulation the molecules are divided as equally as possible over all tetrahedral elements in the compartment (i.e. a uniform distribution).</p>"}, "Amount": {"@code": ["sim.comp.spec.Amount = a"], "@doc": "<p> Set the amount (in mols) of species with identifier string spec in compartment with identifier string comp.</p><p>In a mesh-based simulation this is the combined amount from all tetrahedral elements in the compartment.</p>"}, "Clamped": {"@code": ["sim.comp.spec.Clamped = clamped"], "@doc": "<p> Sets whether the concentration of species with identifier string spec in compartment with identifier string comp is clamped (clamped = True) or not (clamped = False). If a species is clamped the concentration stays the same regardless of reactions that consume or produce molecules of the species.</p><p>Note: in a mesh-based simulation this will set the species to be clamped or not in all tetrahedral elements of the compartment.</p>"}}, "Reaction": {"K": {"@code": ["sim.comp.reac['fwd'].K = kf", "sim.comp.reac['bkw'].K = kf"], "@doc": "<p> Sets the macroscopic reaction constant of reaction with identifier string reac in compartment with identifier string comp to kf. The unit of the reaction constant depends on the order of the reaction.</p><p>Note: In a mesh-based simulation this method sets the reaction constant in all tetrahedral elements of the compartment to kf</p><p>Note: The default value still comes from the steps.model description, so calling reset() will return the reaction constant to that value.</p>"}, "Active": {"@code": ["sim.comp.reac['fwd'].Active = active", "sim.comp.reac['bkw'].Active = active"], "@doc": "<p> Activate (active = True) or deactivate (active = False) a reaction with identifier string reac in compartment with identifier string comp. If a reaction is not active this means that a reaction will never occur regardless of whether the reactants are present in sufficient numbers or not.</p><p>Note: In a mesh-based simulation this will activate/deactivate the reaction in all tetrahedral elements in the compartment.</p>"}}, "Diffusion": {"Active": {"@code": ["sim.comp.diff.Active = active"], "@doc": "<p> Activate (active = True) or deactivate (active = False) a diffusion rule with identifier string diff in compartment with identifier string comp. If diffusion of a species is inactive this means the molecules will remain in place and is effectively the same as setting the diffusion constant to zero</p>"}, "D": {"@code": ["sim.comp.diff.D = dcst"], "@doc": "<p> Sets the diffusion constant of diffusion rule with identifier string diff in compartment with identifier string comp to dcst (in m^2/s).</p><p>Note: This method will set the diffusion constant in all tetrahedral elements in the compartment.</p><p>Note: The default value still comes from the steps.model description, so calling reset() will return the diffusion constants to that value.</p>"}}}, "Patch": {"Species": {"Count": {"@code": ["sim.patch.spec.Count = n"], "@doc": "<p> Sets the number of molecules of species with identifier string spec in patch with identifier string patch to n. Note: in a mesh-based simulation the molecules are divided as equally as possible over all triangular elements in the patch (i.e. a uniform distribution).</p>"}, "Amount": {"@code": ["sim.patch.spec.Amount = a"], "@doc": "<p> Sets the amount (in mols) of species with identifier string spec in patch with identifier string patch to a. In a discrete solver, such as Wmdirect and Tetexact, this continuous value is converted internally into a discrete number of molecules by multiplication with Avogadro's number.</p><p>Note: in a mesh-based simulation the molecules are divided as equally as possible over all triangular elements in the patch (i.e. a uniform distribution).</p>"}, "Clamped": {"@code": ["sim.patch.spec.Clamped = clamped"], "@doc": "<p> Sets whether the species with identifier string spec in patch with identifier string patch is clamped (clamped = True) or not (clamped = False). If a species is clamped the number of molecules stays the same regardless of surface reactions that consume or produce molecules of the species.</p><p>Note: in a mesh-based simulation this will set the species to be clamped in all triangular elements of the patch.</p>"}}, "Reaction": {"K": {"@code": ["sim.patch.sreac['fwd'].K = kf", "sim.patch.sreac['bkw'].K = kf"], "@doc": "<p> Sets the macroscopic reaction constant of surface reaction with identifier string sreac in patch with identifier string patch to kf. The unit of the reaction constant depends on the order of the reaction.</p><p>Note: In a mesh-based simulation this method sets the surface reaction constant in all triangular elements of the patch to kf.</p><p>Note: The default value still comes from the steps.model description, so calling reset() will return the surface reaction constant to that value.</p>"}, "Active": {"@code": ["sim.patch.sreac['fwd'].Active = active", "sim.patch.sreac['bkw'].Active = active"], "@doc": "<p> Activate (active = True) or deactivate (active = False) a surface reaction with identifier string sreac in patch with identifier string patch. If a surface reaction is not active this means that a reaction will never occur regardless of whether the reactants are present in sufficient numbers or not.</p><p>Note: In a mesh-based simulation this will activate/ deactivate the reaction in all triangular elements in the patch.</p>"}}}, "Diff. Boundary": {"Species": {"DiffusionActive": {"@code": ["sim.diffb.spec.DiffusionActive = val"], "@doc": "<p> Activates or inactivates diffusion across a diffusion boundary for a species.</p>"}, "Dcst": {"@code": ["sim.diffb.spec.Dcst = val", "sim.diffb(direc=comp2).spec.Dcst = val"], "@doc": "<p> Set the diffusion constant of tetrahedrons across a diffusion boundary. If direc is provided, only set dcsts of diffusion towards it (Directional dcsts of diffusions in tetrahedrons in the other compartment of the diffusion boundary towards tetrahedons in the direction compartment).</p>"}}}, "Surf. Diff. Boundary": {"Species": {"DiffusionActive": {"@code": ["sim.sdiffb.spec.DiffusionActive = val"], "@doc": "<p> Activates or inactivates diffusion across a surface diffusion boundary for a species.</p>"}, "Dcst": {"@code": ["sim.sdiffb.spec.Dcst = val", "sim.diffb(direc=patch2).spec.Dcst = val"], "@doc": "<p> Set the diffusion constant of triangles across a surface diffusion boundary. If direc is provided, only set dcsts of diffusion towards it (Directional dcsts of diffusions in triangles in the other patches of the diffusion boundary towards triangles in the direction patch).</p>"}}}, "Tetrahedron": {"Species": {"Count": {"@code": ["sim.TET(tet).spec.Count = n", "sim.TETS(tetLst).spec.Count = n"], "@doc": "<p> Sets the number of molecules of species with identifier string spec in tetrahedral element tet to n.</p>"}, "Conc": {"@code": ["sim.TET(tet).spec.Conc = conc", "sim.TETS(tetLst).spec.Conc = conc"], "@doc": "<p> Sets the concentration (in Molar units) of species with identifier string spec in a tetrahedral element tet to conc.This continuous value must be converted internally to a discrete number of molecules.</p><p>Due to the small volumes of tetrahedral elements the difference between 'rounding up' and 'rounding down' can be a large difference in concentration.</p>"}, "Amount": {"@code": ["sim.TET(tet).spec.Amount = a", "sim.TETS(tetLst).spec.Amount = a"], "@doc": "<p> Sets the amount (in mols) of species with identifier string spec in tetrahedral element tet to a. This continuous value must be converted internally to a discrete number of molecules by multiplication with Avogadro's number.</p><p>Due to the small volumes of tetrahedral elements the difference between 'rounding up' and 'rounding down' can be a significant difference in concentration.</p>"}, "Clamped": {"@code": ["sim.TET(tet).spec.Clamped = clamped", "sim.TETS(tetLst).spec.Clamped = clamped"], "@doc": "<p> Sets whether the concentration of species spec in tetrahedral element tet is clamped (clamped = True) or not (clamped = False). If a species is clamped the concentration stays the same regardless of reactions that consume or produce molecules of the species or diffusion of the species into or out of the tetrahedral element.</p>"}}, "Reaction": {"K": {"@code": ["sim.TET(tet).reac['fwd'].K = kf", "sim.TET(tet).reac['bkw'].K = kf", "sim.TETS(tetLst).reac['fwd'].K = kf", "sim.TETS(tetLst).reac['bkw'].K = kf"], "@doc": "<p> Sets the macroscopic reaction constant of reaction with identifier string reac in tetrahedral element tet to kf. The units of the reaction constant depends on the order of the reaction.</p>"}, "Active": {"@code": ["sim.TET(tet).reac['fwd'].Active = active", "sim.TET(tet).reac['bkw'].Active = active", "sim.TETS(tetLst).reac['fwd'].Active = active", "sim.TETS(tetLst).reac['bkw'].Active = active"], "@doc": "<p> Activate (active = True) or deactivate (active = False) a reaction with identifier string reac in tetrahedral element tet. If it's not active this means that the reaction will never occur regardless of whether reactants are present in sufficient numbers or not.</p>"}}, "Diffusion": {"Active": {"@code": ["sim.TET(tet).diff.Active = active", "sim.TETS(tetLst).diff.Active = active"], "@doc": "<p> Activate (active = True) or deactivate (active = False) diffusion rule with identifier string diff in tetrahedral element tet. If diffusion of a species is inactive this means the molecules will never diffuse out of the tetrahedron and has the same effect as a diffusion constant of zero.</p>"}, "D": {"@code": ["sim.TET(tet).diff.D = dcst", "sim.TET(tet).diff(direc=tet2).D = dcst", "sim.TETS(tetLst).diff.D = dcst"], "@doc": "<p> Sets the diffusion constant of diffusion rule with identifier string diff in tetrahedral element tet to dcst (in m^2/s). Specify direc to set the constant only towards a given tetrahedron direction.</p>"}}, "V": {"@code": ["sim.TET(tet).V = val", "sim.TETS(tetLst).V = val"], "@doc": "<p> Set the potential (in volts) of tetrahedral element tet.</p>"}, "VClamped": {"@code": ["sim.TET(tet).VClamped = clamped", "sim.TETS(tetLst).VClamped = clamped"], "@doc": "<p> Sets whether the potential of tetrahedral element tet is clamped (clamped = True) or not (clamped = False).</p>"}}, "Triangle": {"Species": {"Count": {"@code": ["sim.TRI(tri).spec.Count = n", "sim.TRIS(triLst).spec.Count = n"], "@doc": "<p> Sets the number of molecules of species with identifier string spec in triangular element tri to n.</p>"}, "Amount": {"@code": ["sim.TRI(tri).spec.Amount = a", "sim.TRIS(triLst).spec.Amount = a"], "@doc": "<p> Sets the amount (in mols) of species with identifier string spec in triangular element tri to a. This continuous value must be converted internally to a discrete number of molecules by multiplication with Avogadro's number.</p>"}, "Clamped": {"@code": ["sim.TRI(tri).spec.Clamped = clamped", "sim.TRIS(triLst).spec.Clamped = clamped"], "@doc": "<p> Sets whether the concentration of species spec in triangular element tri is clamped (clamped = True) or not (clamped = False). If a species is clamped the concentration stays the same regardless of reactions that consume or produce molecules of the species.</p>"}}, "Reaction": {"K": {"@code": ["sim.TRI(tri).sreac['fwd'].K = kf", "sim.TRI(tri).sreac['bkw'].K = kf", "sim.TRIS(triLst).sreac['fwd'].K = kf", "sim.TRIS(triLst).sreac['bkw'].K = kf"], "@doc": "<p> Sets the macroscopic reaction constant of surface reaction with identifier string sreac in triangular element tri to kf. The units of the reaction constant depends on the order of the reaction.</p>"}, "Active": {"@code": ["sim.TRI(tri).sreac['fwd'].Active = active", "sim.TRI(tri).sreac['bkw'].Active = active", "sim.TRIS(triLst).sreac['fwd'].Active = active", "sim.TRIS(triLst).sreac['bkw'].Active = active"], "@doc": "<p> Activate (active = True) or deactivate (active = False) a surface reaction with identifier string sreac in triangular element tri. If it's not active this means that the surface reaction will never occur regardless of whether reactants are present in sufficient numbers or not.</p>"}}, "Diffusion": {"D": {"@code": ["sim.TRI(tri).sdiff.D = dcst", "sim.TRI(tri).sdiff(direc=tri2).D = dcst", "sim.TRIS(triLst).sdiff.D = dcst"], "@doc": "<p> Sets the diffusion constant of diffusion rule with identifier string diff in triangle element tri to dcst. Specify direc to set the constant only towards a given triangle direction.</p>"}}, "V": {"@code": ["sim.TRI(tri).V = val", "sim.TRIS(triLst).V = val"], "@doc": "<p> Set the potential (in volts) of triangle element tri.</p>"}, "VClamped": {"@code": ["sim.TRI(tri).VClamped = clamped", "sim.TRIS(triLst).VClamped = clamped"], "@doc": "<p> Sets whether the potential of triangle element tri is clamped (clamped = True) or not (clamped = False).</p>"}, "IClamp": {"@code": ["sim.TRI(tri).IClamp = i", "sim.TRIS(triLst).IClamp = i"], "@doc": "<p> Set current clamp to triangle element tri to current i (amps). NOTE: Convention is maintained that a positive current clamp is depolarizing, a negative current clamp is hyperpolarizing.</p>"}, "Capac": {"@code": ["sim.TRI(tri).Capac = cap", "sim.TRIS(triLst).Capac = cap"], "@doc": "<p> Sets the specific membrane capacitance (in farad / m^2) of tri tri.</p>"}}, "Membrane": {"Potential": {"@code": ["sim.memb.Potential = val"], "@doc": "<p> Sets the potential (in volts) of membrane with string identifier memb. NOTE: This method will set the potential of all nodes in the volume conductor to the same value.</p>"}, "Capac": {"@code": ["sim.memb.Capac = cap"], "@doc": "<p> Sets the specific membrane capacitance (in farad / m^2) of membrane with string identifier memb.</p>"}, "VolRes": {"@code": ["sim.memb.VolRes = val"], "@doc": "<p> Sets the bulk electrical resistivity (in ohm.m) of the volume conductor assocaited with membrane with string identifier memb.</p>"}, "Res": {"@code": ["sim.memb.Res = steps.utils.Params(ro, vrev)"], "@doc": "<p> Sets the surface electrical resistivity ro (in ohm.m^2) of the membrane with string identifier memb. Reversal potential vrev is required in Volts.</p>"}}, "Vertex": {"V": {"@code": ["sim.VERT(vert).V = val", "sim.VERTS(vertLst).V = val"], "@doc": "<p> Set the potential (in volts) of vertex element vert.</p>"}, "VClamped": {"@code": ["sim.VERT(vert).VClamped = clamped", "sim.VERTS(vertLst).VClamped = clamped"], "@doc": "<p> Sets whether the potential of vertex element vert is clamped (clamped = True) or not (clamped = False).</p>"}, "IClamp": {"@code": ["sim.VERT(vert).IClamp = i", "sim.VERTS(vertLst).IClamp = i"], "@doc": "<p> Set current clamp to vertex element vert to current i (Amps). NOTE: Convention is maintained that a positive current clamp is depolarizing, a negative current clamp is hyperpolarizing.</p>"}}}, "TetOpSplit": {"Compartment": {"Species": {"Count": {"@code": ["sim.comp.spec.Count = n"], "@doc": "<p> Set the number of molecules of a species with identifier string spec in compartment with identifier string comp.</p><p>In a mesh-based simulation this is the combined count from all tetrahedral elements in the compartment.</p>"}, "Conc": {"@code": ["sim.comp.spec.Conc = conc"], "@doc": "<p> Sets the concentration (in Molar units) of species with identifier string spec in compartment with identifier string comp to conc. In a discrete solver the continuous concentration is converted to a discrete number of molecules.</p><p>Note: in a mesh-based simulation the molecules are divided as equally as possible over all tetrahedral elements in the compartment (i.e. a uniform distribution).</p>"}, "Amount": {"@code": ["sim.comp.spec.Amount = a"], "@doc": "<p> Set the amount (in mols) of species with identifier string spec in compartment with identifier string comp.</p><p>In a mesh-based simulation this is the combined amount from all tetrahedral elements in the compartment.</p>"}, "Clamped": {"@code": ["sim.comp.spec.Clamped = clamped"], "@doc": "<p> Sets whether the concentration of species with identifier string spec in compartment with identifier string comp is clamped (clamped = True) or not (clamped = False). If a species is clamped the concentration stays the same regardless of reactions that consume or produce molecules of the species.</p><p>Note: in a mesh-based simulation this will set the species to be clamped or not in all tetrahedral elements of the compartment.</p>"}}, "Reaction": {"K": {"@code": ["sim.comp.reac['fwd'].K = kf", "sim.comp.reac['bkw'].K = kf"], "@doc": "<p> Sets the macroscopic reaction constant of reaction with identifier string reac in compartment with identifier string comp to kf. The unit of the reaction constant depends on the order of the reaction.</p><p>Note: In a mesh-based simulation this method sets the reaction constant in all tetrahedral elements of the compartment to kf</p><p>Note: The default value still comes from the steps.model description, so calling reset() will return the reaction constant to that value.</p>"}, "Active": {"@code": ["sim.comp.reac['fwd'].Active = active", "sim.comp.reac['bkw'].Active = active"], "@doc": "<p> Activate (active = True) or deactivate (active = False) a reaction with identifier string reac in compartment with identifier string comp. If a reaction is not active this means that a reaction will never occur regardless of whether the reactants are present in sufficient numbers or not.</p><p>Note: In a mesh-based simulation this will activate/deactivate the reaction in all tetrahedral elements in the compartment.</p>"}}, "Diffusion": {"Active": {"@code": ["sim.comp.diff.Active = active"], "@doc": "<p> Activate (active = True) or deactivate (active = False) a diffusion rule with identifier string diff in compartment with identifier string comp. If diffusion of a species is inactive this means the molecules will remain in place and is effectively the same as setting the diffusion constant to zero</p>"}, "D": {"@code": ["sim.comp.diff.D = dcst"], "@doc": "<p> Sets the diffusion constant of diffusion rule with identifier string diff in compartment with identifier string comp to dcst (in m^2/s).</p><p>Note: This method will set the diffusion constant in all tetrahedral elements in the compartment.</p><p>Note: The default value still comes from the steps.model description, so calling reset() will return the diffusion constants to that value.</p>"}}}, "Patch": {"Species": {"Count": {"@code": ["sim.patch.spec.Count = n"], "@doc": "<p> Sets the number of molecules of species with identifier string spec in patch with identifier string patch to n. Note: in a mesh-based simulation the molecules are divided as equally as possible over all triangular elements in the patch (i.e. a uniform distribution).</p>"}, "Amount": {"@code": ["sim.patch.spec.Amount = a"], "@doc": "<p> Sets the amount (in mols) of species with identifier string spec in patch with identifier string patch to a. In a discrete solver, such as Wmdirect and Tetexact, this continuous value is converted internally into a discrete number of molecules by multiplication with Avogadro's number.</p><p>Note: in a mesh-based simulation the molecules are divided as equally as possible over all triangular elements in the patch (i.e. a uniform distribution).</p>"}, "Clamped": {"@code": ["sim.patch.spec.Clamped = clamped"], "@doc": "<p> Sets whether the species with identifier string spec in patch with identifier string patch is clamped (clamped = True) or not (clamped = False). If a species is clamped the number of molecules stays the same regardless of surface reactions that consume or produce molecules of the species.</p><p>Note: in a mesh-based simulation this will set the species to be clamped in all triangular elements of the patch.</p>"}}, "Reaction": {"K": {"@code": ["sim.patch.sreac['fwd'].K = kf", "sim.patch.sreac['bkw'].K = kf"], "@doc": "<p> Sets the macroscopic reaction constant of surface reaction with identifier string sreac in patch with identifier string patch to kf. The unit of the reaction constant depends on the order of the reaction.</p><p>Note: In a mesh-based simulation this method sets the surface reaction constant in all triangular elements of the patch to kf.</p><p>Note: The default value still comes from the steps.model description, so calling reset() will return the surface reaction constant to that value.</p>"}, "Active": {"@code": ["sim.patch.sreac['fwd'].Active = active", "sim.patch.sreac['bkw'].Active = active"], "@doc": "<p> Activate (active = True) or deactivate (active = False) a surface reaction with identifier string sreac in patch with identifier string patch. If a surface reaction is not active this means that a reaction will never occur regardless of whether the reactants are present in sufficient numbers or not.</p><p>Note: In a mesh-based simulation this will activate/ deactivate the reaction in all triangular elements in the patch.</p>"}}}, "Diff. Boundary": {"Species": {"DiffusionActive": {"@code": ["sim.diffb.spec.DiffusionActive = val"], "@doc": "<p> Activates or inactivates diffusion across a diffusion boundary for a species.</p>"}, "Dcst": {"@code": ["sim.diffb.spec.Dcst = val", "sim.diffb(direc=comp2).spec.Dcst = val"], "@doc": "<p> Set the diffusion constant of tetrahedrons across a diffusion boundary. If direc is provided, only set dcsts of diffusion towards it (Directional dcsts of diffusions in tetrahedrons in the other compartment of the diffusion boundary towards tetrahedons in the direction compartment).</p>"}}}, "Surf. Diff. Boundary": {"Species": {"DiffusionActive": {"@code": ["sim.sdiffb.spec.DiffusionActive = val"], "@doc": "<p> Activates or inactivates diffusion across a surface diffusion boundary for a species.</p>"}, "Dcst": {"@code": ["sim.sdiffb.spec.Dcst = val", "sim.diffb(direc=patch2).spec.Dcst = val"], "@doc": "<p> Set the diffusion constant of triangles across a surface diffusion boundary. If direc is provided, only set dcsts of diffusion towards it (Directional dcsts of diffusions in triangles in the other patches of the diffusion boundary towards triangles in the direction patch).</p>"}}}, "Region of Interest": {"Species": {"Count": {"@code": ["sim.roi.spec.Count = n"], "@doc": "<p> Set the count of a species in a ROI.</p>"}, "Conc": {"@code": ["sim.roi.spec.Conc = conc"], "@doc": "<p> Set the concentration of a species in a ROI.</p>"}, "Amount": {"@code": ["sim.roi.spec.Amount = a"], "@doc": "<p> Set the amount of a species in a ROI.</p>"}, "Clamped": {"@code": ["sim.roi.spec.Clamped = clamped"], "@doc": "<p> Set a species in a ROI to be clamped or not. The count of species spec in the ROI is clamped if clamped is True, not clamped if clamped is False.</p>"}}, "Reaction": {"K": {"@code": ["sim.roi.reac['fwd'].K = kf", "sim.roi.reac['bkw'].K = kf"], "@doc": "<p> Sets the macroscopic reaction constant of reaction with identifier string r in a ROI with identifier string roi to kf. The unit of the reaction constant depends on the order of the reaction.</p><p>Note: The default value still comes from the steps.model description, so calling reset() will return the reaction constant to that value.</p>"}, "Active": {"@code": ["sim.roi.reac['fwd'].Active = active", "sim.roi.reac['bkw'].Active = active"], "@doc": "<p> Set reaction r in a ROI to be active or not.</p>"}}, "Diffusion": {"Active": {"@code": ["sim.roi.diff.Active = active"], "@doc": "<p> Set diffusion d in a ROI to be active or not.</p>"}, "D": {"@code": ["sim.roi.diff.D = dcst", "sim.roi.diff(direc=tet2).D = dcst"], "@doc": "<p> Sets the macroscopic diffusion constant of diffusion with identifier string diff in a ROI with identifier string roi to dcst.</p><p>Note: The default value still comes from the steps.model description, so calling reset() will return the diffusion constant to that value.</p>"}}}, "Tetrahedron": {"Species": {"Count": {"@code": ["sim.TET(tet).spec.Count = n", "sim.TETS(tetLst).spec.Count = n"], "@doc": "<p> Sets the number of molecules of species with identifier string spec in tetrahedral element tet to n.</p>"}, "Conc": {"@code": ["sim.TET(tet).spec.Conc = conc", "sim.TETS(tetLst).spec.Conc = conc"], "@doc": "<p> Sets the concentration (in Molar units) of species with identifier string spec in a tetrahedral element tet to conc.This continuous value must be converted internally to a discrete number of molecules.</p><p>Due to the small volumes of tetrahedral elements the difference between 'rounding up' and 'rounding down' can be a large difference in concentration.</p>"}, "Amount": {"@code": ["sim.TET(tet).spec.Amount = a", "sim.TETS(tetLst).spec.Amount = a"], "@doc": "<p> Sets the amount (in mols) of species with identifier string spec in tetrahedral element tet to a. This continuous value must be converted internally to a discrete number of molecules by multiplication with Avogadro's number.</p><p>Due to the small volumes of tetrahedral elements the difference between 'rounding up' and 'rounding down' can be a significant difference in concentration.</p>"}, "Clamped": {"@code": ["sim.TET(tet).spec.Clamped = clamped", "sim.TETS(tetLst).spec.Clamped = clamped"], "@doc": "<p> Sets whether the concentration of species spec in tetrahedral element tet is clamped (clamped = True) or not (clamped = False). If a species is clamped the concentration stays the same regardless of reactions that consume or produce molecules of the species or diffusion of the species into or out of the tetrahedral element.</p>"}}, "Reaction": {"K": {"@code": ["sim.TET(tet).reac['fwd'].K = kf", "sim.TET(tet).reac['bkw'].K = kf", "sim.TETS(tetLst).reac['fwd'].K = kf", "sim.TETS(tetLst).reac['bkw'].K = kf"], "@doc": "<p> Sets the macroscopic reaction constant of reaction with identifier string reac in tetrahedral element tet to kf. The units of the reaction constant depends on the order of the reaction.</p>"}, "Active": {"@code": ["sim.TET(tet).reac['fwd'].Active = active", "sim.TET(tet).reac['bkw'].Active = active", "sim.TETS(tetLst).reac['fwd'].Active = active", "sim.TETS(tetLst).reac['bkw'].Active = active"], "@doc": "<p> Activate (active = True) or deactivate (active = False) a reaction with identifier string reac in tetrahedral element tet. If it's not active this means that the reaction will never occur regardless of whether reactants are present in sufficient numbers or not.</p>"}}, "Diffusion": {"Active": {"@code": ["sim.TET(tet).diff.Active = active", "sim.TETS(tetLst).diff.Active = active"], "@doc": "<p> Activate (active = True) or deactivate (active = False) diffusion rule with identifier string diff in tetrahedral element tet. If diffusion of a species is inactive this means the molecules will never diffuse out of the tetrahedron and has the same effect as a diffusion constant of zero.</p>"}, "D": {"@code": ["sim.TET(tet).diff.D = dcst", "sim.TET(tet).diff(direc=tet2).D = dcst", "sim.TETS(tetLst).diff.D = dcst"], "@doc": "<p> Sets the diffusion constant of diffusion rule with identifier string diff in tetrahedral element tet to dcst (in m^2/s). Specify direc to set the constant only towards a given tetrahedron direction.</p>"}}, "V": {"@code": ["sim.TET(tet).V = val", "sim.TETS(tetLst).V = val"], "@doc": "<p> Set the potential (in volts) of tetrahedral element tet.</p>"}, "VClamped": {"@code": ["sim.TET(tet).VClamped = clamped", "sim.TETS(tetLst).VClamped = clamped"], "@doc": "<p> Sets whether the potential of tetrahedral element tet is clamped (clamped = True) or not (clamped = False).</p>"}}, "Triangle": {"Species": {"Count": {"@code": ["sim.TRI(tri).spec.Count = n", "sim.TRIS(triLst).spec.Count = n"], "@doc": "<p> Sets the number of molecules of species with identifier string spec in triangular element tri to n.</p>"}, "Amount": {"@code": ["sim.TRI(tri).spec.Amount = a", "sim.TRIS(triLst).spec.Amount = a"], "@doc": "<p> Sets the amount (in mols) of species with identifier string spec in triangular element tri to a. This continuous value must be converted internally to a discrete number of molecules by multiplication with Avogadro's number.</p>"}, "Clamped": {"@code": ["sim.TRI(tri).spec.Clamped = clamped", "sim.TRIS(triLst).spec.Clamped = clamped"], "@doc": "<p> Sets whether the concentration of species spec in triangular element tri is clamped (clamped = True) or not (clamped = False). If a species is clamped the concentration stays the same regardless of reactions that consume or produce molecules of the species.</p>"}}, "Reaction": {"K": {"@code": ["sim.TRI(tri).sreac['fwd'].K = kf", "sim.TRI(tri).sreac['bkw'].K = kf", "sim.TRIS(triLst).sreac['fwd'].K = kf", "sim.TRIS(triLst).sreac['bkw'].K = kf"], "@doc": "<p> Sets the macroscopic reaction constant of surface reaction with identifier string sreac in triangular element tri to kf. The units of the reaction constant depends on the order of the reaction.</p>"}, "Active": {"@code": ["sim.TRI(tri).sreac['fwd'].Active = active", "sim.TRI(tri).sreac['bkw'].Active = active", "sim.TRIS(triLst).sreac['fwd'].Active = active", "sim.TRIS(triLst).sreac['bkw'].Active = active"], "@doc": "<p> Activate (active = True) or deactivate (active = False) a surface reaction with identifier string sreac in triangular element tri. If it's not active this means that the surface reaction will never occur regardless of whether reactants are present in sufficient numbers or not.</p>"}}, "Diffusion": {"D": {"@code": ["sim.TRI(tri).sdiff.D = dcst", "sim.TRI(tri).sdiff(direc=tri2).D = dcst", "sim.TRIS(triLst).sdiff.D = dcst"], "@doc": "<p> Sets the diffusion constant of diffusion rule with identifier string diff in triangle element tri to dcst. Specify direc to set the constant only towards a given triangle direction.</p>"}}, "V": {"@code": ["sim.TRI(tri).V = val", "sim.TRIS(triLst).V = val"], "@doc": "<p> Set the potential (in volts) of triangle element tri.</p>"}, "VClamped": {"@code": ["sim.TRI(tri).VClamped = clamped", "sim.TRIS(triLst).VClamped = clamped"], "@doc": "<p> Sets whether the potential of triangle element tri is clamped (clamped = True) or not (clamped = False).</p>"}, "IClamp": {"@code": ["sim.TRI(tri).IClamp = i", "sim.TRIS(triLst).IClamp = i"], "@doc": "<p> Set current clamp to triangle element tri to current i (amps). NOTE: Convention is maintained that a positive current clamp is depolarizing, a negative current clamp is hyperpolarizing.</p>"}, "Capac": {"@code": ["sim.TRI(tri).Capac = cap", "sim.TRIS(triLst).Capac = cap"], "@doc": "<p> Sets the specific membrane capacitance (in farad / m^2) of tri tri.</p>"}}, "Membrane": {"Potential": {"@code": ["sim.memb.Potential = val"], "@doc": "<p> Sets the potential (in volts) of membrane with string identifier memb. NOTE: This method will set the potential of all nodes in the volume conductor to the same value.</p>"}, "Capac": {"@code": ["sim.memb.Capac = cap"], "@doc": "<p> Sets the specific membrane capacitance (in farad / m^2) of membrane with string identifier memb.</p>"}, "VolRes": {"@code": ["sim.memb.VolRes = val"], "@doc": "<p> Sets the bulk electrical resistivity (in ohm.m) of the volume conductor assocaited with membrane with string identifier memb.</p>"}, "Res": {"@code": ["sim.memb.Res = steps.utils.Params(ro, vrev)"], "@doc": "<p> Sets the surface electrical resistivity ro (in ohm.m^2) of the membrane with string identifier memb. Reversal potential vrev is required in Volts.</p>"}}, "Vertex": {"V": {"@code": ["sim.VERT(vert).V = val", "sim.VERTS(vertLst).V = val"], "@doc": "<p> Set the potential (in volts) of vertex element vert.</p>"}, "VClamped": {"@code": ["sim.VERT(vert).VClamped = clamped", "sim.VERTS(vertLst).VClamped = clamped"], "@doc": "<p> Sets whether the potential of vertex element vert is clamped (clamped = True) or not (clamped = False).</p>"}, "IClamp": {"@code": ["sim.VERT(vert).IClamp = i", "sim.VERTS(vertLst).IClamp = i"], "@doc": "<p> Set current clamp to vertex element vert to current i (Amps). NOTE: Convention is maintained that a positive current clamp is depolarizing, a negative current clamp is hyperpolarizing.</p>"}}}, "TetVesicle": {"Compartment": {"Species": {"Count": {"@code": ["sim.comp.spec.Count = n"], "@doc": "<p> Sets the number of molecules of species s in compartment c. NOTE: in a mesh-based simulation, the total amount is equally divided over all tetrahedrons in the compartment (i.e. a uniform distribution).</p><p>:param c: Name of the compartment. :type c: str :param s: Name of the species. :type s: str :param n: Number of molecules of the species. :type n: float</p><p> :rtype: None</p>"}, "Conc": {"@code": ["sim.comp.spec.Conc = conc"], "@doc": "<p> Sets the concentration (in molar units) of species s in compartment c. NOTE: in a mesh-based simulation, this method changes the concentration to the same value in all tetrahedrons of the compartment.</p><p>:param c: Name of the compartment. :type c: str :param s: Name of the species. :type s: str :param conc: Concentration of the species. :type conc: float</p><p> :rtype: None</p>"}, "Amount": {"@code": ["sim.comp.spec.Amount = a"], "@doc": "<p> Set the amount (in mols) of species s in compartment c. NOTE: in a mesh-based simulation, the total amount is equally divided over all tetrahedrons in the compartment (i.e. a uniform distribution).</p><p>:param c: Name of the compartment. :type c: str :param s: Name of the species. :type s: str :param a: Amount of the species. :type a: float</p><p> :rtype: None</p>"}, "Clamped": {"@code": ["sim.comp.spec.Clamped = clamped"], "@doc": "<p> Turns clamping of species s in compartment c on or off. NOTE: in a mesh based simulation, this method turns clamping on/off in all tetrahedrons of the compartment.</p><p>:param c: Name of the compartment. :type c: str :param s: Name of the species. :type s: str :param b: Flag to trun clamping of species on / off. :type b: bool</p><p> :rtype: None</p>"}}, "Reaction": {"K": {"@code": ["sim.comp.reac['fwd'].K = kf", "sim.comp.reac['bkw'].K = kf"], "@doc": "<p> Sets the macroscopic reaction constant of reaction r in compartment c (units vary according to the order of the reaction). NOTE: in a mesh-based simulation, this method changes the reaction constant equally in all tetrahedrons of the compartment.</p><p>:param c: Name of the compartment. :type c: str :param r: Name of te reaction. :type r: str :param kf: Reaction constant. :type kf: float</p><p> :rtype: None</p>"}, "Active": {"@code": ["sim.comp.reac['fwd'].Active = active", "sim.comp.reac['bkw'].Active = active"], "@doc": "<p> Activate or inactivate reaction r in compartment c. NOTE: in a mesh-based simulation, activation/inactivation of a reaction turns it on/off in all tetrahedrons.</p><p>:param c: Name of the compartment. :type c: str :param r: Name of the reaction. :type r: str :param a: Flag to activate or deactivate the reaction. :type a: bool</p><p> :rtype: None</p>"}}, "Diffusion": {"Active": {"@code": ["sim.comp.diff.Active = active"], "@doc": "<p> Activate or deactivate diffusion rule d in compartment c.</p><p>:param c: Name of the compartment. :type c: str :param d: Name of the diffusion. :type d: str :param act: Flag to activate or deactivate the diffusion. :type act: bool</p><p> :rtype: None</p>"}, "D": {"@code": ["sim.comp.diff.D = dcst"], "@doc": "<p> Set the diffusion constant of diffusion rule d in compartment c.</p><p>:param c: Name of the compartment. :type c: str :param d: Name of the diffusion. :type d: str :param dcst: Rate constant of the diffusion. :type dcst: float</p><p> :rtype: None</p>"}}, "Vesicle": {"Count": {"@code": ["sim.comp.ves.Count = n"], "@doc": "<p> Sets the number of vesicles v in compartment c</p><p>:param c: Name of the compartment. :type c: str :param v: Name of the vesicle. :type v: str :param n: Number of vesicles :type n: int</p><p> :rtype: None</p>"}}}, "Patch": {"Species": {"Count": {"@code": ["sim.patch.spec.Count = n"], "@doc": "<p> Sets the number of molecules of species s in patch p. NOTE: in a mesh-based simulation, the total amount is equally divided over all triangles in the patch.</p><p>:param p: Name of the patch. :type p: str :param s: Name of the species. :type s: str :param n: Number of molecules of species. :type n: float</p><p> :rtype: None</p>"}, "Amount": {"@code": ["sim.patch.spec.Amount = a"], "@doc": "<p> Sets the amount (in mols) of species s in patch p. NOTE: in a mesh-based simulation, the total amount is equally divided over all triangles in the patch.</p><p>:param p: Name of the patch. :type p: str :param s: Name of the species. :type s: str :param a: Amount of the species. :type a: float</p><p> :rtype: None</p>"}, "Clamped": {"@code": ["sim.patch.spec.Clamped = clamped"], "@doc": "<p> Turns clamping of species in patch p on or off. NOTE: in a mesh-based simulation, this method turns clamping on/off in all triangles in the patch.</p><p>:param p: Name of the patch. :type p: str :param s: Name of the species. :type s: str :param buf: Flag to turn clamping of species on /off. :type buf: bool</p><p> :rtype: None</p>"}}, "Reaction": {"K": {"@code": ["sim.patch.sreac['fwd'].K = kf", "sim.patch.sreac['bkw'].K = kf"], "@doc": "<p> Sets the macroscopic reaction constant of surface reaction r in patch p. NOTE: in a mesh-based simulation this method changes the reaction constant equally in all triangles of the patch.</p><p>:param p: Name of the patch. :type p: str :param r: Name of the reaction. :type r: str :param kf: Rate constant of the reaction. :type kf: float</p><p> :rtype: None</p>"}, "Active": {"@code": ["sim.patch.sreac['fwd'].Active = active", "sim.patch.sreac['bkw'].Active = active"], "@doc": "<p> Activate or inactivate surface reaction r in patch p. NOTE: in a mesh-based simulation, activation/inactivation of a surface reaction turns it on/off in all triangles.</p><p>:param p: Name of the patch. :type p: str :param r: Name of the reaction. :type r: str :param a: Flag to activate / deactivate the reaction. :type a: bool</p><p> :rtype: None</p>"}}, "Raft": {"Count": {"@code": ["sim.patch.raft.Count = n"], "@doc": "<p> Set the number of rafts r in patch p</p><p>:param p: Name of the patch. :type p: str :param r: Name of the raft. :type r: str :param n: Number of rafts :type n: int</p><p> :rtype: None</p>"}}}, "Diff. Boundary": {"Species": {"DiffusionActive": {"@code": ["sim.diffb.spec.DiffusionActive = val"], "@doc": "<p> Activate or inactivate diffusion across a diffusion boundary for a species.</p><p>:param db: Name of the diffusion boundary. :type db: str :param s: Name of the species. :type s: str :param act: Bool to activate (true) or inactivate (false) diffusion. :type act: bool</p><p> :rtype: None</p>"}, "Dcst": {"@code": ["sim.diffb.spec.Dcst = val", "sim.diffb(direc=comp2).spec.Dcst = val"], "@doc": "<p> Set the diffusion constant across a diffusion boundary.</p><p>:param db: Name of the diffusion boundary. :type db: str :param s: Name of the species. :type s: str :param dcst: diffusion constant. :type dcst: float :param direc: ID of the compartment which the diffusion towards to. :type direc: str</p><p> :rtype: None</p>"}}}, "Surf. Diff. Boundary": {"Species": {"DiffusionActive": {"@code": ["sim.sdiffb.spec.DiffusionActive = val"], "@doc": "<p> Activate or inactivate diffusion across a surface diffusion boundary for a species.</p><p>:param sdb: Name of the surface diffusion boundary. :type sdb: str :param s: Name of the species. :type s: str :param act: Bool to activate (true) or inactivate (false) diffusion. :type act: bool</p><p> :rtype: None</p>"}, "Dcst": {"@code": ["sim.sdiffb.spec.Dcst = val", "sim.diffb(direc=patch2).spec.Dcst = val"], "@doc": "<p> Set the diffusion constant across a surface diffusion boundary.</p><p>:param sdb: Name of the surface diffusion boundary. :type sdb: str :param s: Name of the species. :type s: str :param dcst: diffusion constant. :type dcst: float :param direc: ID of the patch which the diffusion is towards to. :type direc: str</p><p> :rtype: None</p>"}}}, "Region of Interest": {"Species": {"Count": {"@code": ["sim.roi.spec.Count = n"], "@doc": "<p> Set the count of a species in a ROI.</p><p>:param roi: :type roi: str :param s: :type s: str :param count: :type count: float</p><p> :rtype: None</p>"}, "Conc": {"@code": ["sim.roi.spec.Conc = conc"], "@doc": "<p> Set the concentration of a species in a ROI.</p><p>:param roi: :type roi: str :param s: :type s: str :param conc: :type conc: float</p><p> :rtype: None</p>"}, "Amount": {"@code": ["sim.roi.spec.Amount = a"], "@doc": "<p> Set the amount of a species in a ROI.</p><p>:param roi: :type roi: str :param s: :type s: str :param amount: :type amount: float</p><p> :rtype: None</p>"}, "Clamped": {"@code": ["sim.roi.spec.Clamped = clamped"], "@doc": "<p> Set a species in a ROI to be clamped or not. The count of species spec in the ROI is clamped if clamped is True, not clamped if clamped is False.</p>"}}, "Reaction": {"K": {"@code": ["sim.roi.reac['fwd'].K = kf", "sim.roi.reac['bkw'].K = kf"], "@doc": "<p> Sets the macroscopic reaction constant of reaction with identifier string r in a ROI with identifier string roi to kf. The unit of the reaction constant depends on the order of the reaction. Note: The default value still comes from the steps.model description, so calling reset() will return the reaction constant to that value.</p><p>:param roi: :type roi: str :param r: :type r: str :param kf: :type kf: float</p><p> :rtype: None</p>"}, "Active": {"@code": ["sim.roi.reac['fwd'].Active = active", "sim.roi.reac['bkw'].Active = active"], "@doc": "<p> Set reaction r in a ROI to be active or not.</p><p>:param roi: :type roi: str :param r: :type r: str :param a: :type a: bool</p><p> :rtype: None</p>"}}, "Diffusion": {"Active": {"@code": ["sim.roi.diff.Active = active"], "@doc": "<p> Set diffusion d in a ROI to be active or not.</p><p>:param roi: :type roi: str :param d: :type d: str :param act: :type act: bool</p><p> :rtype: None</p>"}, "D": {"@code": ["sim.roi.diff.D = dcst", "sim.roi.diff(direc=tet2).D = dcst"], "@doc": "<p> Sets the macroscopic diffusion constant of diffusion with identifier string diff in a ROI with identifier string roi to dcst.</p><p>Note: The default value still comes from the steps.model description, so calling reset() will return the diffusion constant to that value.</p>"}}}, "Tetrahedron": {"Species": {"Count": {"@code": ["sim.TET(tet).spec.Count = n", "sim.TETS(tetLst).spec.Count = n"], "@doc": "<p> Sets the number of molecules of species s in a tetrahedron</p><p>:param idx: Index of the tetrahedron. :type idx: steps.index_t :param s: Name of the species. :type s: str :param n: Number of molecules of the species. :type n: float</p><p> :rtype: None</p>"}, "Conc": {"@code": ["sim.TET(tet).spec.Conc = conc", "sim.TETS(tetLst).spec.Conc = conc"], "@doc": "<p> Sets the concentration (in molar units) of species s in a tetrahedron.</p><p>:param idx: Index of the tetrahedron. :type idx: steps.index_t :param s: Name of the species. :type s: str :param c: Concentration of the species. :type c: float</p><p> :rtype: None</p>"}, "Amount": {"@code": ["sim.TET(tet).spec.Amount = a", "sim.TETS(tetLst).spec.Amount = a"], "@doc": "<p> Sets the amount (in mols) of species s in a tetrahedron.</p><p>:param idx: Index of the tetrahedron. :type idx: steps.index_t :param s: Name of the species. :type s: str :param m: Amount of the species. :type m: float</p><p> :rtype: None</p>"}, "Clamped": {"@code": ["sim.TET(tet).spec.Clamped = clamped", "sim.TETS(tetLst).spec.Clamped = clamped"], "@doc": "<p> Sets clamping of species s in a tetrahedron on or off.</p><p>:param idx: Index of the tetrahedron. :type idx: steps.index_t :param s: Name of the species. :type s: str :param buf: Flag to turn the clamping of species on or off. :type buf: bool</p><p> :rtype: None</p>"}}, "Reaction": {"K": {"@code": ["sim.TET(tet).reac['fwd'].K = kf", "sim.TET(tet).reac['bkw'].K = kf", "sim.TETS(tetLst).reac['fwd'].K = kf", "sim.TETS(tetLst).reac['bkw'].K = kf"], "@doc": "<p> Sets the macroscopic reaction constant of reaction r in a tetrahedron.</p><p>:param idx: Index of the tetrahedron. :type idx: steps.index_t :param r: Name of the reaction. :type r: str :param kf: Rate constant of the reaction. :type kf: float</p><p> :rtype: None</p>"}, "Active": {"@code": ["sim.TET(tet).reac['fwd'].Active = active", "sim.TET(tet).reac['bkw'].Active = active", "sim.TETS(tetLst).reac['fwd'].Active = active", "sim.TETS(tetLst).reac['bkw'].Active = active"], "@doc": "<p> Activates/deactivates reaction r in a tetrahedron.</p><p>:param idx: Index of the tetrahedron. :type idx: steps.index_t :param r: Name of the reaction. :type r: str :param act: Flag to activate or deactivate the reaction. :type act: bool</p><p> :rtype: None</p>"}}, "Diffusion": {"Active": {"@code": ["sim.TET(tet).diff.Active = active", "sim.TETS(tetLst).diff.Active = active"], "@doc": "<p> Activates/deactivates diffusion rule d in a tetrahedron.</p><p>:param idx: Index of the tetrahedron. :type idx: steps.index_t :param d: Name of the diffusion. :type d: str :param act: Flag to activate / deactivate the diffusion. :type act: bool</p><p> :rtype: None</p>"}, "D": {"@code": ["sim.TET(tet).diff.D = dcst", "sim.TET(tet).diff(direc=tet2).D = dcst", "sim.TETS(tetLst).diff.D = dcst"], "@doc": "<p> Sets the diffusion constant of diffusion rule d in a tetrahedron.</p><p>:param idx: Index of the tetrahedron. :type idx: steps.index_t :param d: Name of the diffusion. :type d: str :param dk: Rate constant of the diffusion. :type dk: float :param direc: Tetrahedron index which the diffusion towards. :type direc: steps.index_t</p><p> :rtype: None</p>"}}, "Vesicle": {"Dcst": {"@code": ["sim.TET(tet).ves.Dcst = val", "sim.TETS(tetLst).ves.Dcst = val"], "@doc": "<p> Set the diffusion rate per tetrahedron of vesicles of type v. Vesicles will use this diffusion rate when vesicle centre is in this tet.</p><p>:param idx: Tetrahrdron index :type idx: steps.index_t :param v: Name of the vesicle. :type v: str :param dcst: Diffusion coefficient :type dcst: float</p><p> :rtype: None</p>"}}, "Vol": {"@code": ["sim.TET(tet).Vol = val", "sim.TETS(tetLst).Vol = val"], "@doc": "<p> Set the volume of a tetrahedron (in m^3).</p><p>:param idx: Index of the tetrahedron. :type idx: steps.index_t :param vol: Volume of the tetrahedron. :type vol: float</p><p> :rtype: None</p>"}, "V": {"@code": ["sim.TET(tet).V = val", "sim.TETS(tetLst).V = val"], "@doc": "<p> Set the potential of tetrahedron.</p><p>:param idx: Index of the tetrahedron :type idx: steps.index_t :param v: :type v: float</p><p> :rtype: None</p>"}, "VClamped": {"@code": ["sim.TET(tet).VClamped = clamped", "sim.TETS(tetLst).VClamped = clamped"], "@doc": "<p> Sets voltage clamp in tetrahedron.</p><p>:param idx: Index of the tetrahedron :type idx: steps.index_t :param cl: Flag to turn the clamping on or off. :type cl: bool</p><p> :rtype: None</p>"}}, "Triangle": {"Species": {"Count": {"@code": ["sim.TRI(tri).spec.Count = n", "sim.TRIS(triLst).spec.Count = n"], "@doc": "<p> Sets the number of molecules of species s in a triangle.</p><p>:param idx: Index of the triangle. :type idx: steps.index_t :param s: Name of the species. :type s: str :param n: Number of molecules of the species. :type n: float</p><p> :rtype: None</p>"}, "Amount": {"@code": ["sim.TRI(tri).spec.Amount = a", "sim.TRIS(triLst).spec.Amount = a"], "@doc": "<p> Sets the amount (in mols) of species s in a triangle.</p><p>:param idx: Index of the triangle. :type idx: steps.index_t :param s: Name of the species. :type s: str :param m: Amount of the species. :type m: float</p><p> :rtype: None</p>"}, "Clamped": {"@code": ["sim.TRI(tri).spec.Clamped = clamped", "sim.TRIS(triLst).spec.Clamped = clamped"], "@doc": "<p> Sets clamping of species s in a triangle on or off.</p><p>:param idx: Index of the triangle. :type idx: steps.index_t :param s: name of the species. :type s: str :param buf: Flag to set clamping of species on /off. :type buf: bool</p><p> :rtype: None</p>"}}, "Reaction": {"K": {"@code": ["sim.TRI(tri).sreac['fwd'].K = kf", "sim.TRI(tri).sreac['bkw'].K = kf", "sim.TRIS(triLst).sreac['fwd'].K = kf", "sim.TRIS(triLst).sreac['bkw'].K = kf"], "@doc": "<p> Sets the macroscopic reaction constant of surface reaction r in a triangle.</p><p>:param idx: Index of the triangle. :type idx: steps.index_t :param r: name of the reaction. :type r: str :param kf: Rate constant of the reaction. :type kf: float</p><p> :rtype: None</p>"}, "Active": {"@code": ["sim.TRI(tri).sreac['fwd'].Active = active", "sim.TRI(tri).sreac['bkw'].Active = active", "sim.TRIS(triLst).sreac['fwd'].Active = active", "sim.TRIS(triLst).sreac['bkw'].Active = active"], "@doc": "<p> Activates/inactivates surface reaction r in a triangle.</p><p>:param idx: Index of the triangle. :type idx: steps.index_t :param r: name of the reaction. :type r: str :param act: Flag to activate / deactivate the reaction. :type act: bool</p><p> :rtype: None</p>"}}, "Diffusion": {"D": {"@code": ["sim.TRI(tri).diff.D = dcst", "sim.TRI(tri).diff(direc=tet2).D = dcst", "sim.TRIS(triLst).diff.D = dcst"], "@doc": "<p> outdated function</p><p>:param idx: :type idx: steps.index_t :param d: :type d: str :param dk: :type dk: float :param direc: :type direc: steps.index_t</p><p> :rtype: None</p>"}}, "Raft": {"Count": {"@code": ["sim.TRI(tri).raft.Count = n", "sim.TRIS(triLst).raft.Count = n"], "@doc": "<p> Returns the number of rafts in a triangle</p><p>:param idx: Index of the triangle. :type idx: steps.index_t :param r: Name of the raft. :type r: str :param n: Number of rafts :type n: int</p><p> :rtype: None</p>"}}, "Exocytosis": {"Active": {"@code": ["sim.TRI(tri).exo.Active = active", "sim.TRIS(triLst).exo.Active = active"], "@doc": "<p> Activates/inactivates exocytotic reaction in a triangle.</p><p>:param idx: Index of the triangle. :type idx: steps.index_t :param er: name of the exocytotic reaction. :type er: str :param act: Flag to activate / deactivate the exocytotic reaction. :type act: bool</p><p> :rtype: None</p>"}}, "Area": {"@code": ["sim.TRI(tri).Area = val", "sim.TRIS(triLst).Area = val"], "@doc": "<p> Set the area (in m^2) of the triangle.</p><p>:param idx: Index of the triangle. :type idx: steps.index_t :param area: Area of teh triangle. :type area: float</p><p> :rtype: None</p>"}, "V": {"@code": ["sim.TRI(tri).V = val", "sim.TRIS(triLst).V = val"], "@doc": "<p> Set the potential of triangle.</p><p>:param idx: Index of the triangle :type idx: steps.index_t :param v: :type v: float</p><p> :rtype: None</p>"}, "VClamped": {"@code": ["sim.TRI(tri).VClamped = clamped", "sim.TRIS(triLst).VClamped = clamped"], "@doc": "<p> Sets voltage clamp in triangle.</p><p>:param idx: Index of the triangle :type idx: steps.index_t :param cl: Flag to turn the clamping on or off. :type cl: bool</p><p> :rtype: None</p>"}, "IClamp": {"@code": ["sim.TRI(tri).IClamp = i", "sim.TRIS(triLst).IClamp = i"], "@doc": "<p> Sets current injection to triangle. Will be assumed to be constant for one EField DT</p><p>:param idx: Index of the triangle :type idx: steps.index_t :param i: :type i: float</p><p> :rtype: None</p>"}, "Capac": {"@code": ["sim.TRI(tri).Capac = cap", "sim.TRIS(triLst).Capac = cap"], "@doc": "<p> Set the specific capacitance of a triangle surface element.</p><p>:param idx: Index of the triangle surface element :type idx: steps.index_t :param cm: Specific membrane capacitance (farad / m^2) :type cm: float</p><p> :rtype: None</p>"}}, "Vesicle": {"Reaction": {"K": {"@code": ["sim.ves.sreac['fwd'].K = kf", "sim.ves.sreac['bkw'].K = kf"], "@doc": "<p></p><p>:param vsr: Name of the vesicle surface reaction :type vsr: str :param kf: Rate :type kf: float</p><p> :rtype: None</p>"}}}, "Vesicle surface": {"Species": {"Count": {"@code": ["sim.VESICLE(vesref)('surf').spec.Count = n", "sim.VESICLES(vesLst)('surf').spec.Count = n"], "@doc": "<p> Set the surface count of species s on vesicle of type v and unique index ves_unique_index.</p><p>:param v: Name of the vesicle. :type v: str :param ves_unique_index: Unique index of the individual vesicle :type ves_unique_index: steps.index_t :param s: Name of the species :type s: str :param count: The number of the surface species :type count: int</p><p> :rtype: None</p>"}, "PosSpherical": {"@code": ["sim.VESICLE(vesref)('surf').spec.PosSpherical = spos", "sim.VESICLES(vesLst)('surf').spec.PosSpherical = spos"], "@doc": "<p> Set the spherical coordinates of species s on vesicle of type v and unique index ves_unique_index.</p><p>:param v: Name of the vesicle. :type v: str :param ves_unique_index: Unique index of the individual vesicle :type ves_unique_index: steps.index_t :param s: Name of the species :type s: str :param pos_spherical: Position of the molecule in spherical coordinates (relative to the vesicle) :type pos_spherical: List[float]</p><p> :rtype: None</p>"}}}, "Vesicle inside": {"Species": {"Count": {"@code": ["sim.VESICLE(vesref)('in').spec.Count = n", "sim.VESICLES(vesLst)('in').spec.Count = n"], "@doc": "<p> Set the count of the inner species, that is inside the vesicle volume, on vesicle of type v and unique index ves_unique_index.</p><p>:param v: Name of the vesicle. :type v: str :param ves_unique_index: Unique index of the individual vesicle :type ves_unique_index: steps.index_t :param s: Name of the species :type s: str :param count: The number of the inner species :type count: int</p><p> :rtype: None</p>"}}}, "Raft": {"Species": {"Count": {"@code": ["sim.RAFT(raftref).spec.Count = n", "sim.RAFTS(raftLst).spec.Count = n"], "@doc": "<p> Set the count of species s on raft of type r and unique index raft_unique_index.</p><p>:param r: Name of the raft. :type r: str :param raft_unique_index: Unique index of the individual raft. :type raft_unique_index: steps.index_t :param s: Name of the species :type s: str :param count: The number of the species :type count: int</p><p> :rtype: None</p>"}}, "Reaction": {"Active": {"@code": ["sim.RAFT(raftref).sreac['fwd'].Active = active", "sim.RAFT(raftref).sreac['bkw'].Active = active", "sim.RAFTS(raftLst).sreac['fwd'].Active = active", "sim.RAFTS(raftLst).sreac['bkw'].Active = active"], "@doc": "<p> Activate or de-activate a raft surface reaction on a raft</p><p>:param r: Name of the raft. :type r: str :param raft_unique_index: Unique index of the individual raft. :type raft_unique_index: steps.index_t :param rsreac: Name of the raft surface reaction :type rsreac: str :param active: Whether the raftsreac should be active :type active: bool</p><p> :rtype: None</p>"}}, "Raft Endocytosis": {"K": {"@code": ["sim.RAFT(raftref).rendo.K = kf", "sim.RAFTS(raftLst).rendo.K = kf"], "@doc": "<p> Set the raft endocytosis rate of a raft</p><p>:param r: Name of the raft. :type r: str :param raft_unique_index: Unique index of the individual raft. :type raft_unique_index: steps.index_t :param rendo: Name of the raft endocytosis :type rendo: str :param k: Rate. :type k: float</p><p> :rtype: None</p>"}}}, "Membrane": {"Potential": {"@code": ["sim.memb.Potential = val"], "@doc": "<p> Set the electric potential of the membrane, including all nodes in the conduction volume.</p><p>:param m: Name of the membrane :type m: str :param v: Potential (volts) :type v: float</p><p> :rtype: None</p>"}, "Capac": {"@code": ["sim.memb.Capac = cap"], "@doc": "<p> Set the specific membrane capacitance of the membrane</p><p>:param m: Name of the membrane :type m: str :param cm: Specific membrane capacitance (farad / m^2) :type cm: float</p><p> :rtype: None</p>"}, "VolRes": {"@code": ["sim.memb.VolRes = val"], "@doc": "<p> Set the bulk electrical resistivity of the section of the mesh representing the volume conductor</p><p>:param m: Name of the membrane :type m: str :param ro: Electrical resistivity (ohm.m) :type ro: float</p><p> :rtype: None</p>"}, "Res": {"@code": ["sim.memb.Res = steps.utils.Params(ro, vrev)"], "@doc": "<p> Sets the surface electrical resistivity ro (in ohm.m^2) of the membrane with string identifier memb. Reversal potential vrev is required in Volts.</p><p>:param m: Name of the membrane :type m: str :param ro: membrane resistivity (ohm.m^2) :type ro: float :param vrev: Reversal potential (Volts) :type vrev: float</p><p> :rtype: None</p>"}}, "Vertex": {"V": {"@code": ["sim.VERT(vert).V = val", "sim.VERTS(vertLst).V = val"], "@doc": "<p> Set the potential of vertex.</p><p>:param vidx: Index of the vertex :type vidx: steps.index_t :param v: :type v: float</p><p> :rtype: None</p>"}, "VClamped": {"@code": ["sim.VERT(vert).VClamped = clamped", "sim.VERTS(vertLst).VClamped = clamped"], "@doc": "<p> Sets voltage clamp in vertex.</p><p>:param vidx: Index of the vertex :type vidx: steps.index_t :param cl: Flag to turn the clamping on or off. :type cl: bool</p><p> :rtype: None</p>"}, "IClamp": {"@code": ["sim.VERT(vert).IClamp = i", "sim.VERTS(vertLst).IClamp = i"], "@doc": "<p> Sets current injection to vertex. Will be assumed to be constant for one EField DT</p><p>:param vidx: Index of the vertex :type vidx: steps.index_t :param i: :type i: float</p><p> :rtype: None</p>"}}, "Exocytosis": {"K": {"@code": ["sim.exo.K = kf"], "@doc": "<p> Set rate of exocytosis events. Not compartment-specific.</p><p>:param exo: Name of the vesicle exocytosis :type exo: str :param kf: Rate :type kf: float</p><p> :rtype: None</p>"}}, "Raft Endocytosis": {"K": {"@code": ["sim.rendo.K = kf"], "@doc": "<p> Set the rate of raft endocytosis. Not patch-specific.</p><p>:param rendo: Name of the raft endocytosis :type rendo: str :param kcst: Rate of the raft endocytosis :type kcst: double</p><p></p>"}}}, "DistTetOpSplit": {"Compartment": {"Species": {"Count": {"@code": ["sim.comp.spec.Count = n", "sim.comp.spec.Count = steps.utils.Params(n, distributionMethod=DistributionMethod.UNIFORM)"], "@doc": "<p> Set the number of molecules of a species with identifier string spec in compartment with identifier string comp.</p><p>In a mesh-based simulation this is the combined count from all tetrahedral elements in the compartment.</p><p>The distributing is weighted with the volume fraction V_tet/V_tot: bigger elements get a higher amount of molecules.</p><p>distributionMethod=UNIFORM the distribution is deterministic (apart from roundings) and the number of molecules per element is n*V_tet/V_tot.</p><p>distributionMethod=MULTINOMIAL the distribution is multinomial and the probability of putting an element in a tet is V_tet/V_tot</p>"}, "Conc": {"@code": ["sim.comp.spec.Conc = conc", "sim.comp.spec.Conc = steps.utils.Params(conc, distributionMethod=DistributionMethod.UNIFORM)"], "@doc": "<p> Sets the concentration (in Molar units) of species with identifier string spec in compartment with identifier string comp to conc. In a discrete solver the continuous concentration is converted to a discrete number of molecules.</p><p>In a mesh-based simulation this is the combined count from all tetrahedral elements in the compartment.</p><p>The distributing is weighted with the volume fraction V_tet/V_tot: bigger elements get a higher amount of molecules.</p><p>distributionMethod=UNIFORM the distribution is deterministic (apart from roundings) and the number of molecules per element is n*V_tet/V_tot.</p><p>distributionMethod=MULTINOMIAL the distribution is multinomial and the probability of putting an element in a tet is V_tet/V_tot</p>"}}}, "Patch": {"Species": {"Count": {"@code": ["sim.patch.spec.Count = n", "sim.patch.spec.Count = steps.utils.Params(n, distributionMethod=DistributionMethod.UNIFORM)"], "@doc": "<p> Sets the number of molecules of species with identifier string spec in patch with identifier string pat to n.</p><p> Note: In case of a mesh-based simulation the molecules, molecules are divided among triangles.</p><p>distributionMethod=UNIFORM the distribution is deterministic (apart from roundings) and the number of molecules per element is n*V_tet/V_tot.</p><p>distributionMethod=DIST_MULTINOMIAL the distribution is multinomial and the probability of putting an element in a tet is V_tet/V_tot</p>"}}, "Reaction": {"K": {"@code": ["sim.patch.sreac['fwd'].K = kf", "sim.patch.sreac['bkw'].K = kf"], "@doc": "<p> Sets the macroscopic reaction constant of surface reaction with identifier string sreac in patch with identifier string pat to kf. The unit of the reaction constant depends on the order of the reaction.</p><p>Note: In a mesh-based simulation this method sets the surface reaction constant in all triangular elements of the patch to kf.</p><p>Note: The default value still comes from the steps.model description, so calling reset() will return the surface reaction constant to that value.</p>"}}}, "Diff. Boundary": {"Species": {"DiffusionActive": {"@code": ["sim.diffb.spec.DiffusionActive = val"], "@doc": "<p> Activates or inactivates diffusion across a diffusion boundary for a species.</p>"}}}, "Tetrahedron": {"Species": {"Count": {"@code": ["sim.TET(tet).spec.Count = n", "sim.TETS(tetLst).spec.Count = n"], "@doc": "<p> Sets the number of molecules of species with identifier string spec in tetrahedral element tet to n.</p>"}, "Conc": {"@code": ["sim.TET(tet).spec.Conc = conc", "sim.TETS(tetLst).spec.Conc = conc"], "@doc": "<p> Sets the concentration (in Molar units) of species with identifier string spec in a tetrahedral element tet to conc.This continuous value must be converted internally to a discrete number of molecules.</p><p>Due to the small volumes of tetrahedral elements the difference between 'rounding up' and 'rounding down' can be a large difference in concentration.</p>"}}}, "Triangle": {"Species": {"Count": {"@code": ["sim.TRI(tri).spec.Count = n", "sim.TRIS(triLst).spec.Count = n"], "@doc": "<p> Sets the number of molecules of species with identifier string spec in triangular element tri to n.</p>"}}}, "Membrane": {"IClamp": {"@code": ["sim.memb.IClamp = i"], "@doc": "<p> Set a current clamp on a membrane</p>"}, "Potential": {"@code": ["sim.memb.Potential = val"], "@doc": "<p> Sets the potential (in volts) of membrane with string identifier memb. NOTE: This method will set the potential of all nodes in the volume conductor to the same value.</p>"}, "Res": {"@code": ["sim.memb.Res = steps.utils.Params(ro, vrev)"], "@doc": "<p> Sets the surface electrical resistivity ro (in ohm.m^2) of the membrane with string identifier memb. Reversal potential vrev is required in Volts.</p>"}}, "Vertex": {"IClamp": {"@code": ["sim.VERT(vert).IClamp = i", "sim.VERTS(vertLst).IClamp = i"], "@doc": "<p> Set the current clamp on the vertex vert, in ampere. NOTE: Convention is maintained that a positive current clamp is depolarizing, a negative current clamp is hyperpolarizing.</p>"}}}}}